---
title: "L09 - åŠ¨æ€è§„åˆ’"
description: "æ·±å…¥å­¦ä¹ åŠ¨æ€è§„åˆ’ç®—æ³•ï¼ŒæŒæ¡æœ€ä¼˜å­ç»“æ„ã€é‡å å­é—®é¢˜ã€çŠ¶æ€è½¬ç§»ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œè§£å†³å¤æ‚ä¼˜åŒ–é—®é¢˜"
date: "2024-01-09"
category: "ç®—æ³•"
difficulty: "é«˜çº§"
tags: ["åŠ¨æ€è§„åˆ’", "æœ€ä¼˜å­ç»“æ„", "çŠ¶æ€è½¬ç§»", "èƒŒåŒ…é—®é¢˜", "å­—ç¬¦ä¸²å¤„ç†"]
duration: "4å°æ—¶"
prerequisites: ["L03-åŸºç¡€æ•°æ®ç»“æ„", "L04-æ ‘ä¸äºŒå‰æœç´¢"]
next: ["L10-å­—ç¬¦ä¸²ç®—æ³•"]
math: true
interactive: true
---

import { CodeBlock } from '@/src/components/algorithm/CodeBlock';
import { AlgorithmVisualizer } from '@/src/components/algorithm/AlgorithmVisualizer';
import { ArrayVisualizer } from '@/src/components/algorithm/ArrayVisualizer';
import { ComplexityAnalyzer } from '@/src/components/algorithm/ComplexityAnalyzer';
import { TreeVisualizer } from '@/src/components/algorithm/TreeVisualizer';
import { ExerciseBlock } from '@/src/components/algorithm/ExerciseBlock';

# L09 - åŠ¨æ€è§„åˆ’

## å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬è¯¾ç¨‹ï¼Œä½ å°†ï¼š

- ğŸ” **æŒæ¡åŠ¨æ€è§„åˆ’çš„åŸºæœ¬åŸç†å’Œæ€æƒ³**ï¼Œç†è§£æœ€ä¼˜å­ç»“æ„å’Œé‡å å­é—®é¢˜æ¦‚å¿µ
- ğŸ§® **å­¦ä¼šè¯†åˆ«å’Œè§£å†³åŠ¨æ€è§„åˆ’é—®é¢˜**ï¼ŒæŒæ¡é—®é¢˜åˆ†æå’Œå»ºæ¨¡æŠ€å·§
- âš¡ **ç†è§£çŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„è®¾è®¡æ–¹æ³•**ï¼Œèƒ½å¤Ÿæ„å»ºé«˜æ•ˆçš„DPè§£å†³æ–¹æ¡ˆ
- ğŸŒ **èƒ½å¤Ÿåº”ç”¨åŠ¨æ€è§„åˆ’è§£å†³å¤æ‚ä¼˜åŒ–é—®é¢˜**ï¼Œæ¶µç›–å¤šä¸ªåº”ç”¨é¢†åŸŸ

## åŠ¨æ€è§„åˆ’åŸºç¡€

### æ ¸å¿ƒæ¦‚å¿µ

**åŠ¨æ€è§„åˆ’**æ˜¯ä¸€ç§è§£å†³å¤æ‚é—®é¢˜çš„å¼ºå¤§æ–¹æ³•ï¼Œé€šè¿‡å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜å¹¶å­˜å‚¨å­é—®é¢˜çš„è§£æ¥é¿å…é‡å¤è®¡ç®—ã€‚

#### æ ¸å¿ƒè¦ç´ 

<AlgorithmVisualizer
  title="åŠ¨æ€è§„åˆ’æ ¸å¿ƒè¦ç´ "
  algorithm="dp-concepts"
  steps={[
    {
      title: "æœ€ä¼˜å­ç»“æ„",
      content: "é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£",
      formula: "OPT(n) = min{OPT(i) + cost(i,n) | i âˆˆ [0,n-1]}"
    },
    {
      title: "é‡å å­é—®é¢˜",
      content: "é€’å½’æ±‚è§£æ—¶ä¼šé‡å¤è®¡ç®—ç›¸åŒçš„å­é—®é¢˜",
      formula: "T(n) = Î£ T(i) * T(n-i-1) å¯¼è‡´æŒ‡æ•°å¤æ‚åº¦"
    },
    {
      title: "çŠ¶æ€å®šä¹‰",
      content: "æè¿°é—®é¢˜å½“å‰çŠ¶å†µçš„å˜é‡ç»„åˆ",
      formula: "dp[i][j] = f(i,j) å…¶ä¸­i,jä¸ºçŠ¶æ€å˜é‡"
    },
    {
      title: "çŠ¶æ€è½¬ç§»",
      content: "ä»ä¸€ä¸ªçŠ¶æ€åˆ°å¦ä¸€ä¸ªçŠ¶æ€çš„è½¬æ¢è§„åˆ™",
      formula: "dp[i][j] = min{dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + cost}"
    },
    {
      title: "è¾¹ç•Œæ¡ä»¶",
      content: "é—®é¢˜çš„åˆå§‹æˆ–ç»ˆæ­¢æ¡ä»¶",
      formula: "dp[0][j] = 0, dp[i][0] = 0 (åˆå§‹åŒ–)"
    }
  ]}
/>

### è§£å†³åŠ¨æ€è§„åˆ’é—®é¢˜çš„äº”æ­¥æ³•

<AlgorithmVisualizer
  title="åŠ¨æ€è§„åˆ’è§£é¢˜æ­¥éª¤"
  algorithm="dp-steps"
  steps={[
    {
      title: "1. å®šä¹‰çŠ¶æ€",
      content: "ç¡®å®šæè¿°é—®é¢˜çš„çŠ¶æ€å˜é‡",
      details: [
        "è¯†åˆ«é—®é¢˜çš„å…³é”®å‚æ•°",
        "ç¡®å®šçŠ¶æ€ç©ºé—´çš„ç»´åº¦",
        "é€‰æ‹©åˆé€‚çš„çŠ¶æ€è¡¨ç¤º"
      ],
      example: "dp[i] = å‰iä¸ªå…ƒç´ çš„æœ€ä¼˜è§£"
    },
    {
      title: "2. çŠ¶æ€è½¬ç§»æ–¹ç¨‹",
      content: "æ‰¾å‡ºçŠ¶æ€ä¹‹é—´çš„å…³ç³»",
      details: [
        "åˆ†æå†³ç­–çš„å¯èƒ½æ€§",
        "å»ºç«‹é€’æ¨å…³ç³»",
        "ç¡®ä¿æ— åæ•ˆæ€§"
      ],
      example: "dp[i] = min{dp[i-1], dp[i-2] + cost}"
    },
    {
      title: "3. è¾¹ç•Œæ¡ä»¶",
      content: "ç¡®å®šåˆå§‹çŠ¶æ€å’Œç»ˆæ­¢çŠ¶æ€",
      details: [
        "è®¾ç½®åŸºç¡€æƒ…å†µ",
        "å¤„ç†è¾¹ç•Œæƒ…å†µ",
        "ç¡®ä¿å®Œæ•´æ€§"
      ],
      example: "dp[0] = 0, dp[1] = cost[0]"
    },
    {
      title: "4. è®¡ç®—é¡ºåº",
      content: "ç¡®å®šçŠ¶æ€çš„è®¡ç®—é¡ºåº",
      details: [
        "è¯†åˆ«ä¾èµ–å…³ç³»",
        "é€‰æ‹©è®¡ç®—æ–¹å‘",
        "é¿å…å¾ªç¯ä¾èµ–"
      ],
      example: "ä»å°åˆ°å¤§è®¡ç®—: dp[1] â†’ dp[2] â†’ ... â†’ dp[n]"
    },
    {
      title: "5. ç©ºé—´ä¼˜åŒ–",
      content: "å°½å¯èƒ½å‡å°‘ç©ºé—´å¤æ‚åº¦",
      details: [
        "è¯†åˆ«å¯å¤ç”¨çš„ç©ºé—´",
        "ä½¿ç”¨æ»šåŠ¨æ•°ç»„",
        "åº”ç”¨å‹ç¼©æŠ€å·§"
      ],
      example: "dp[i][j] â†’ dp[j] (ç©ºé—´ä»O(nÂ²)â†’O(n))"
    }
  ]}
/>

## åŸºç¡€åŠ¨æ€è§„åˆ’é—®é¢˜

### 1. æ–æ³¢é‚£å¥‘æ•°åˆ—

<CodeBlock
  title="æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å¤šç§è§£æ³•"
  code={`def fibonacci_recursive(n: int) -> int:
    """é€’å½’æ–æ³¢é‚£å¥‘æ•°åˆ—

    æ—¶é—´å¤æ‚åº¦: O(2^n) - æŒ‡æ•°çº§
    ç©ºé—´å¤æ‚åº¦: O(n) - è°ƒç”¨æ ˆæ·±åº¦

    é—®é¢˜: å¤§é‡é‡å¤è®¡ç®—ï¼Œæ•ˆç‡æä½
    """
    if n <= 1:
        return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

def fibonacci_memoization(n: int, memo=None) -> int:
    """è®°å¿†åŒ–é€’å½’æ–æ³¢é‚£å¥‘æ•°åˆ—

    æ—¶é—´å¤æ‚åº¦: O(n) - æ¯ä¸ªå­é—®é¢˜åªè®¡ç®—ä¸€æ¬¡
    ç©ºé—´å¤æ‚åº¦: O(n) - å­˜å‚¨æ‰€æœ‰å­é—®é¢˜çš„è§£

    æ”¹è¿›: é¿å…é‡å¤è®¡ç®—ï¼Œæ˜¾è‘—æå‡æ€§èƒ½
    """
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n <= 1:
        return n

    memo[n] = fibonacci_memoization(n-1, memo) + fibonacci_memoization(n-2, memo)
    return memo[n]

def fibonacci_iterative(n: int) -> int:
    """è¿­ä»£æ–æ³¢é‚£å¥‘æ•°åˆ—

    æ—¶é—´å¤æ‚åº¦: O(n) - çº¿æ€§æ—¶é—´
    ç©ºé—´å¤æ‚åº¦: O(1) - å¸¸æ•°ç©ºé—´

    ä¼˜åŒ–: æ¶ˆé™¤é€’å½’å¼€é”€ï¼Œç©ºé—´æœ€ä¼˜
    """
    if n <= 1:
        return n

    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b

    return b

def fibonacci_matrix(n: int) -> int:
    """çŸ©é˜µå¿«é€Ÿå¹‚æ–æ³¢é‚£å¥‘æ•°åˆ—

    æ—¶é—´å¤æ‚åº¦: O(log n) - å¯¹æ•°æ—¶é—´
    ç©ºé—´å¤æ‚åº¦: O(1) - å¸¸æ•°ç©ºé—´

    æ•°å­¦åŸç†: åˆ©ç”¨çŸ©é˜µä¹˜æ³•çš„ç»“åˆå¾‹
    """
    def matrix_multiply(a, b):
        """2x2çŸ©é˜µä¹˜æ³•"""
        return [
            [a[0][0] * b[0][0] + a[0][1] * b[1][0],
             a[0][0] * b[0][1] + a[0][1] * b[1][1]
        ], [
            a[1][0] * b[0][0] + a[1][1] * b[1][0],
             a[1][0] * b[0][1] + a[1][1] * b[1][1]
        ]

    def matrix_pow(mat, power):
        """çŸ©é˜µå¿«é€Ÿå¹‚"""
        result = [[1, 0], [0, 1]]  # å•ä½çŸ©é˜µ
        while power > 0:
            if power % 2 == 1:
                result = matrix_multiply(result, mat)
            mat = matrix_multiply(mat, mat)
            power //= 2
        return result

    if n <= 1:
        return n

    # æ–æ³¢é‚£å¥‘å˜æ¢çŸ©é˜µ
    mat = [[1, 1], [1, 0]]
    result = matrix_pow(mat, n - 1)
    return result[0][0]

def fibonacci_mathematical(n: int) -> int:
    """æ•°å­¦å…¬å¼æ³•ï¼ˆBinet's Formulaï¼‰

    æ—¶é—´å¤æ‚åº¦: O(1) - å¸¸æ•°æ—¶é—´
    ç©ºé—´å¤æ‚åº¦: O(1) - å¸¸æ•°ç©ºé—´

    æ³¨æ„: æµ®ç‚¹æ•°ç²¾åº¦é™åˆ¶ï¼Œé€‚åˆnè¾ƒå°æ—¶ä½¿ç”¨
    """
    import math
    sqrt5 = math.sqrt(5)
    phi = (1 + sqrt5) / 2
    psi = (1 - sqrt5) / 2

    return int((phi**n - psi**n) / sqrt5)`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. çˆ¬æ¥¼æ¢¯é—®é¢˜

<CodeBlock
  title="çˆ¬æ¥¼æ¢¯é—®é¢˜çš„å¤šç§å˜ä½“"
  code={`def climb_stairs(n: int) -> int:
    """çˆ¬æ¥¼æ¢¯é—®é¢˜ï¼šæ¯æ¬¡å¯ä»¥çˆ¬1æˆ–2ä¸ªå°é˜¶

    çŠ¶æ€å®šä¹‰: dp[i] = çˆ¬åˆ°ç¬¬ié˜¶çš„æ–¹æ³•æ•°
    çŠ¶æ€è½¬ç§»: dp[i] = dp[i-1] + dp[i-2]
    è¾¹ç•Œæ¡ä»¶: dp[0] = 1, dp[1] = 1

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if n <= 2:
        return n

    dp = [0] * (n + 1)
    dp[0] = 1  # åœ°é¢
    dp[1] = 1
    dp[2] = 2

    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

def climb_stairs_optimized(n: int) -> int:
    """ç©ºé—´ä¼˜åŒ–çš„çˆ¬æ¥¼æ¢¯é—®é¢˜

    ç©ºé—´å¤æ‚åº¦: O(1) - åªéœ€è¦å¸¸æ•°ç©ºé—´
    """
    if n <= 2:
        return n

    a, b = 1, 2  # dp[1], dp[2]
    for _ in range(3, n + 1):
        a, b = b, a + b

    return b

def climb_stairs_general(n: int, steps: list) -> int:
    """é€šç”¨çˆ¬æ¥¼æ¢¯é—®é¢˜ï¼šæ¯æ¬¡å¯ä»¥çˆ¬stepsä¸­çš„ä»»æ„æ­¥æ•°

    çŠ¶æ€è½¬ç§»: dp[i] = Î£ dp[i-step] for step in steps if i >= step

    æ—¶é—´å¤æ‚åº¦: O(n * k) - kä¸ºæ­¥æ•°ç§ç±»æ•°
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if n < 0:
        return 0
    if n == 0:
        return 1

    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n + 1):
        for step in steps:
            if i >= step:
                dp[i] += dp[i - step]

    return dp[n]

def climb_stairs_with_min_cost(cost: list) -> tuple:
    """å¸¦æœ€å°æˆæœ¬çš„çˆ¬æ¥¼æ¢¯é—®é¢˜

    çŠ¶æ€å®šä¹‰: dp[i] = çˆ¬åˆ°ç¬¬ié˜¶çš„æœ€å°æˆæœ¬
    çŠ¶æ€è½¬ç§»: dp[i] = min(dp[i-1], dp[i-2]) + cost[i]

    Args:
        cost: æ¯ä¸ªå°é˜¶çš„æˆæœ¬æ•°ç»„

    Returns:
        (æœ€å°æˆæœ¬, è·¯å¾„)
    """
    n = len(cost)
    if n == 0:
        return 0, []
    if n == 1:
        return cost[0], [0]

    dp = [0] * n
    path = [[] for _ in range(n)]

    dp[0] = cost[0]
    path[0] = [0]
    dp[1] = cost[1]
    path[1] = [1]

    for i in range(2, n):
        if dp[i-1] < dp[i-2]:
            dp[i] = dp[i-1] + cost[i]
            path[i] = path[i-1] + [i]
        else:
            dp[i] = dp[i-2] + cost[i]
            path[i] = path[i-2] + [i]

    # å¯ä»¥é€‰æ‹©ä»å€’æ•°ç¬¬ä¸€é˜¶æˆ–å€’æ•°ç¬¬äºŒé˜¶ç»“æŸ
    if dp[n-1] < dp[n-2]:
        return dp[n-1], path[n-1]
    else:
        return dp[n-2], path[n-2]

def climb_stairs_with_constraints(n: int, max_steps: int = 3) -> int:
    """å¸¦æ­¥æ•°é™åˆ¶çš„çˆ¬æ¥¼æ¢¯é—®é¢˜

    æ¯æ¬¡æœ€å¤šçˆ¬max_stepsä¸ªå°é˜¶

    æ—¶é—´å¤æ‚åº¦: O(n * max_steps)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if n <= 1:
        return 1

    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n + 1):
        for step in range(1, min(max_steps + 1, i + 1)):
            dp[i] += dp[i - step]

    return dp[n]`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## èƒŒåŒ…é—®é¢˜ç³»åˆ—

### 1. 0-1èƒŒåŒ…é—®é¢˜

<CodeBlock
  title="0-1èƒŒåŒ…é—®é¢˜å®Œæ•´å®ç°"
  code={`def zero_one_knapsack(weights: list, values: list, capacity: int) -> int:
    """0-1èƒŒåŒ…é—®é¢˜åŸºç¡€ç‰ˆ

    çŠ¶æ€å®šä¹‰: dp[i][j] = å‰iä¸ªç‰©å“ï¼Œå®¹é‡ä¸ºjæ—¶çš„æœ€å¤§ä»·å€¼
    çŠ¶æ€è½¬ç§»: dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1])

    æ—¶é—´å¤æ‚åº¦: O(n * capacity)
    ç©ºé—´å¤æ‚åº¦: O(n * capacity)

    Args:
        weights: ç‰©å“é‡é‡åˆ—è¡¨
        values: ç‰©å“ä»·å€¼åˆ—è¡¨
        capacity: èƒŒåŒ…å®¹é‡

    Returns:
        æœ€å¤§ä»·å€¼
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    # dp[i][j] = å‰iä¸ªç‰©å“ï¼Œå®¹é‡ä¸ºjæ—¶çš„æœ€å¤§ä»·å€¼
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if weights[i-1] <= j:
                # å¯ä»¥é€‰æ‹©ç¬¬iä¸ªç‰©å“
                dp[i][j] = max(dp[i-1][j],                             # ä¸é€‰
                             dp[i-1][j - weights[i-1]] + values[i-1])  # é€‰
            else:
                # ä¸èƒ½é€‰æ‹©ç¬¬iä¸ªç‰©å“
                dp[i][j] = dp[i-1][j]

    return dp[n][capacity]

def zero_one_knapsack_optimized(weights: list, values: list, capacity: int) -> int:
    """ç©ºé—´ä¼˜åŒ–çš„0-1èƒŒåŒ…é—®é¢˜

    ç©ºé—´å¤æ‚åº¦: O(capacity) - ä½¿ç”¨ä¸€ç»´æ•°ç»„

    æ³¨æ„: å¿…é¡»é€†åºéå†å®¹é‡ï¼Œé¿å…é‡å¤è®¡ç®—
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    dp = [0] * (capacity + 1)

    for i in range(n):
        # é€†åºéå†ï¼Œç¡®ä¿æ¯ä¸ªç‰©å“åªä½¿ç”¨ä¸€æ¬¡
        for j in range(capacity, weights[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])

    return dp[capacity]

def zero_one_knapsack_with_items(weights: list, values: list, capacity: int) -> tuple:
    """è¿”å›ç‰©å“é€‰æ‹©çš„0-1èƒŒåŒ…é—®é¢˜

    Returns:
        (æœ€å¤§ä»·å€¼, é€‰æ‹©çš„ç‰©å“ç´¢å¼•åˆ—è¡¨)
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0, []

    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    # å¡«å……DPè¡¨
    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if weights[i-1] <= j:
                dp[i][j] = max(dp[i-1][j],
                             dp[i-1][j - weights[i-1]] + values[i-1])
            else:
                dp[i][j] = dp[i-1][j]

    # é‡æ„é€‰æ‹©çš„ç‰©å“
    selected_items = []
    total_value = dp[n][capacity]
    remaining_capacity = capacity

    for i in range(n, 0, -1):
        if dp[i][remaining_capacity] != dp[i-1][remaining_capacity]:
            selected_items.append(i-1)
            remaining_capacity -= weights[i-1]

    selected_items.reverse()
    return total_value, selected_items

def zero_one_knapsack_branch_and_bound(weights: list, values: list, capacity: int) -> tuple:
    """åˆ†æ”¯é™ç•Œæ³•è§£å†³0-1èƒŒåŒ…é—®é¢˜

    é€‚ç”¨äºå¤§è§„æ¨¡é—®é¢˜ï¼Œå¯èƒ½æ¯”DPæ›´å¿«

    Returns:
        (æœ€å¤§ä»·å€¼, é€‰æ‹©çš„ç‰©å“ç´¢å¼•åˆ—è¡¨)
    """
    import heapq

    n = len(weights)
    if n == 0 or capacity == 0:
        return 0, []

    # è®¡ç®—ä»·å€¼å¯†åº¦å¹¶æ’åº
    items = list(zip(weights, values, range(n)))
    items.sort(key=lambda x: x[1]/x[0], reverse=True)

    def greedy_bound(current_weight, current_value, start_idx):
        """è®¡ç®—è´ªå¿ƒä¸Šç•Œ"""
        bound = current_value
        remaining_weight = capacity - current_weight

        for i in range(start_idx, n):
            weight, value, idx = items[i]
            if weight <= remaining_weight:
                bound += value
                remaining_weight -= weight
            else:
                bound += value * remaining_weight / weight
                break

        return bound

    # ä¼˜å…ˆé˜Ÿåˆ— (è´Ÿä»·å€¼ç”¨äºæœ€å¤§å †)
    heap = []
    heapq.heappush(heap, (-greedy_bound(0, 0, 0), 0, 0, 0, []))

    best_value = 0
    best_items = []

    while heap:
        _, level, current_weight, current_value, selected, _ = heapq.heappop(heap)

        if current_value > best_value:
            best_value = current_value
            best_items = selected.copy()

        if level == n:
            continue

        # å‰ªæï¼šå¦‚æœå½“å‰ä¸Šç•Œå°äºå·²çŸ¥æœ€ä¼˜è§£ï¼Œè·³è¿‡
        bound = greedy_bound(current_weight, current_value, level)
        if bound <= best_value:
            continue

        weight, value, idx = items[level]

        # ä¸é€‰æ‹©å½“å‰ç‰©å“
        heapq.heappush(heap, (-greedy_bound(current_weight, current_value, level + 1),
                           level + 1, current_weight, current_value, selected.copy()))

        # é€‰æ‹©å½“å‰ç‰©å“
        if current_weight + weight <= capacity:
            new_selected = selected + [idx]
            heapq.heappush(heap, (-greedy_bound(current_weight + weight, current_value + value, level + 1),
                               level + 1, current_weight + weight, current_value + value, new_selected))

    return best_value, best_items

def zero_one_knapsack_multiple_constraints(weights: list, values: list, costs: list,
                                        capacity: int, budget: int) -> tuple:
    """å¤šçº¦æŸ0-1èƒŒåŒ…é—®é¢˜

    åŒæ—¶è€ƒè™‘é‡é‡çº¦æŸå’Œæˆæœ¬çº¦æŸ

    çŠ¶æ€å®šä¹‰: dp[i][j][k] = å‰iä¸ªç‰©å“ï¼Œé‡é‡jï¼Œæˆæœ¬kæ—¶çš„æœ€å¤§ä»·å€¼

    æ—¶é—´å¤æ‚åº¦: O(n * capacity * budget)
    ç©ºé—´å¤æ‚åº¦: O(n * capacity * budget)
    """
    n = len(weights)
    if n == 0 or capacity == 0 or budget == 0:
        return 0, []

    # ä¸‰ç»´DPè¡¨
    dp = [[[0] * (budget + 1) for _ in range(capacity + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(capacity + 1):
            for k in range(budget + 1):
                if weights[i-1] <= j and costs[i-1] <= k:
                    dp[i][j][k] = max(dp[i-1][j][k],
                                    dp[i-1][j-weights[i-1]][k-costs[i-1]] + values[i-1])
                else:
                    dp[i][j][k] = dp[i-1][j][k]

    # é‡æ„è§£
    selected_items = []
    remaining_capacity = capacity
    remaining_budget = budget

    for i in range(n, 0, -1):
        if (weights[i-1] <= remaining_capacity and
            costs[i-1] <= remaining_budget and
            dp[i][remaining_capacity][remaining_budget] !=
            dp[i-1][remaining_capacity][remaining_budget]):

            selected_items.append(i-1)
            remaining_capacity -= weights[i-1]
            remaining_budget -= costs[i-1]

    selected_items.reverse()
    return dp[n][capacity][budget], selected_items`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. å®Œå…¨èƒŒåŒ…é—®é¢˜

<CodeBlock
  title="å®Œå…¨èƒŒåŒ…é—®é¢˜åŠå…¶å˜ä½“"
  code={`def unbounded_knapsack(weights: list, values: list, capacity: int) -> int:
    """å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼šç‰©å“å¯ä»¥é‡å¤é€‰æ‹©

    çŠ¶æ€è½¬ç§»: dp[j] = max(dp[j], dp[j-weights[i]] + values[i])

    æ—¶é—´å¤æ‚åº¦: O(n * capacity)
    ç©ºé—´å¤æ‚åº¦: O(capacity)

    æ³¨æ„: æ­£åºéå†å®¹é‡ï¼Œå…è®¸é‡å¤é€‰æ‹©
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    dp = [0] * (capacity + 1)

    for i in range(n):
        # æ­£åºéå†ï¼Œå…è®¸é‡å¤é€‰æ‹©
        for j in range(weights[i], capacity + 1):
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])

    return dp[capacity]

def unbounded_knapsack_optimized(weights: list, values: list, capacity: int) -> int:
    """ä¼˜åŒ–çš„å®Œå…¨èƒŒåŒ…é—®é¢˜

    é€šè¿‡åˆ†è§£ç‰©å“æ•°é‡ä¼˜åŒ–
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    dp = [0] * (capacity + 1)

    for i in range(n):
        # è®¡ç®—æ¯ä¸ªç‰©å“æœ€å¤šå¯ä»¥é€‰æ‹©å¤šå°‘æ¬¡
        max_count = capacity // weights[i]

        # äºŒè¿›åˆ¶åˆ†è§£
        k = 1
        while k <= max_count:
            current_weight = k * weights[i]
            current_value = k * values[i]

            # é€†åºå¤„ç†ï¼Œå½“ä½œ0-1èƒŒåŒ…
            for j in range(capacity, current_weight - 1, -1):
                dp[j] = max(dp[j], dp[j - current_weight] + current_value)

            max_count -= k
            k *= 2

        if max_count > 0:
            current_weight = max_count * weights[i]
            current_value = max_count * values[i]
            for j in range(capacity, current_weight - 1, -1):
                dp[j] = max(dp[j], dp[j - current_weight] + current_value)

    return dp[capacity]

def unbounded_knapsack_with_counts(weights: list, values: list, capacity: int) -> tuple:
    """è¿”å›ç‰©å“æ•°é‡çš„å®Œå…¨èƒŒåŒ…é—®é¢˜

    Returns:
        (æœ€å¤§ä»·å€¼, ç‰©å“é€‰æ‹©è®¡æ•°)
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0, []

    dp = [0] * (capacity + 1)
    count = [0] * (capacity + 1)
    item_used = [[] for _ in range(capacity + 1)]

    for j in range(1, capacity + 1):
        for i in range(n):
            if weights[i] <= j:
                if dp[j] < dp[j - weights[i]] + values[i]:
                    dp[j] = dp[j - weights[i]] + values[i]
                    item_used[j] = item_used[j - weights[i]] + [i]

    # ç»Ÿè®¡ç‰©å“ä½¿ç”¨æ¬¡æ•°
    from collections import Counter
    item_counts = Counter(item_used[capacity])

    return dp[capacity], dict(item_counts)

def unbounded_knapsack_min_coins(coins: list, amount: int) -> tuple:
    """ç¡¬å¸æ‰¾é›¶é—®é¢˜ï¼šæœ€å°‘ç¡¬å¸æ•°

    ç‰¹æ®Šçš„å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼šæ±‚æœ€å°å€¼è€Œéæœ€å¤§å€¼

    Returns:
        (æœ€å°‘ç¡¬å¸æ•°, ç¡¬å¸ç»„åˆ)
    """
    if amount == 0:
        return 0, []

    # dp[i] = ç»„æˆé‡‘é¢içš„æœ€å°‘ç¡¬å¸æ•°
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    # è®°å½•é€‰æ‹©çš„ç¡¬å¸
    coin_used = [[] for _ in range(amount + 1)]

    for coin in coins:
        for j in range(coin, amount + 1):
            if dp[j] > dp[j - coin] + 1:
                dp[j] = dp[j - coin] + 1
                coin_used[j] = coin_used[j - coin] + [coin]

    if dp[amount] == float('inf'):
        return -1, []

    return dp[amount], coin_used[amount]

def unbounded_knapsack_max_combinations(coins: list, amount: int) -> int:
    """ç¡¬å¸æ‰¾é›¶é—®é¢˜ï¼šç»„åˆæ€»æ•°

    Returns:
        ç»„åˆæ€»æ•°
    """
    if amount == 0:
        return 1

    # dp[i] = ç»„æˆé‡‘é¢içš„ç»„åˆæ•°
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for j in range(coin, amount + 1):
            dp[j] += dp[j - coin]

    return dp[amount]

def unbounded_knapsack_fractional(values: list, weights: list, capacity: int) -> tuple:
    """åˆ†æ•°èƒŒåŒ…é—®é¢˜ï¼ˆè´ªå¿ƒç®—æ³•ï¼‰

    ç‰©å“å¯ä»¥åˆ†å‰²ï¼Œä½¿ç”¨è´ªå¿ƒè€ŒéDP

    Returns:
        (æœ€å¤§ä»·å€¼, é€‰æ‹©æ–¹æ¡ˆ)
    """
    n = len(values)
    if n == 0 or capacity == 0:
        return 0, []

    # è®¡ç®—ä»·å€¼å¯†åº¦å¹¶æ’åº
    items = [(values[i] / weights[i], values[i], weights[i], i)
             for i in range(n)]
    items.sort(key=lambda x: x[0], reverse=True)

    total_value = 0
    remaining_capacity = capacity
    selected_items = []

    for density, value, weight, idx in items:
        if weight <= remaining_capacity:
            # å®Œæ•´é€‰æ‹©
            total_value += value
            remaining_capacity -= weight
            selected_items.append((idx, 1.0))
        else:
            # éƒ¨åˆ†é€‰æ‹©
            fraction = remaining_capacity / weight
            total_value += value * fraction
            selected_items.append((idx, fraction))
            break

    return total_value, selected_items`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 3. å¤šé‡èƒŒåŒ…é—®é¢˜

<CodeBlock
  title="å¤šé‡èƒŒåŒ…é—®é¢˜å®ç°"
  code={`def multiple_knapsack(weights: list, values: list, counts: list, capacity: int) -> int:
    """å¤šé‡èƒŒåŒ…é—®é¢˜ï¼šæ¯ä¸ªç‰©å“æœ‰æ•°é‡é™åˆ¶

    çŠ¶æ€å®šä¹‰: dp[j] = å®¹é‡ä¸ºjæ—¶çš„æœ€å¤§ä»·å€¼

    æ—¶é—´å¤æ‚åº¦: O(n * capacity * log(max_count))
    ç©ºé—´å¤æ‚åº¦: O(capacity)

    Args:
        weights: ç‰©å“é‡é‡åˆ—è¡¨
        values: ç‰©å“ä»·å€¼åˆ—è¡¨
        counts: ç‰©å“æ•°é‡åˆ—è¡¨
        capacity: èƒŒåŒ…å®¹é‡

    Returns:
        æœ€å¤§ä»·å€¼
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    dp = [0] * (capacity + 1)

    for i in range(n):
        # å°†å¤šé‡èƒŒåŒ…è½¬æ¢ä¸º0-1èƒŒåŒ…ï¼ˆäºŒè¿›åˆ¶ä¼˜åŒ–ï¼‰
        num = min(counts[i], capacity // weights[i])
        k = 1

        while k <= num:
            # åˆ†è§£ä¸º2çš„å¹‚æ¬¡
            current_weight = k * weights[i]
            current_value = k * values[i]

            # é€†åºå¤„ç†
            for j in range(capacity, current_weight - 1, -1):
                dp[j] = max(dp[j], dp[j - current_weight] + current_value)

            num -= k
            k *= 2

        # å¤„ç†å‰©ä½™éƒ¨åˆ†
        if num > 0:
            current_weight = num * weights[i]
            current_value = num * values[i]
            for j in range(capacity, current_weight - 1, -1):
                dp[j] = max(dp[j], dp[j - current_weight] + current_value)

    return dp[capacity]

def multiple_knapsack_with_items(weights: list, values: list, counts: list,
                                capacity: int) -> tuple:
    """è¿”å›ç‰©å“é€‰æ‹©çš„å¤šé‡èƒŒåŒ…é—®é¢˜

    Returns:
        (æœ€å¤§ä»·å€¼, ç‰©å“é€‰æ‹©åˆ—è¡¨)
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0, []

    # å±•å¼€ç‰©å“åˆ—è¡¨
    expanded_weights = []
    expanded_values = []
    item_mapping = []  # è®°å½•åŸå§‹ç‰©å“ç´¢å¼•

    for i in range(n):
        count = min(counts[i], capacity // weights[i])
        # äºŒè¿›åˆ¶å±•å¼€
        k = 1
        while k <= count:
            expanded_weights.append(k * weights[i])
            expanded_values.append(k * values[i])
            item_mapping.append((i, k))
            count -= k
            k *= 2
        if count > 0:
            expanded_weights.append(count * weights[i])
            expanded_values.append(count * values[i])
            item_mapping.append((i, count))

    # ä½¿ç”¨0-1èƒŒåŒ…æ±‚è§£
    m = len(expanded_weights)
    dp = [0] * (capacity + 1)
    selected_expanded = []

    for i in range(m):
        for j in range(capacity, expanded_weights[i] - 1, -1):
            if dp[j] < dp[j - expanded_weights[i]] + expanded_values[i]:
                dp[j] = dp[j - expanded_weights[i]] + expanded_values[i]

    # é‡æ„é€‰æ‹©çš„ç‰©å“
    remaining_capacity = capacity
    result_items = []

    for i in range(m - 1, -1, -1):
        if remaining_capacity >= expanded_weights[i]:
            if dp[remaining_capacity] == dp[remaining_capacity - expanded_weights[i]] + expanded_values[i]:
                result_items.append(item_mapping[i])
                remaining_capacity -= expanded_weights[i]

    # åˆå¹¶ç›¸åŒç‰©å“
    final_items = {}
    for original_idx, count in result_items:
        if original_idx in final_items:
            final_items[original_idx] += count
        else:
            final_items[original_idx] = count

    return dp[capacity], final_items

def multiple_knapsack_monotonic_queue(weights: list, values: list, counts: list,
                                    capacity: int) -> int:
    """å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–çš„å¤šé‡èƒŒåŒ…é—®é¢˜

    é€‚ç”¨äºç‰©å“ä»·å€¼è¾ƒå¤§çš„æƒ…å†µ

    æ—¶é—´å¤æ‚åº¦: O(n * capacity)
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    dp = [0] * (capacity + 1)

    for i in range(n):
        weight = weights[i]
        value = values[i]
        count = counts[i]

        # å¯¹æ¯ä¸ªä½™æ•°åˆ†åˆ«å¤„ç†
        for remainder in range(weight):
            # ä½¿ç”¨å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–
            from collections import deque
            q = deque()

            # æšä¸¾å€æ•°
            max_multiple = (capacity - remainder) // weight
            for k in range(max_multiple + 1):
                current_j = remainder + k * weight
                current_value = dp[current_j] - k * value

                # ç»´æŠ¤å•è°ƒé˜Ÿåˆ—
                while q and current_value >= q[-1][1]:
                    q.pop()
                q.append((k, current_value))

                # ç§»é™¤è¶…å‡ºæ•°é‡é™åˆ¶çš„å…ƒç´ 
                while q and q[0][0] < k - count:
                    q.popleft()

                # æ›´æ–°DPå€¼
                if q:
                    dp[current_j] = q[0][1] + k * value

    return dp[capacity]

def multiple_knapsack_hybrid(weights: list, values: list, counts: list,
                            capacity: int) -> int:
    """æ··åˆä¼˜åŒ–çš„å¤šé‡èƒŒåŒ…é—®é¢˜

    æ ¹æ®é—®é¢˜ç‰¹å¾é€‰æ‹©åˆé€‚çš„ä¼˜åŒ–ç­–ç•¥
    """
    n = len(weights)
    if n == 0 or capacity == 0:
        return 0

    # æ ¹æ®ç‰©å“æ•°é‡å’Œå®¹é‡é€‰æ‹©ç­–ç•¥
    total_items = sum(counts)

    if total_items * capacity > 10**7:  # å¤§è§„æ¨¡é—®é¢˜
        return multiple_knapsack_monotonic_queue(weights, values, counts, capacity)
    elif max(counts) > 100:  # æ•°é‡è¾ƒå¤šçš„ç‰©å“
        return multiple_knapsack(weights, values, counts, capacity)
    else:  # å°è§„æ¨¡é—®é¢˜
        return multiple_knapsack_with_items(weights, values, counts, capacity)[0]`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## å­—ç¬¦ä¸²åŠ¨æ€è§„åˆ’

### 1. æœ€é•¿å…¬å…±å­åºåˆ— (LCS)

<CodeBlock
  title="æœ€é•¿å…¬å…±å­åºåˆ—å®Œæ•´å®ç°"
  code={`def longest_common_subsequence(text1: str, text2: str) -> int:
    """æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦

    çŠ¶æ€å®šä¹‰: dp[i][j] = text1å‰iä¸ªå­—ç¬¦å’Œtext2å‰jä¸ªå­—ç¬¦çš„LCSé•¿åº¦
    çŠ¶æ€è½¬ç§»:
        if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1
        else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(text1), len(text2)

    # dp[i][j] = text1å‰iä¸ªå­—ç¬¦å’Œtext2å‰jä¸ªå­—ç¬¦çš„LCSé•¿åº¦
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

def longest_common_subsequence_with_sequence(text1: str, text2: str) -> tuple:
    """è¿”å›æœ€é•¿å…¬å…±å­åºåˆ—

    Returns:
        (LCSé•¿åº¦, LCSå­—ç¬¦ä¸²)
    """
    m, n = len(text1), len(text2)

    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # å¡«å……DPè¡¨
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    # é‡æ„LCS
    lcs = []
    i, j = m, n

    while i > 0 and j > 0:
        if text1[i-1] == text2[j-1]:
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    lcs.reverse()
    return dp[m][n], ''.join(lcs)

def longest_common_subsequence_optimized(text1: str, text2: str) -> int:
    """ç©ºé—´ä¼˜åŒ–çš„LCS

    ç©ºé—´å¤æ‚åº¦: O(min(m, n))
    """
    if len(text1) < len(text2):
        text1, text2 = text2, text1

    m, n = len(text1), len(text2)
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                curr[j] = prev[j-1] + 1
            else:
                curr[j] = max(prev[j], curr[j-1])
        prev, curr = curr, prev

    return prev[n]

def longest_common_subsequence_k_strings(strings: list) -> int:
    """kä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—

    æ—¶é—´å¤æ‚åº¦: O(k * n * m * p...) - æŒ‡æ•°çº§å¤æ‚åº¦
    ç©ºé—´å¤æ‚åº¦: O(n * m * p...)

    é€‚ç”¨äºå°‘é‡çŸ­å­—ç¬¦ä¸²
    """
    if not strings:
        return 0

    k = len(strings)
    lengths = [len(s) for s in strings]

    # åˆ›å»ºkç»´DPæ•°ç»„
    # dp[i1][i2]...[ik] = å„å­—ç¬¦ä¸²å‰i1,i2,...,ikä¸ªå­—ç¬¦çš„LCSé•¿åº¦
    dp_shape = [length + 1 for length in lengths]

    def get_dp_value(indices):
        """è·å–æŒ‡å®šç´¢å¼•çš„DPå€¼"""
        if any(idx == 0 for idx in indices):
            return 0

        # æ£€æŸ¥æ‰€æœ‰å­—ç¬¦æ˜¯å¦ç›¸åŒ
        chars = [strings[i][indices[i]-1] for i in range(k)]
        if len(set(chars)) == 1:
            # æ‰€æœ‰å­—ç¬¦ç›¸åŒ
            prev_indices = [idx - 1 for idx in indices]
            return get_dp_value(prev_indices) + 1
        else:
            # å­—ç¬¦ä¸åŒï¼Œå°è¯•å‡å°‘å„ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦
            max_value = 0
            for i in range(k):
                if indices[i] > 0:
                    temp_indices = indices.copy()
                    temp_indices[i] -= 1
                    max_value = max(max_value, get_dp_value(temp_indices))
            return max_value

    # ä½¿ç”¨è®°å¿†åŒ–é¿å…é‡å¤è®¡ç®—
    memo = {}

    def get_dp_value_memo(indices):
        key = tuple(indices)
        if key in memo:
            return memo[key]

        if any(idx == 0 for idx in indices):
            memo[key] = 0
            return 0

        chars = [strings[i][indices[i]-1] for i in range(k)]
        if len(set(chars)) == 1:
            prev_indices = [idx - 1 for idx in indices]
            result = get_dp_value_memo(prev_indices) + 1
        else:
            max_value = 0
            for i in range(k):
                if indices[i] > 0:
                    temp_indices = indices.copy()
                    temp_indices[i] -= 1
                    max_value = max(max_value, get_dp_value_memo(temp_indices))
            result = max_value

        memo[key] = result
        return result

    initial_indices = lengths.copy()
    return get_dp_value_memo(initial_indices)

def longest_common_subsequence_parallel(text1: str, text2: str) -> int:
    """å¹¶è¡ŒåŒ–çš„LCSç®—æ³•

    åˆ©ç”¨å¯¹è§’çº¿å¹¶è¡Œè®¡ç®—
    """
    m, n = len(text1), len(text2)

    if m == 0 or n == 0:
        return 0

    # ä½¿ç”¨å¯¹è§’çº¿è®¡ç®—
    total_diagonals = m + n - 1

    def compute_diagonal(diag):
        """è®¡ç®—å¯¹è§’çº¿"""
        results = {}

        # ç¡®å®šå¯¹è§’çº¿çš„èŒƒå›´
        if diag < m:
            start_i = diag
            start_j = 0
        else:
            start_i = m - 1
            start_j = diag - m + 1

        i, j = start_i, start_j

        while i >= 0 and j < n:
            if text1[i] == text2[j]:
                if i > 0 and j > 0:
                    prev_key = (i-1, j-1)
                    if prev_key in results:
                        results[(i, j)] = results[prev_key] + 1
                    else:
                        results[(i, j)] = 1
                else:
                    results[(i, j)] = 1
            else:
                up = results.get((i-1, j), 0) if i > 0 else 0
                left = results.get((i, j-1), 0) if j > 0 else 0
                results[(i, j)] = max(up, left)

            i -= 1
            j += 1

        return results

    # é¡ºåºè®¡ç®—å„å¯¹è§’çº¿ï¼ˆå®é™…å¹¶è¡Œç¯å¢ƒå¯ç”¨å¤šçº¿ç¨‹ï¼‰
    all_results = {}
    for diag in range(total_diagonals):
        diagonal_results = compute_diagonal(diag)
        all_results.update(diagonal_results)

    return all_results.get((m-1, n-1), 0)

def longest_common_subsequence_with_gaps(text1: str, text2: str, max_gap: int) -> int:
    """å…è®¸é—´éš™çš„æœ€é•¿å…¬å…±å­åºåˆ—

    å…è®¸è¿ç»­ä¸åŒ¹é…çš„å­—ç¬¦æ•°ä¸è¶…è¿‡max_gap

    çŠ¶æ€å®šä¹‰: dp[i][j][g] = text1å‰iä¸ªå­—ç¬¦ï¼Œtext2å‰jä¸ªå­—ç¬¦ï¼Œå½“å‰é—´éš™gçš„LCSé•¿åº¦
    """
    m, n = len(text1), len(text2)

    # dp[i][j][g] = å‰iä¸ªå­—ç¬¦ï¼Œå‰jä¸ªå­—ç¬¦ï¼Œå½“å‰é—´éš™ä¸ºgçš„LCSé•¿åº¦
    dp = [[[0] * (max_gap + 1) for _ in range(n + 1)] for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            for g in range(max_gap + 1):
                if text1[i-1] == text2[j-1]:
                    # å­—ç¬¦åŒ¹é…ï¼Œé‡ç½®é—´éš™
                    dp[i][j][0] = dp[i-1][j-1][g] + 1
                else:
                    # å­—ç¬¦ä¸åŒ¹é…ï¼Œå¢åŠ é—´éš™
                    if g < max_gap:
                        dp[i][j][g + 1] = dp[i-1][j-1][g]
                    # æˆ–è·³è¿‡å…¶ä¸­ä¸€ä¸ªå­—ç¬¦
                    dp[i][j][g] = max(dp[i-1][j][g], dp[i][j-1][g])

    return max(dp[m][n][g] for g in range(max_gap + 1))`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. æœ€é•¿é€’å¢å­åºåˆ— (LIS)

<CodeBlock
  title="æœ€é•¿é€’å¢å­åºåˆ—å¤šç§è§£æ³•"
  code={`def longest_increasing_subsequence(nums: list) -> int:
    """æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦ - O(nÂ²)è§£æ³•

    çŠ¶æ€å®šä¹‰: dp[i] = ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦
    çŠ¶æ€è½¬ç§»: dp[i] = max(dp[j] + 1) for j < i and nums[j] < nums[i]

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if not nums:
        return 0

    n = len(nums)
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

def longest_increasing_subsequence_optimized(nums: list) -> int:
    """ä¼˜åŒ–çš„LIS - O(n log n)è§£æ³•

    ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç»´æŠ¤æœ‰åºæ•°ç»„

    æ—¶é—´å¤æ‚åº¦: O(n log n)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if not nums:
        return 0

    tails = []  # tails[i] = é•¿åº¦ä¸ºi+1çš„é€’å¢å­åºåˆ—çš„æœ€å°æœ«å°¾

    for num in nums:
        # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°æ’å…¥ä½ç½®
        left, right = 0, len(tails)
        while left < right:
            mid = (left + right) // 2
            if tails[mid] < num:
                left = mid + 1
            else:
                right = mid

        if left == len(tails):
            tails.append(num)
        else:
            tails[left] = num

    return len(tails)

def longest_increasing_subsequence_with_sequence(nums: list) -> tuple:
    """è¿”å›æœ€é•¿é€’å¢å­åºåˆ—

    Returns:
        (LISé•¿åº¦, LISåºåˆ—)
    """
    if not nums:
        return 0, []

    n = len(nums)
    dp = [1] * n
    prev = [-1] * n  # è®°å½•å‰é©±

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j] and dp[i] < dp[j] + 1:
                dp[i] = dp[j] + 1
                prev[i] = j

    max_length = max(dp)
    max_index = dp.index(max_length)

    # é‡æ„LIS
    lis = []
    current = max_index
    while current != -1:
        lis.append(nums[current])
        current = prev[current]

    lis.reverse()
    return max_length, lis

def longest_increasing_subsequence_strict(nums: list) -> int:
    """ä¸¥æ ¼é€’å¢å­åºåˆ—ï¼ˆä¸å…è®¸ç›¸ç­‰ï¼‰"""
    if not nums:
        return 0

    tails = []
    for num in nums:
        left, right = 0, len(tails)
        while left < right:
            mid = (left + right) // 2
            if tails[mid] < num:
                left = mid + 1
            else:
                right = mid

        if left == len(tails):
            tails.append(num)
        else:
            tails[left] = num

    return len(tails)

def longest_increasing_subsequence_non_strict(nums: list) -> int:
    """éä¸¥æ ¼é€’å¢å­åºåˆ—ï¼ˆå…è®¸ç›¸ç­‰ï¼‰"""
    if not nums:
        return 0

    tails = []
    for num in nums:
        left, right = 0, len(tails)
        while left < right:
            mid = (left + right) // 2
            if tails[mid] <= num:
                left = mid + 1
            else:
                right = mid

        if left == len(tails):
            tails.append(num)
        else:
            tails[left] = num

    return len(tails)

def longest_increasing_subsequence_circular(nums: list) -> int:
    """å¾ªç¯æ•°ç»„çš„æœ€é•¿é€’å¢å­åºåˆ—

    æ•°ç»„å¯ä»¥å¾ªç¯ç§»åŠ¨ï¼Œæ±‚æœ€é•¿é€’å¢å­åºåˆ—

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    """
    if not nums:
        return 0

    n = len(nums)
    max_length = 0

    # å°è¯•æ¯ä¸ªèµ·å§‹ç‚¹
    for start in range(n):
        # æ„å»ºå¾ªç¯æ•°ç»„
        circular = nums[start:] + nums[:start]

        # è®¡ç®—è¿™ä¸ªèµ·å§‹ç‚¹çš„LIS
        dp = [1] * n
        for i in range(1, n):
            for j in range(i):
                if circular[i] > circular[j]:
                    dp[i] = max(dp[i], dp[j] + 1)

        max_length = max(max_length, max(dp))

    return max_length

def longest_increasing_subsequence_2d(matrix: list) -> int:
    """äºŒç»´æ•°ç»„çš„æœ€é•¿é€’å¢å­åºåˆ—

    åœ¨äºŒç»´ç½‘æ ¼ä¸­æ‰¾åˆ°æœ€é•¿çš„é€’å¢è·¯å¾„

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    if not matrix or not matrix[0]:
        return 0

    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def dfs(i, j):
        if dp[i][j] != 0:
            return dp[i][j]

        max_length = 1
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                max_length = max(max_length, dfs(ni, nj) + 1)

        dp[i][j] = max_length
        return max_length

    result = 0
    for i in range(m):
        for j in range(n):
            result = max(result, dfs(i, j))

    return result

def longest_increasing_subsequence_kth(nums: list, k: int) -> int:
    """ç¬¬ké•¿çš„é€’å¢å­åºåˆ—

    æ‰¾åˆ°ç¬¬ké•¿çš„é€’å¢å­åºåˆ—çš„é•¿åº¦

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    """
    if not nums or k <= 0:
        return 0

    n = len(nums)

    # è®¡ç®—ä»¥æ¯ä¸ªä½ç½®ç»“å°¾çš„LISé•¿åº¦
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    # ç»Ÿè®¡æ¯ä¸ªé•¿åº¦çš„å‡ºç°æ¬¡æ•°
    length_counts = {}
    for length in dp:
        length_counts[length] = length_counts.get(length, 0) + 1

    # æŒ‰é•¿åº¦æ’åº
    sorted_lengths = sorted(length_counts.keys(), reverse=True)

    # æ‰¾åˆ°ç¬¬ké•¿çš„é•¿åº¦
    cumulative_count = 0
    for length in sorted_lengths:
        cumulative_count += length_counts[length]
        if cumulative_count >= k:
            return length

    return 0  # kè¶…è¿‡æ€»æ•°`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 3. ç¼–è¾‘è·ç¦»

<CodeBlock
  title="ç¼–è¾‘è·ç¦»åŠå…¶å˜ä½“"
  code={`def min_edit_distance(word1: str, word2: str) -> int:
    """æœ€å°ç¼–è¾‘è·ç¦»ï¼ˆLevenshteinè·ç¦»ï¼‰

    çŠ¶æ€å®šä¹‰: dp[i][j] = word1å‰iä¸ªå­—ç¬¦è½¬æ¢ä¸ºword2å‰jä¸ªå­—ç¬¦çš„æœ€å°ç¼–è¾‘è·ç¦»
    çŠ¶æ€è½¬ç§»:
        if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1]
        else: dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(word1), len(word2)

    # dp[i][j] = word1å‰iä¸ªå­—ç¬¦è½¬æ¢ä¸ºword2å‰jä¸ªå­—ç¬¦çš„æœ€å°ç¼–è¾‘è·ç¦»
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # åˆå§‹åŒ–
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,    # åˆ é™¤
                    dp[i][j-1] + 1,    # æ’å…¥
                    dp[i-1][j-1] + 1   # æ›¿æ¢
                )

    return dp[m][n]

def min_edit_distance_with_operations(word1: str, word2: str) -> tuple:
    """è¿”å›ç¼–è¾‘æ“ä½œçš„ç¼–è¾‘è·ç¦»

    Returns:
        (ç¼–è¾‘è·ç¦», æ“ä½œåºåˆ—)
    """
    m, n = len(word1), len(word2)

    dp = [[0] * (n + 1) for _ in range(m + 1)]
    operations = [[None] * (n + 1) for _ in range(m + 1)]

    # åˆå§‹åŒ–
    for i in range(m + 1):
        dp[i][0] = i
        operations[i][0] = f"åˆ é™¤{i}æ¬¡" if i > 0 else ""
    for j in range(n + 1):
        dp[0][j] = j
        operations[0][j] = f"æ’å…¥{j}æ¬¡" if j > 0 else ""

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
                operations[i][j] = operations[i-1][j-1]
            else:
                delete_cost = dp[i-1][j] + 1
                insert_cost = dp[i][j-1] + 1
                replace_cost = dp[i-1][j-1] + 1

                if delete_cost <= insert_cost and delete_cost <= replace_cost:
                    dp[i][j] = delete_cost
                    operations[i][j] = operations[i-1][j] + f" åˆ é™¤'{word1[i-1]}'"
                elif insert_cost <= delete_cost and insert_cost <= replace_cost:
                    dp[i][j] = insert_cost
                    operations[i][j] = operations[i][j-1] + f" æ’å…¥'{word2[j-1]}'"
                else:
                    dp[i][j] = replace_cost
                    operations[i][j] = operations[i-1][j-1] + f" æ›¿æ¢'{word1[i-1]}'ä¸º'{word2[j-1]}'"

    return dp[m][n], operations[m][n].strip()

def min_edit_distance_optimized(word1: str, word2: str) -> int:
    """ç©ºé—´ä¼˜åŒ–çš„ç¼–è¾‘è·ç¦»

    ç©ºé—´å¤æ‚åº¦: O(min(m, n))
    """
    if len(word1) < len(word2):
        word1, word2 = word2, word1

    m, n = len(word1), len(word2)
    prev = list(range(n + 1))
    curr = [0] * (n + 1)

    for i in range(1, m + 1):
        curr[0] = i
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                curr[j] = prev[j-1]
            else:
                curr[j] = min(prev[j], curr[j-1], prev[j-1]) + 1
        prev, curr = curr, prev

    return prev[n]

def damerau_levenshtein_distance(word1: str, word2: str) -> int:
    """Damerau-Levenshteinè·ç¦»

    å…è®¸ç›¸é‚»å­—ç¬¦çš„äº¤æ¢æ“ä½œ

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(word1), len(word2)

    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # åˆå§‹åŒ–
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,    # åˆ é™¤
                    dp[i][j-1] + 1,    # æ’å…¥
                    dp[i-1][j-1] + 1   # æ›¿æ¢
                )

            # æ£€æŸ¥ç›¸é‚»å­—ç¬¦äº¤æ¢
            if i > 1 and j > 1 and word1[i-1] == word2[j-2] and word1[i-2] == word2[j-1]:
                dp[i][j] = min(dp[i][j], dp[i-2][j-2] + 1)  # äº¤æ¢

    return dp[m][n]

def longest_common_substring(word1: str, word2: str) -> int:
    """æœ€é•¿å…¬å…±å­ä¸²

    æ³¨æ„ï¼šä¸å­åºåˆ—ä¸åŒï¼Œå­ä¸²è¦æ±‚è¿ç»­

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(word1), len(word2)

    # dp[i][j] = ä»¥word1[i-1]å’Œword2[j-1]ç»“å°¾çš„æœ€é•¿å…¬å…±å­ä¸²é•¿åº¦
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_length = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                max_length = max(max_length, dp[i][j])
            else:
                dp[i][j] = 0

    return max_length

def fuzzy_string_matching(pattern: str, text: str, threshold: float = 0.8) -> list:
    """æ¨¡ç³Šå­—ç¬¦ä¸²åŒ¹é…

    åœ¨æ–‡æœ¬ä¸­æ‰¾åˆ°ä¸æ¨¡å¼ç›¸ä¼¼çš„å­ä¸²

    Args:
        pattern: æ¨¡å¼å­—ç¬¦ä¸²
        text: æ–‡æœ¬å­—ç¬¦ä¸²
        threshold: ç›¸ä¼¼åº¦é˜ˆå€¼ (0-1)

    Returns:
        åŒ¹é…ä½ç½®åˆ—è¡¨ [(start, end, similarity), ...]
    """
    m, n = len(pattern), len(text)
    matches = []

    if m == 0 or n == 0:
        return matches

    # æ»‘åŠ¨çª—å£è®¡ç®—ç›¸ä¼¼åº¦
    max_window_size = min(m * 2, n)

    for window_size in range(max(1, m // 2), max_window_size + 1):
        for start in range(n - window_size + 1):
            window = text[start:start + window_size]

            # è®¡ç®—ç¼–è¾‘è·ç¦»
            edit_dist = min_edit_distance(pattern, window)
            max_len = max(len(pattern), window_size)
            similarity = 1 - edit_dist / max_len

            if similarity >= threshold:
                matches.append((start, start + window_size - 1, similarity))

    # æŒ‰ç›¸ä¼¼åº¦æ’åº
    matches.sort(key=lambda x: x[2], reverse=True)

    # å»é‡ï¼ˆé‡å çš„åŒ¹é…ä¿ç•™ç›¸ä¼¼åº¦æœ€é«˜çš„ï¼‰
    unique_matches = []
    for match in matches:
        is_overlap = False
        for existing in unique_matches:
            if not (match[1] < existing[0] or match[0] > existing[1]):
                is_overlap = True
                break
        if not is_overlap:
            unique_matches.append(match)

    return unique_matches

def edit_distance_parallel(word1: str, word2: str) -> int:
    """å¹¶è¡ŒåŒ–çš„ç¼–è¾‘è·ç¦»ç®—æ³•

    åˆ©ç”¨å¯¹è§’çº¿å¹¶è¡Œè®¡ç®—
    """
    m, n = len(word1), len(word2)

    if m == 0:
        return n
    if n == 0:
        return m

    # ä½¿ç”¨å¯¹è§’çº¿è®¡ç®—
    total_diagonals = m + n - 1

    def compute_diagonal(diag):
        """è®¡ç®—å¯¹è§’çº¿"""
        results = {}

        if diag < m:
            start_i = diag
            start_j = 0
        else:
            start_i = m - 1
            start_j = diag - m + 1

        i, j = start_i, start_j

        while i >= 0 and j < n:
            if i == 0:
                results[(i, j)] = j
            elif j == 0:
                results[(i, j)] = i
            else:
                if word1[i] == word2[j]:
                    results[(i, j)] = results.get((i-1, j-1), 0)
                else:
                    results[(i, j)] = min(
                        results.get((i-1, j), float('inf')),
                        results.get((i, j-1), float('inf')),
                        results.get((i-1, j-1), float('inf'))
                    ) + 1

            i -= 1
            j += 1

        return results

    # é¡ºåºè®¡ç®—å„å¯¹è§’çº¿ï¼ˆå®é™…å¹¶è¡Œç¯å¢ƒå¯ç”¨å¤šçº¿ç¨‹ï¼‰
    all_results = {}
    for diag in range(total_diagonals):
        diagonal_results = compute_diagonal(diag)
        all_results.update(diagonal_results)

    return all_results.get((m-1, n-1), m + n)`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## åŒºé—´åŠ¨æ€è§„åˆ’

### 1. çŸ©é˜µé“¾ä¹˜æ³•

<CodeBlock
  title="çŸ©é˜µé“¾ä¹˜æ³•å®ç°"
  code={`def matrix_chain_order(dimensions: list) -> tuple:
    """çŸ©é˜µé“¾ä¹˜æ³•æœ€ä¼˜æ‹¬å·åŒ–

    è¾“å…¥: dimensions = [m0, m1, m2, ..., mn] è¡¨ç¤ºnä¸ªçŸ©é˜µçš„ç»´åº¦
    å…¶ä¸­çŸ©é˜µAiçš„ç»´åº¦ä¸º dimensions[i-1] Ã— dimensions[i]

    çŠ¶æ€å®šä¹‰: dp[i][j] = çŸ©é˜µiåˆ°çŸ©é˜µjçš„æœ€å°ä¹˜æ³•æ¬¡æ•°
    çŠ¶æ€è½¬ç§»: dp[i][j] = min{dp[i][k] + dp[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]}

    æ—¶é—´å¤æ‚åº¦: O(nÂ³)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)

    Returns:
        (æœ€å°ä¹˜æ³•æ¬¡æ•°, æœ€ä¼˜æ‹¬å·åŒ–å­—ç¬¦ä¸²)
    """
    n = len(dimensions) - 1  # çŸ©é˜µæ•°é‡

    # dp[i][j] = çŸ©é˜µiåˆ°çŸ©é˜µjçš„æœ€å°ä¹˜æ³•æ¬¡æ•°
    dp = [[0] * n for _ in range(n)]
    # split[i][j] = æœ€ä¼˜åˆ†å‰²ç‚¹
    split = [[0] * n for _ in range(n)]

    for length in range(2, n + 1):  # é“¾é•¿åº¦
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')

            for k in range(i, j):
                cost = (dp[i][k] + dp[k+1][j] +
                       dimensions[i] * dimensions[k+1] * dimensions[j+1])

                if cost < dp[i][j]:
                    dp[i][j] = cost
                    split[i][j] = k

    # é‡æ„æœ€ä¼˜æ‹¬å·åŒ–
    def construct_optimal_parenthesis(i, j):
        """é€’å½’æ„é€ æœ€ä¼˜æ‹¬å·åŒ–"""
        if i == j:
            return f"A{i+1}"
        else:
            k = split[i][j]
            left = construct_optimal_parenthesis(i, k)
            right = construct_optimal_parenthesis(k+1, j)
            return f"({left} Ã— {right})"

    optimal_order = construct_optimal_parenthesis(0, n-1)

    return dp[0][n-1], optimal_order

def matrix_chain_multiplication(matrices: list, dimensions: list) -> tuple:
    """å®é™…æ‰§è¡ŒçŸ©é˜µé“¾ä¹˜æ³•

    Args:
        matrices: çŸ©é˜µåˆ—è¡¨
        dimensions: ç»´åº¦åˆ—è¡¨

    Returns:
        (æœ€å°ä¹˜æ³•æ¬¡æ•°, æœ€ä¼˜æ‹¬å·åŒ–, ç»“æœçŸ©é˜µ)
    """
    min_multiplications, optimal_order = matrix_chain_order(dimensions)

    def parse_parenthesis(expression):
        """è§£ææ‹¬å·è¡¨è¾¾å¼"""
        if expression[0] != '(':
            # å•ä¸ªçŸ©é˜µ
            matrix_idx = int(expression[1:]) - 1
            return matrices[matrix_idx]
        else:
            # æ‰¾åˆ°ä¸»è¿ç®—ç¬¦
            balance = 0
            for i, char in enumerate(expression):
                if char == '(':
                    balance += 1
                elif char == ')':
                    balance -= 1
                elif char == 'Ã—' and balance == 1:
                    left_expr = expression[1:i]
                    right_expr = expression[i+2:-1]

                    left_matrix = parse_parenthesis(left_expr)
                    right_matrix = parse_parenthesis(right_expr)

                    # æ‰§è¡ŒçŸ©é˜µä¹˜æ³•
                    return multiply_matrices(left_matrix, right_matrix)

    def multiply_matrices(A, B):
        """çŸ©é˜µä¹˜æ³•"""
        if isinstance(A, list) and isinstance(B, list):
            m = len(A)
            p = len(A[0])
            n = len(B[0])
            result = [[0] * n for _ in range(m)]

            for i in range(m):
                for j in range(n):
                    for k in range(p):
                        result[i][j] += A[i][k] * B[k][j]

            return result
        else:
            # ç®€åŒ–å¤„ç†ï¼šè¿”å›çŸ©é˜µç»´åº¦
            return (A[0], B[1]) if isinstance(A, tuple) and isinstance(B, tuple) else A

    # è§£æå¹¶è®¡ç®—æœ€ä¼˜ä¹˜æ³•é¡ºåº
    result_matrix = parse_parenthesis(optimal_order)

    return min_multiplications, optimal_order, result_matrix

def matrix_chain_order_with_cache(dimensions: list) -> tuple:
    """å¸¦ç¼“å­˜çš„çŸ©é˜µé“¾ä¹˜æ³•

    ç¼“å­˜ä¸­é—´ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
    """
    n = len(dimensions) - 1

    # ä½¿ç”¨è®°å¿†åŒ–
    memo = {}
    split_memo = {}

    def solve(i, j):
        """è§£å†³å­é—®é¢˜ [i, j]"""
        if (i, j) in memo:
            return memo[(i, j)], split_memo[(i, j)]

        if i == j:
            memo[(i, j)] = 0
            split_memo[(i, j)] = i
            return 0, i

        min_cost = float('inf')
        best_split = i

        for k in range(i, j):
            cost = (solve(i, k)[0] + solve(k+1, j)[0] +
                   dimensions[i] * dimensions[k+1] * dimensions[j+1])

            if cost < min_cost:
                min_cost = cost
                best_split = k

        memo[(i, j)] = min_cost
        split_memo[(i, j)] = best_split
        return min_cost, best_split

    min_cost, _ = solve(0, n-1)

    # æ„é€ æœ€ä¼˜æ‹¬å·åŒ–
    def construct_parenthesis(i, j):
        if i == j:
            return f"A{i+1}"
        else:
            k = split_memo[(i, j)]
            left = construct_parenthesis(i, k)
            right = construct_parenthesis(k+1, j)
            return f"({left} Ã— {right})"

    optimal_order = construct_parenthesis(0, n-1)
    return min_cost, optimal_order

def matrix_chain_parallel(dimensions: list) -> tuple:
    """å¹¶è¡ŒåŒ–çš„çŸ©é˜µé“¾ä¹˜æ³•

    åˆ©ç”¨åŠ¨æ€è§„åˆ’çš„å¯å¹¶è¡Œæ€§è´¨
    """
    n = len(dimensions) - 1

    if n == 0:
        return 0, ""

    # dp[i][j] = çŸ©é˜µiåˆ°çŸ©é˜µjçš„æœ€å°ä¹˜æ³•æ¬¡æ•°
    dp = [[0] * n for _ in range(n)]
    split = [[0] * n for _ in range(n)]

    # æŒ‰é“¾é•¿åº¦å¹¶è¡Œè®¡ç®—
    for length in range(2, n + 1):
        # åŒä¸€é•¿åº¦çš„å­é—®é¢˜å¯ä»¥å¹¶è¡Œè®¡ç®—
        subproblems = []

        for i in range(n - length + 1):
            j = i + length - 1
            subproblems.append((i, j))

        # å¹¶è¡Œè®¡ç®—æ¯ä¸ªå­é—®é¢˜ï¼ˆå®é™…ç¯å¢ƒç”¨å¤šçº¿ç¨‹ï¼‰
        for i, j in subproblems:
            dp[i][j] = float('inf')

            for k in range(i, j):
                cost = (dp[i][k] + dp[k+1][j] +
                       dimensions[i] * dimensions[k+1] * dimensions[j+1])

                if cost < dp[i][j]:
                    dp[i][j] = cost
                    split[i][j] = k

    # æ„é€ æœ€ä¼˜æ‹¬å·åŒ–
    def construct_optimal_parenthesis(i, j):
        if i == j:
            return f"A{i+1}"
        else:
            k = split[i][j]
            left = construct_optimal_parenthesis(i, k)
            right = construct_optimal_parenthesis(k+1, j)
            return f"({left} Ã— {right})"

    optimal_order = construct_optimal_parenthesis(0, n-1)
    return dp[0][n-1], optimal_order

def matrix_chain_approximate(dimensions: list, approximation_factor: float = 1.1) -> tuple:
    """è¿‘ä¼¼çŸ©é˜µé“¾ä¹˜æ³•ç®—æ³•

    ä½¿ç”¨è´ªå¿ƒç­–ç•¥è·å¾—è¿‘ä¼¼è§£

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    n = len(dimensions) - 1

    if n == 0:
        return 0, ""

    # è´ªå¿ƒç­–ç•¥ï¼šæ¯æ¬¡é€‰æ‹©ä¹˜æ³•ä»£ä»·æœ€å°çš„åˆ†å‰²
    dp = [[0] * n for _ in range(n)]
    split = [[0] * n for _ in range(n)]

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            # æ‰¾åˆ°ä»£ä»·æœ€å°çš„åˆ†å‰²
            min_cost = float('inf')
            best_k = i

            for k in range(i, j):
                cost = (dimensions[i] * dimensions[k+1] * dimensions[j+1])
                if cost < min_cost:
                    min_cost = cost
                    best_k = k

            dp[i][j] = dp[i][best_k] + dp[best_k+1][j] + min_cost
            split[i][j] = best_k

    # æ„é€ æ‹¬å·åŒ–
    def construct_parenthesis(i, j):
        if i == j:
            return f"A{i+1}"
        else:
            k = split[i][j]
            left = construct_parenthesis(i, k)
            right = construct_parenthesis(k+1, j)
            return f"({left} Ã— {right})"

    optimal_order = construct_parenthesis(0, n-1)
    return dp[0][n-1], optimal_order

def matrix_chain_with_constraints(dimensions: list, max_intermediate_size: int) -> tuple:
    """å¸¦ä¸­é—´ç»“æœå¤§å°çº¦æŸçš„çŸ©é˜µé“¾ä¹˜æ³•

    é™åˆ¶ä¸­é—´çŸ©é˜µçš„è¡ŒÃ—åˆ—ä¸è¶…è¿‡max_intermediate_size

    Returns:
        (æœ€å°ä¹˜æ³•æ¬¡æ•°, æœ€ä¼˜æ‹¬å·åŒ–) æˆ– (None, None) å¦‚æœæ— è§£
    """
    n = len(dimensions) - 1

    # dp[i][j] = (æœ€å°ä¹˜æ³•æ¬¡æ•°, æœ€å¤§ä¸­é—´å°ºå¯¸)
    dp = [[(float('inf'), float('inf'))] * n for _ in range(n)]
    split = [[0] * n for _ in range(n)]

    # åˆå§‹åŒ–
    for i in range(n):
        dp[i][i] = (0, dimensions[i] * dimensions[i+1])

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            min_cost = float('inf')
            best_split = i
            max_intermediate = float('inf')

            for k in range(i, j):
                left_cost, left_size = dp[i][k]
                right_cost, right_size = dp[k+1][j]

                # è®¡ç®—å½“å‰åˆ†å‰²çš„ä»£ä»·å’Œä¸­é—´å°ºå¯¸
                current_cost = left_cost + right_cost + dimensions[i] * dimensions[k+1] * dimensions[j+1]
                current_intermediate = max(left_size, right_size, dimensions[i] * dimensions[j+1])

                if (current_intermediate <= max_intermediate_size and
                    current_cost < min_cost):
                    min_cost = current_cost
                    best_split = k
                    max_intermediate = current_intermediate

            if min_cost != float('inf'):
                dp[i][j] = (min_cost, max_intermediate)
                split[i][j] = best_split
            else:
                # æ— å¯è¡Œè§£
                return None, None

    # æ„é€ æ‹¬å·åŒ–
    def construct_parenthesis(i, j):
        if i == j:
            return f"A{i+1}"
        else:
            k = split[i][j]
            left = construct_parenthesis(i, k)
            right = construct_parenthesis(k+1, j)
            return f"({left} Ã— {right})"

    if dp[0][n-1][0] != float('inf'):
        optimal_order = construct_parenthesis(0, n-1)
        return dp[0][n-1][0], optimal_order
    else:
        return None, None`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. æœ€é•¿å›æ–‡å­ä¸²

<CodeBlock
  title="æœ€é•¿å›æ–‡å­ä¸²ç®—æ³•"
  code={`def longest_palindromic_substring(s: str) -> str:
    """æœ€é•¿å›æ–‡å­ä¸² - æ ‡å‡†DPè§£æ³•

    çŠ¶æ€å®šä¹‰: dp[i][j] = s[i:j+1]æ˜¯å¦ä¸ºå›æ–‡
    çŠ¶æ€è½¬ç§»:
        if s[i] == s[j] and (j-i <= 1 or dp[i+1][j-1]): dp[i][j] = True

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    if not s:
        return ""

    n = len(s)
    # dp[i][j] = s[i:j+1]æ˜¯å¦ä¸ºå›æ–‡
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_length = 1

    # æ‰€æœ‰é•¿åº¦ä¸º1çš„å­ä¸²éƒ½æ˜¯å›æ–‡
    for i in range(n):
        dp[i][i] = True

    # æ£€æŸ¥é•¿åº¦ä¸º2çš„å­ä¸²
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_length = 2

    # æ£€æŸ¥é•¿åº¦å¤§äº2çš„å­ä¸²
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                if length > max_length:
                    start = i
                    max_length = length

    return s[start:start + max_length]

def longest_palindromic_substring_optimized(s: str) -> str:
    """ç©ºé—´ä¼˜åŒ–çš„æœ€é•¿å›æ–‡å­ä¸²

    ä½¿ç”¨ä¸­å¿ƒæ‰©å±•æ³•

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not s:
        return ""

    def expand_around_center(left, right):
        """ä»ä¸­å¿ƒæ‰©å±•"""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1

    start = 0
    end = 0

    for i in range(len(s)):
        len1 = expand_around_center(i, i)      # å¥‡æ•°é•¿åº¦
        len2 = expand_around_center(i, i + 1)  # å¶æ•°é•¿åº¦
        max_len = max(len1, len2)

        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2

    return s[start:end + 1]

def longest_palindromic_substring_manacher(s: str) -> str:
    """Manacherç®—æ³• - æœ€ä¼˜è§£æ³•

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if not s:
        return ""

    # é¢„å¤„ç†å­—ç¬¦ä¸²ï¼Œæ’å…¥ç‰¹æ®Šå­—ç¬¦
    processed = '#' + '#'.join(s) + '#'
    n = len(processed)

    # P[i] = ä»¥iä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡åŠå¾„
    P = [0] * n

    center = 0  # å½“å‰ä¸­å¿ƒ
    right = 0   # å½“å‰å³è¾¹ç•Œ

    max_center = 0  # æœ€é•¿å›æ–‡çš„ä¸­å¿ƒ
    max_radius = 0   # æœ€é•¿å›æ–‡çš„åŠå¾„

    for i in range(n):
        # åˆ©ç”¨å¯¹ç§°æ€§
        mirror = 2 * center - i

        if i < right:
            P[i] = min(right - i, P[mirror])

        # ä¸­å¿ƒæ‰©å±•
        left_boundary = i - (P[i] + 1)
        right_boundary = i + (P[i] + 1)

        while (left_boundary >= 0 and right_boundary < n and
               processed[left_boundary] == processed[right_boundary]):
            P[i] += 1
            left_boundary -= 1
            right_boundary += 1

        # æ›´æ–°ä¸­å¿ƒå’Œå³è¾¹ç•Œ
        if i + P[i] > right:
            center = i
            right = i + P[i]

        # æ›´æ–°æœ€é•¿å›æ–‡
        if P[i] > max_radius:
            max_radius = P[i]
            max_center = i

    # é‡æ„åŸå§‹å­—ç¬¦ä¸²ä¸­çš„æœ€é•¿å›æ–‡
    start = (max_center - max_radius) // 2
    length = max_radius

    return s[start:start + length]

def longest_palindromic_subsequence(s: str) -> str:
    """æœ€é•¿å›æ–‡å­åºåˆ—

    æ³¨æ„ï¼šä¸å­ä¸²ä¸åŒï¼Œå­åºåˆ—ä¸è¦æ±‚è¿ç»­

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    if not s:
        return ""

    n = len(s)
    # dp[i][j] = s[i:j+1]çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦
    dp = [[0] * n for _ in range(n)]

    # é•¿åº¦ä¸º1çš„å­åºåˆ—
    for i in range(n):
        dp[i][i] = 1

    # å¡«å……DPè¡¨
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            if s[i] == s[j]:
                if length == 2:
                    dp[i][j] = 2
                else:
                    dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])

    # é‡æ„LPS
    def reconstruct_lps(i, j):
        """é‡æ„æœ€é•¿å›æ–‡å­åºåˆ—"""
        if i > j:
            return ""
        if i == j:
            return s[i]
        if s[i] == s[j]:
            return s[i] + reconstruct_lps(i+1, j-1) + s[j]
        elif dp[i+1][j] > dp[i][j-1]:
            return reconstruct_lps(i+1, j)
        else:
            return reconstruct_lps(i, j-1)

    return reconstruct_lps(0, n-1)

def count_palindromic_substrings(s: str) -> int:
    """ç»Ÿè®¡å›æ–‡å­ä¸²æ•°é‡

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    if not s:
        return 0

    n = len(s)
    dp = [[False] * n for _ in range(n)]
    count = 0

    # å•å­—ç¬¦å›æ–‡
    for i in range(n):
        dp[i][i] = True
        count += 1

    # åŒå­—ç¬¦å›æ–‡
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            count += 1

    # é•¿åº¦å¤§äº2çš„å›æ–‡
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                count += 1

    return count

def count_palindromic_substrings_optimized(s: str) -> int:
    """ä¼˜åŒ–çš„å›æ–‡å­ä¸²ç»Ÿè®¡

    ä½¿ç”¨ä¸­å¿ƒæ‰©å±•æ³•

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not s:
        return 0

    n = len(s)
    count = 0

    def expand_around_center(left, right):
        """ä»ä¸­å¿ƒæ‰©å±•ï¼Œç»Ÿè®¡å›æ–‡æ•°é‡"""
        local_count = 0
        while left >= 0 and right < n and s[left] == s[right]:
            local_count += 1
            left -= 1
            right += 1
        return local_count

    for i in range(n):
        # å¥‡æ•°é•¿åº¦å›æ–‡
        count += expand_around_center(i, i)
        # å¶æ•°é•¿åº¦å›æ–‡
        count += expand_around_center(i, i + 1)

    return count

def shortest_palindrome(s: str) -> str:
    """æœ€çŸ­å›æ–‡ï¼ˆé€šè¿‡å‰é¢æ·»åŠ å­—ç¬¦ï¼‰

    æ‰¾åˆ°æœ€é•¿çš„å›æ–‡å‰ç¼€ï¼Œç„¶åå°†å‰©ä½™éƒ¨åˆ†åè½¬æ·»åŠ åˆ°å‰é¢

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if not s:
        return ""

    # æ‰¾åˆ°æœ€é•¿çš„å›æ–‡å‰ç¼€
    def is_palindrome(sub):
        return sub == sub[::-1]

    for i in range(len(s), 0, -1):
        if is_palindrome(s[:i]):
            # å°†å‰©ä½™éƒ¨åˆ†åè½¬æ·»åŠ åˆ°å‰é¢
            return s[i:][::-1] + s

    return s[::-1] + s  # å¦‚æœæ²¡æœ‰å›æ–‡å‰ç¼€ï¼ˆé™¤äº†å•ä¸ªå­—ç¬¦ï¼‰

def palindrome_partitioning(s: str) -> list:
    """å›æ–‡åˆ†å‰²

    å°†å­—ç¬¦ä¸²åˆ†å‰²æˆè‹¥å¹²å›æ–‡å­ä¸²çš„æ‰€æœ‰å¯èƒ½æ–¹å¼

    æ—¶é—´å¤æ‚åº¦: O(n * 2^n)
    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    if not s:
        return [[]]

    n = len(s)
    # é¢„å¤„ç†å›æ–‡ä¿¡æ¯
    is_pal = [[False] * n for _ in range(n)]

    # å•å­—ç¬¦å›æ–‡
    for i in range(n):
        is_pal[i][i] = True

    # åŒå­—ç¬¦å›æ–‡
    for i in range(n - 1):
        is_pal[i][i + 1] = (s[i] == s[i + 1])

    # é•¿åº¦å¤§äº2çš„å›æ–‡
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            is_pal[i][j] = (s[i] == s[j] and is_pal[i + 1][j - 1])

    result = []

    def backtrack(start, path):
        """å›æº¯æœç´¢æ‰€æœ‰åˆ†å‰²æ–¹æ¡ˆ"""
        if start == n:
            result.append(path[:])
            return

        for end in range(start, n):
            if is_pal[start][end]:
                path.append(s[start:end + 1])
                backtrack(end + 1, path)
                path.pop()

    backtrack(0, [])
    return result

def min_palindrome_partitioning(s: str) -> int:
    """æœ€å°å›æ–‡åˆ†å‰²æ¬¡æ•°

    å°†å­—ç¬¦ä¸²åˆ†å‰²æˆå›æ–‡å­ä¸²çš„æœ€å°‘åˆ†å‰²æ¬¡æ•°

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    if not s:
        return 0

    n = len(s)
    # é¢„å¤„ç†å›æ–‡ä¿¡æ¯
    is_pal = [[False] * n for _ in range(n)]

    for i in range(n):
        is_pal[i][i] = True

    for i in range(n - 1):
        is_pal[i][i + 1] = (s[i] == s[i + 1])

    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            is_pal[i][j] = (s[i] == s[j] and is_pal[i + 1][j - 1])

    # dp[i] = s[0:i+1]çš„æœ€å°åˆ†å‰²æ¬¡æ•°
    dp = [float('inf')] * n

    for i in range(n):
        if is_pal[0][i]:
            dp[i] = 0
        else:
            for j in range(i):
                if is_pal[j + 1][i]:
                    dp[i] = min(dp[i], dp[j] + 1)

    return dp[n - 1]`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## è‚¡ç¥¨ä¹°å–é—®é¢˜

<CodeBlock
  title="è‚¡ç¥¨ä¹°å–é—®é¢˜ç³»åˆ—"
  code={`def max_profit_one_transaction(prices: list) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆåªå…è®¸ä¸€æ¬¡äº¤æ˜“ï¼‰

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices[1:]:
        max_profit = max(max_profit, price - min_price)
        min_price = min(min_price, price)

    return max_profit

def max_profit_unlimited_transactions(prices: list) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆå…è®¸æ— é™æ¬¡äº¤æ˜“ï¼‰

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not prices:
        return 0

    max_profit = 0

    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            max_profit += prices[i] - prices[i-1]

    return max_profit

def max_profit_k_transactions(prices: list, k: int) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆæœ€å¤škæ¬¡äº¤æ˜“ï¼‰

    æ—¶é—´å¤æ‚åº¦: O(n * k)
    ç©ºé—´å¤æ‚åº¦: O(n * k)
    """
    if not prices or k == 0:
        return 0

    n = len(prices)

    # å¦‚æœk >= n/2ï¼Œç›¸å½“äºæ— é™æ¬¡äº¤æ˜“
    if k >= n // 2:
        return max_profit_unlimited_transactions(prices)

    # dp[i][j] = æœ€å¤šiæ¬¡äº¤æ˜“ï¼Œåœ¨ç¬¬jå¤©çš„æœ€å¤§åˆ©æ¶¦
    dp = [[0] * n for _ in range(k + 1)]

    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i-1][j-1] - prices[j])

    return dp[k][n-1]

def max_profit_with_cooldown(prices: list) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆåŒ…å«å†·å´æœŸï¼‰

    å†·å´æœŸï¼šå–å‡ºåç¬¬äºŒå¤©ä¸èƒ½ä¹°å…¥

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not prices:
        return 0

    # hold[i] = ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š
    # sold[i] = ç¬¬iå¤©å–å‡ºè‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š
    # rest[i] = ç¬¬iå¤©ä¼‘æ¯çš„æœ€å¤§æ”¶ç›Š
    hold = sold = rest = -float('inf')

    for price in prices:
        prev_hold = hold
        prev_sold = sold
        prev_rest = rest

        # å½“å‰æŒæœ‰ï¼šç»§ç»­ä¿æŒæŒæœ‰ æˆ– ä¹‹å‰ä¼‘æ¯ä»Šå¤©ä¹°å…¥
        hold = max(prev_hold, prev_rest - price)
        # å½“å‰å–å‡ºï¼šä¹‹å‰æŒæœ‰ä»Šå¤©å–å‡º
        sold = prev_hold + price
        # å½“å‰ä¼‘æ¯ï¼šä¹‹å‰ä¼‘æ¯ æˆ– ä¹‹å‰å–å‡º
        rest = max(prev_rest, prev_sold)

    return max(sold, rest)

def max_profit_with_fee(prices: list, fee: int) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆåŒ…å«æ‰‹ç»­è´¹ï¼‰

    æ¯æ¬¡äº¤æ˜“éœ€è¦æ”¯ä»˜æ‰‹ç»­è´¹

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not prices:
        return 0

    # cash[i] = ç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š
    # hold[i] = ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š
    cash, hold = 0, -prices[0]

    for i in range(1, len(prices)):
        # ä¸æŒæœ‰ï¼šç»§ç»­ä¿æŒä¸æŒæœ‰ æˆ– å–å‡ºè‚¡ç¥¨
        cash = max(cash, hold + prices[i] - fee)
        # æŒæœ‰ï¼šç»§ç»­ä¿æŒæŒæœ‰ æˆ– ä¹°å…¥è‚¡ç¥¨
        hold = max(hold, cash - prices[i])

    return cash

def max_profit_with_cooldown_and_fee(prices: list, fee: int) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆåŒ…å«å†·å´æœŸå’Œæ‰‹ç»­è´¹ï¼‰

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not prices:
        return 0

    # hold[i] = ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š
    # sold[i] = ç¬¬iå¤©å–å‡ºè‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š
    # rest[i] = ç¬¬iå¤©ä¼‘æ¯çš„æœ€å¤§æ”¶ç›Š
    hold = sold = rest = -float('inf')

    for price in prices:
        prev_hold = hold
        prev_sold = sold
        prev_rest = rest

        # å½“å‰æŒæœ‰ï¼šç»§ç»­ä¿æŒæŒæœ‰ æˆ– ä¹‹å‰ä¼‘æ¯ä»Šå¤©ä¹°å…¥
        hold = max(prev_hold, prev_rest - price)
        # å½“å‰å–å‡ºï¼šä¹‹å‰æŒæœ‰ä»Šå¤©å–å‡º
        sold = prev_hold + price - fee
        # å½“å‰ä¼‘æ¯ï¼šä¹‹å‰ä¼‘æ¯ æˆ– ä¹‹å‰å–å‡º
        rest = max(prev_rest, prev_sold)

    return max(sold, rest)

def max_profit_ii_at_most_two_transactions(prices: list) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIIIï¼ˆæœ€å¤šä¸¤æ¬¡äº¤æ˜“ï¼‰

    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not prices:
        return 0

    # ç¬¬ä¸€æ¬¡äº¤æ˜“
    first_buy = -prices[0]
    first_sell = 0

    # ç¬¬äºŒæ¬¡äº¤æ˜“
    second_buy = -prices[0]
    second_sell = 0

    for i in range(1, len(prices)):
        # ç¬¬ä¸€æ¬¡äº¤æ˜“
        first_buy = max(first_buy, -prices[i])
        first_sell = max(first_sell, first_buy + prices[i])

        # ç¬¬äºŒæ¬¡äº¤æ˜“
        second_buy = max(second_buy, first_sell - prices[i])
        second_sell = max(second_sell, second_buy + prices[i])

    return second_sell

def max_profit_iii_at_most_k_transactions(prices: list, k: int) -> int:
    """ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIVï¼ˆæœ€å¤škæ¬¡äº¤æ˜“ï¼‰- ä¼˜åŒ–ç‰ˆ

    æ—¶é—´å¤æ‚åº¦: O(n * min(k, n/2))
    ç©ºé—´å¤æ‚åº¦: O(min(k, n/2))
    """
    if not prices or k == 0:
        return 0

    n = len(prices)

    # å¦‚æœk >= n/2ï¼Œç›¸å½“äºæ— é™æ¬¡äº¤æ˜“
    if k >= n // 2:
        return max_profit_unlimited_transactions(prices)

    # ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦
    dp = [[0] * n for _ in range(2)]

    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i % 2][j] = max(dp[i % 2][j-1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[(i-1) % 2][j-1] - prices[j])

    return dp[k % 2][n-1]

def best_time_to_buy_and_sell_stock_with_constraints(prices: list, constraints: dict) -> int:
    """å¸¦çº¦æŸçš„è‚¡ç¥¨ä¹°å–é—®é¢˜

    constraintså¯ä»¥åŒ…å«ï¼š
    - max_transactions: æœ€å¤§äº¤æ˜“æ¬¡æ•°
    - cooldown: å†·å´æœŸ
    - fee: æ‰‹ç»­è´¹

    æ—¶é—´å¤æ‚åº¦: æ ¹æ®çº¦æŸæ¡ä»¶å˜åŒ–
    ç©ºé—´å¤æ‚åº¦: æ ¹æ®çº¦æŸæ¡ä»¶å˜åŒ–
    """
    if not prices:
        return 0

    max_transactions = constraints.get('max_transactions', float('inf'))
    cooldown = constraints.get('cooldown', 0)
    fee = constraints.get('fee', 0)

    # ç®€åŒ–å¤„ç†ï¼šåªå¤„ç†æœ€å¸¸è§çš„çº¦æŸç»„åˆ
    if max_transactions == 1:
        return max_profit_one_transaction(prices)
    elif max_transactions == float('inf'):
        if cooldown > 0:
            return max_profit_with_cooldown(prices)
        elif fee > 0:
            return max_profit_with_fee(prices, fee)
        else:
            return max_profit_unlimited_transactions(prices)
    else:
        if cooldown > 0 and fee > 0:
            # æœ€å¤æ‚çš„æƒ…å†µï¼šåŒæ—¶æœ‰å†·å´æœŸå’Œæ‰‹ç»­è´¹
            return self._max_profit_complex_constraints(prices, max_transactions, cooldown, fee)
        elif cooldown > 0:
            # åªæœ‰å†·å´æœŸ
            return self._max_profit_with_cooldown_k(prices, max_transactions)
        elif fee > 0:
            # åªæœ‰æ‰‹ç»­è´¹
            return self._max_profit_with_fee_k(prices, max_transactions, fee)
        else:
            # åªæœ‰äº¤æ˜“æ¬¡æ•°é™åˆ¶
            return max_profit_k_transactions(prices, max_transactions)

def _max_profit_complex_constraints(prices: list, k: int, cooldown: int, fee: int) -> int:
    """å¤„ç†å¤æ‚çº¦æŸçš„è‚¡ç¥¨ä¹°å–é—®é¢˜"""
    if k == 0 or not prices:
        return 0

    n = len(prices)

    # dp[i][j][state] = ç¬¬iå¤©ï¼Œç¬¬jæ¬¡äº¤æ˜“ï¼ŒçŠ¶æ€ä¸ºstateæ—¶çš„æœ€å¤§æ”¶ç›Š
    # state: 0=æŒæœ‰è‚¡ç¥¨ï¼Œ1=ä¸æŒæœ‰è‚¡ç¥¨ï¼ˆå†·å´æœŸï¼‰ï¼Œ2=ä¸æŒæœ‰è‚¡ç¥¨ï¼ˆéå†·å´æœŸï¼‰
    dp = [[[0] * 3 for _ in range(k + 1)] for _ in range(n)]

    # åˆå§‹åŒ–
    for j in range(k + 1):
        dp[0][j][0] = -prices[0] - fee
        dp[0][j][1] = 0
        dp[0][j][2] = 0

    for i in range(1, n):
        for j in range(k + 1):
            # æŒæœ‰è‚¡ç¥¨ï¼šç»§ç»­ä¿æŒ æˆ– ä¹°å…¥
            if j > 0:
                dp[i][j][0] = max(dp[i-1][j][0],
                                 dp[i-1][j-1][2] - prices[i] - fee)
            else:
                dp[i][j][0] = dp[i-1][j][0]

            # ä¸æŒæœ‰ï¼ˆå†·å´æœŸï¼‰ï¼šå–å‡º
            dp[i][j][1] = dp[i-1][j][0] + prices[i]

            # ä¸æŒæœ‰ï¼ˆéå†·å´æœŸï¼‰ï¼šç»§ç»­ä¿æŒéå†·å´ æˆ– ä»å†·å´æœŸè½¬æ¢
            dp[i][j][2] = max(dp[i-1][j][2], dp[i-1][j][1])

    return max(dp[n-1][k][1], dp[n-1][k][2])

def _max_profit_with_cooldown_k(prices: list, k: int) -> int:
    """å¸¦å†·å´æœŸå’Œäº¤æ˜“æ¬¡æ•°é™åˆ¶çš„è‚¡ç¥¨ä¹°å–"""
    # å®ç°ç»†èŠ‚...
    pass

def _max_profit_with_fee_k(prices: list, k: int, fee: int) -> int:
    """å¸¦æ‰‹ç»­è´¹å’Œäº¤æ˜“æ¬¡æ•°é™åˆ¶çš„è‚¡ç¥¨ä¹°å–"""
    # å®ç°ç»†èŠ‚...
    pass`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## é«˜çº§åŠ¨æ€è§„åˆ’é—®é¢˜

### 1. æˆ³æ°”çƒé—®é¢˜

<CodeBlock
  title="æˆ³æ°”çƒé—®é¢˜å®ç°"
  code={`def max_coins(nums: list) -> int:
    """æˆ³æ°”çƒé—®é¢˜

    æˆ³ç ´æ°”çƒiè·å¾—nums[i-1] * nums[i] * nums[i+1]ä¸ªç¡¬å¸
    æ±‚æˆ³ç ´æ‰€æœ‰æ°”çƒèƒ½è·å¾—çš„æœ€å¤§ç¡¬å¸æ•°

    çŠ¶æ€å®šä¹‰: dp[i][j] = æˆ³ç ´(i,j)å¼€åŒºé—´å†…æ‰€æœ‰æ°”çƒçš„æœ€å¤§ç¡¬å¸æ•°
    çŠ¶æ€è½¬ç§»: dp[i][j] = max{dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]}

    æ—¶é—´å¤æ‚åº¦: O(nÂ³)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    n = len(nums)
    # æ·»åŠ è¾¹ç•Œ
    nums = [1] + nums + [1]
    new_n = n + 2

    # dp[i][j] = æˆ³ç ´(i,j)å¼€åŒºé—´å†…æ‰€æœ‰æ°”çƒçš„æœ€å¤§ç¡¬å¸æ•°
    dp = [[0] * new_n for _ in range(new_n)]

    for length in range(2, new_n):  # åŒºé—´é•¿åº¦
        for left in range(new_n - length):
            right = left + length

            for k in range(left + 1, right):
                # kæ˜¯åŒºé—´å†…æœ€åæˆ³ç ´çš„æ°”çƒ
                coins = (nums[left] * nums[k] * nums[right] +
                        dp[left][k] + dp[k][right])
                dp[left][right] = max(dp[left][right], coins)

    return dp[0][new_n - 1]

def max_coins_with_path(nums: list) -> tuple:
    """æˆ³æ°”çƒé—®é¢˜ï¼Œè¿”å›æˆ³ç ´é¡ºåº

    Returns:
        (æœ€å¤§ç¡¬å¸æ•°, æˆ³ç ´é¡ºåºåˆ—è¡¨)
    """
    n = len(nums)
    nums = [1] + nums + [1]
    new_n = n + 2

    dp = [[0] * new_n for _ in range(new_n)]
    # è®°å½•æ¯ä¸ªåŒºé—´çš„æœ€ä¼˜æˆ³ç ´é¡ºåº
    path = [[None] * new_n for _ in range(new_n)]

    for length in range(2, new_n):
        for left in range(new_n - length):
            right = left + length

            for k in range(left + 1, right):
                coins = (nums[left] * nums[k] * nums[right] +
                        dp[left][k] + dp[k][right])

                if coins > dp[left][right]:
                    dp[left][right] = coins
                    path[left][right] = k

    # é‡æ„æˆ³ç ´é¡ºåº
    def construct_order(left, right):
        """é€’å½’æ„é€ æˆ³ç ´é¡ºåº"""
        if left + 1 >= right:
            return []

        k = path[left][right]
        if k is None:
            return []

        left_order = construct_order(left, k)
        right_order = construct_order(k, right)

        return left_order + [k - 1] + right_order  # k-1è½¬æ¢ä¸ºåŸæ•°ç»„ç´¢å¼•

    burst_order = construct_order(0, new_n - 1)
    return dp[0][new_n - 1], burst_order

def max_coins_memoization(nums: list) -> int:
    """è®°å¿†åŒ–æœç´¢è§£å†³æˆ³æ°”çƒé—®é¢˜"""
    n = len(nums)
    nums = [1] + nums + [1]
    new_n = n + 2

    memo = {}

    def solve(left, right):
        """è§£å†³åŒºé—´[left, right]"""
        if (left, right) in memo:
            return memo[(left, right)]

        if left + 1 >= right:
            return 0

        max_coins = 0
        for k in range(left + 1, right):
            coins = (nums[left] * nums[k] * nums[right] +
                    solve(left, k) + solve(k, right))
            max_coins = max(max_coins, coins)

        memo[(left, right)] = max_coins
        return max_coins

    return solve(0, new_n - 1)

def max_coins_iterative_optimized(nums: list) -> int:
    """è¿­ä»£ä¼˜åŒ–çš„æˆ³æ°”çƒé—®é¢˜"""
    n = len(nums)
    if n == 0:
        return 0

    nums = [1] + nums + [1]
    new_n = n + 2

    # ä½¿ç”¨ä¸€ç»´æ•°ç»„ä¼˜åŒ–ç©ºé—´
    dp = [0] * new_n * new_n

    for length in range(2, new_n):
        for left in range(new_n - length):
            right = left + length

            max_coins = 0
            for k in range(left + 1, right):
                idx = left * new_n + right
                left_idx = left * new_n + k
                right_idx = k * new_n + right

                coins = (nums[left] * nums[k] * nums[right] +
                        dp[left_idx] + dp[right_idx])
                max_coins = max(max_coins, coins)

            dp[left * new_n + right] = max_coins

    return dp[new_n - 1]

def max_coins_parallel(nums: list) -> int:
    """å¹¶è¡ŒåŒ–çš„æˆ³æ°”çƒé—®é¢˜

    åˆ©ç”¨åŠ¨æ€è§„åˆ’çš„å¯å¹¶è¡Œæ€§è´¨
    """
    n = len(nums)
    if n == 0:
        return 0

    nums = [1] + nums + [1]
    new_n = n + 2

    dp = [[0] * new_n for _ in range(new_n)]

    # æŒ‰åŒºé—´é•¿åº¦å¹¶è¡Œè®¡ç®—
    for length in range(2, new_n):
        # åŒä¸€é•¿åº¦çš„åŒºé—´å¯ä»¥å¹¶è¡Œè®¡ç®—
        intervals = []

        for left in range(new_n - length):
            right = left + length
            intervals.append((left, right))

        # å¹¶è¡Œè®¡ç®—æ¯ä¸ªåŒºé—´ï¼ˆå®é™…ç¯å¢ƒç”¨å¤šçº¿ç¨‹ï¼‰
        for left, right in intervals:
            max_coins = 0

            for k in range(left + 1, right):
                coins = (nums[left] * nums[k] * nums[right] +
                        dp[left][k] + dp[k][right])
                max_coins = max(max_coins, coins)

            dp[left][right] = max_coins

    return dp[0][new_n - 1]

def min_operations_to_burst_balloons(nums: list) -> int:
    """æœ€å°æ“ä½œæ¬¡æ•°æˆ³æ°”çƒé—®é¢˜

    æ¯æ¬¡å¯ä»¥æˆ³ç ´ç›¸é‚»çš„ç›¸åŒæ°”çƒ

    æ—¶é—´å¤æ‚åº¦: O(nÂ²)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    if not nums:
        return 0

    n = len(nums)
    # dp[i][j] = æˆ³ç ´åŒºé—´[i,j]å†…æ°”çƒçš„æœ€å°æ“ä½œæ¬¡æ•°
    dp = [[float('inf')] * n for _ in range(n)]

    # å•ä¸ªæ°”çƒ
    for i in range(n):
        dp[i][i] = 1

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            # å°è¯•å°†åŒºé—´åˆ†æˆä¸¤éƒ¨åˆ†
            for k in range(i, j):
                left_ops = dp[i][k]
                right_ops = dp[k+1][j]

                # æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶æ“ä½œ
                if nums[k] == nums[k+1]:
                    # å¯ä»¥åˆå¹¶ï¼Œå‡å°‘æ“ä½œæ¬¡æ•°
                    total_ops = left_ops + right_ops - 1
                else:
                    total_ops = left_ops + right_ops

                dp[i][j] = min(dp[i][j], total_ops)

    return dp[0][n-1]`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

<CodeBlock
  title="æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å®ç°"
  code={`def is_match(s: str, p: str) -> bool:
    """æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ï¼ˆæ”¯æŒ '.' å’Œ '*'ï¼‰

    '.' åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦
    '*' åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰ä¸€ä¸ªå­—ç¬¦

    çŠ¶æ€å®šä¹‰: dp[i][j] = så‰iä¸ªå­—ç¬¦å’Œpå‰jä¸ªå­—ç¬¦æ˜¯å¦åŒ¹é…
    çŠ¶æ€è½¬ç§»:
        if p[j-1] == '.' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1]
        elif p[j-1] == '*':
            dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == '.' or p[j-2] == s[i-1]))

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(s), len(p)

    # dp[i][j] = så‰iä¸ªå­—ç¬¦å’Œpå‰jä¸ªå­—ç¬¦æ˜¯å¦åŒ¹é…
    dp = [[False] * (n + 1) for _ in range(m + 1)]

    # ç©ºå­—ç¬¦ä¸²åŒ¹é…ç©ºå­—ç¬¦ä¸²
    dp[0][0] = True

    # å¤„ç†æ¨¡å¼å¼€å¤´çš„'*'ï¼ˆå¯ä»¥åŒ¹é…0æ¬¡ï¼‰
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-2]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-2]  # åŒ¹é…0æ¬¡
                if p[j-2] == '.' or p[j-2] == s[i-1]:
                    dp[i][j] = dp[i][j] or dp[i-1][j]  # åŒ¹é…1æ¬¡æˆ–å¤šæ¬¡

    return dp[m][n]

def is_match_optimized(s: str, p: str) -> bool:
    """ç©ºé—´ä¼˜åŒ–çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

    ç©ºé—´å¤æ‚åº¦: O(n)
    """
    m, n = len(s), len(p)

    prev = [False] * (n + 1)
    curr = [False] * (n + 1)

    prev[0] = True

    for j in range(1, n + 1):
        if p[j-1] == '*':
            prev[j] = prev[j-2]

    for i in range(1, m + 1):
        curr[0] = False
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                curr[j] = prev[j-1]
            elif p[j-1] == '*':
                curr[j] = curr[j-2]
                if p[j-2] == '.' or p[j-2] == s[i-1]:
                    curr[j] = curr[j] or prev[j]
        prev, curr = curr, prev

    return prev[n]

def is_match_with_plus(s: str, p: str) -> bool:
    """æ”¯æŒ '+' çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

    '+' åŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªå‰ä¸€ä¸ªå­—ç¬¦

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(s), len(p)

    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    # é¢„å¤„ç†æ¨¡å¼ï¼Œå°† '+' è½¬æ¢ä¸ºç­‰æ•ˆå½¢å¼
    converted_pattern = []
    i = 0
    while i < len(p):
        if i + 1 < len(p) and p[i+1] == '+':
            # a+ -> aa*
            converted_pattern.append(p[i])
            converted_pattern.append(p[i])
            converted_pattern.append('*')
            i += 2
        else:
            converted_pattern.append(p[i])
            i += 1

    p = ''.join(converted_pattern)
    n = len(p)

    # å¤„ç†å¼€å¤´çš„'*'
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-2]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-2]
                if p[j-2] == '.' or p[j-2] == s[i-1]:
                    dp[i][j] = dp[i][j] or dp[i-1][j]

    return dp[m][n]

def is_match_with_question(s: str, p: str) -> bool:
    """æ”¯æŒ '?' çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

    '?' åŒ¹é…é›¶ä¸ªæˆ–ä¸€ä¸ªå‰ä¸€ä¸ªå­—ç¬¦

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(s), len(p)

    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    # å¤„ç†å¼€å¤´çš„'?'å’Œ'*'
    for j in range(1, n + 1):
        if p[j-1] == '*' or p[j-1] == '?':
            dp[0][j] = dp[0][j-2]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == '.' or p[j-2] == s[i-1]))
            elif p[j-1] == '?':
                dp[i][j] = dp[i][j-2] or (dp[i-1][j-2] and (p[j-2] == '.' or p[j-2] == s[i-1]))

    return dp[m][n]

def wildcard_matching(s: str, p: str) -> bool:
    """é€šé…ç¬¦åŒ¹é…

    '?' åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦
    '*' åŒ¹é…ä»»æ„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬ç©ºå­—ç¬¦ä¸²ï¼‰

    æ—¶é—´å¤æ‚åº¦: O(m * n)
    ç©ºé—´å¤æ‚åº¦: O(m * n)
    """
    m, n = len(s), len(p)

    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    # å¤„ç†å¼€å¤´çš„'*'
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-1]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '?' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-1] or dp[i-1][j]

    return dp[m][n]

def is_match_with_groups(s: str, p: str) -> tuple:
    """æ”¯æŒåˆ†ç»„çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

    æ”¯æŒ '(' å’Œ ')' åˆ†ç»„

    Returns:
        (æ˜¯å¦åŒ¹é…, åˆ†ç»„åŒ¹é…ç»“æœ)
    """
    # ç®€åŒ–ç‰ˆæœ¬ï¼šåªå¤„ç†ç®€å•çš„åˆ†ç»„
    # å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„è§£æ

    # é¦–å…ˆæ£€æŸ¥åŸºæœ¬åŒ¹é…
    if not is_match(s, p):
        return False, {}

    # ç®€åŒ–çš„åˆ†ç»„å¤„ç†
    groups = {}
    stack = []
    group_start = 0
    group_id = 1

    i = 0
    while i < len(p):
        if p[i] == '(':
            stack.append(i)
            group_start = i + 1
        elif p[i] == ')':
            if stack:
                start = stack.pop()
                # è¿™é‡Œåº”è¯¥è®°å½•åˆ†ç»„èŒƒå›´
                # ç®€åŒ–å¤„ç†ï¼šåªè®°å½•åˆ†ç»„çš„èµ·å§‹ä½ç½®
                groups[f'group{group_id}'] = (start, i)
                group_id += 1
        i += 1

    return True, groups

def regex_to_nfa(pattern: str) -> dict:
    """å°†æ­£åˆ™è¡¨è¾¾å¼è½¬æ¢ä¸ºNFA

    ç®€åŒ–çš„NFAæ„å»º

    Returns:
        NFAçš„è¡¨ç¤º
    """
    # è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°
    # å®é™…çš„æ­£åˆ™è¡¨è¾¾å¼åˆ°NFAè½¬æ¢éœ€è¦æ›´å¤æ‚çš„ç®—æ³•

    nfa = {
        'states': set(),
        'alphabet': set(),
        'transitions': {},
        'start': 0,
        'accept': set()
    }

    current_state = 0
    i = 0

    while i < len(pattern):
        if pattern[i] == '*':
            # å¤„ç†é‡å¤
            if i > 0:
                # æ·»åŠ Îµè½¬ç§»
                prev_char = pattern[i-1]
                nfa['alphabet'].add(prev_char)

                # ç®€åŒ–çš„å¤„ç†
                nfa['states'].add(current_state)
                nfa['states'].add(current_state + 1)
                nfa['states'].add(current_state + 2)

                nfa['transitions'][(current_state, 'Îµ')] = {current_state + 1, current_state + 2}
                nfa['transitions'][(current_state + 1, prev_char)] = {current_state + 1}
                nfa['transitions'][(current_state + 1, 'Îµ')] = {current_state + 2}

                current_state += 3
        elif pattern[i] == '.':
            # å¤„ç†é€šé…ç¬¦
            nfa['alphabet'].update('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')

            nfa['states'].add(current_state)
            nfa['states'].add(current_state + 1)

            # ä¸ºæ¯ä¸ªå­—ç¬¦æ·»åŠ è½¬ç§»
            for char in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789':
                nfa['transitions'][(current_state, char)] = {current_state + 1}

            current_state += 1
        else:
            # å¤„ç†æ™®é€šå­—ç¬¦
            nfa['alphabet'].add(pattern[i])

            nfa['states'].add(current_state)
            nfa['states'].add(current_state + 1)

            nfa['transitions'][(current_state, pattern[i])] = {current_state + 1}
            current_state += 1

        i += 1

    nfa['accept'].add(current_state - 1)

    return nfa

def nfa_simulate(nfa: dict, input_string: str) -> bool:
    """NFAæ¨¡æ‹Ÿå™¨

    ç®€åŒ–çš„NFAæ¨¡æ‹Ÿ
    """
    current_states = {nfa['start']}

    def epsilon_closure(states):
        """è®¡ç®—Îµé—­åŒ…"""
        closure = set(states)
        stack = list(states)

        while stack:
            state = stack.pop()
            if (state, 'Îµ') in nfa['transitions']:
                for next_state in nfa['transitions'][(state, 'Îµ')]:
                    if next_state not in closure:
                        closure.add(next_state)
                        stack.append(next_state)

        return closure

    current_states = epsilon_closure(current_states)

    for char in input_string:
        next_states = set()

        for state in current_states:
            if (state, char) in nfa['transitions']:
                next_states.update(nfa['transitions'][(state, char)])

        current_states = epsilon_closure(next_states)

        if not current_states:
            return False

    return bool(current_states & nfa['accept'])`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## åŠ¨æ€è§„åˆ’æ¨¡å¼æ€»ç»“

<ComplexityAnalyzer
  algorithms={[
    {
      name: "çº¿æ€§DP",
      timeComplexity: "O(n) æˆ– O(nÂ²)",
      spaceComplexity: "O(n) æˆ– O(nÂ²)",
      bestCase: "O(n)",
      worstCase: "O(nÂ²)",
      averageCase: "O(n) æˆ– O(nÂ²)",
      description: "æŒ‰çº¿æ€§é¡ºåºè§£å†³ï¼Œå¦‚æ–æ³¢é‚£å¥‘ã€LIS",
      examples: ["æ–æ³¢é‚£å¥‘æ•°åˆ—", "æœ€é•¿é€’å¢å­åºåˆ—", "æœ€å¤§å­æ•°ç»„å’Œ"]
    },
    {
      name: "èƒŒåŒ…DP",
      timeComplexity: "O(n * W)",
      spaceComplexity: "O(n * W) æˆ– O(W)",
      bestCase: "O(n)",
      worstCase: "O(n * W)",
      averageCase: "O(n * W)",
      description: "å®¹é‡çº¦æŸä¸‹çš„æœ€ä¼˜é€‰æ‹©",
      examples: ["0-1èƒŒåŒ…", "å®Œå…¨èƒŒåŒ…", "å¤šé‡èƒŒåŒ…"]
    },
    {
      name: "åŒºé—´DP",
      timeComplexity: "O(nÂ³)",
      spaceComplexity: "O(nÂ²)",
      bestCase: "O(nÂ²)",
      worstCase: "O(nÂ³)",
      averageCase: "O(nÂ³)",
      description: "æ¶‰åŠåŒºé—´æ“ä½œçš„DP",
      examples: ["çŸ©é˜µé“¾ä¹˜æ³•", "æœ€é•¿å›æ–‡å­ä¸²", "æˆ³æ°”çƒ"]
    },
    {
      name: "æ ‘å½¢DP",
      timeComplexity: "O(n)",
      spaceComplexity: "O(n)",
      bestCase: "O(n)",
      worstCase: "O(n)",
      averageCase: "O(n)",
      description: "æ ‘ç»“æ„ä¸Šçš„DP",
      examples: ["æ ‘çš„ç›´å¾„", "æœ€å¤§ç‹¬ç«‹é›†", "æ ‘çš„æœ€å°è¦†ç›–"]
    },
    {
      name: "çŠ¶æ€å‹ç¼©DP",
      timeComplexity: "O(n * 2^n)",
      spaceComplexity: "O(2^n)",
      bestCase: "O(2^n)",
      worstCase: "O(n * 2^n)",
      averageCase: "O(n * 2^n)",
      description: "çŠ¶æ€ç”¨äºŒè¿›åˆ¶è¡¨ç¤º",
      examples: ["æ—…è¡Œå•†é—®é¢˜", "é›†åˆè¦†ç›–", "å­é›†å’Œé—®é¢˜"]
    }
  ]}
/>

### åŠ¨æ€è§„åˆ’é—®é¢˜è¯†åˆ«æŒ‡å—

<AlgorithmVisualizer
  title="åŠ¨æ€è§„åˆ’é—®é¢˜è¯†åˆ«"
  algorithm="dp-identification"
  steps={[
    {
      title: "1. æ£€æŸ¥æœ€ä¼˜å­ç»“æ„",
      content: "é—®é¢˜çš„æœ€ä¼˜è§£æ˜¯å¦åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£",
      conditions: ["æ˜¯", "å¦"],
      results: {
        "æ˜¯": "ç»§ç»­æ£€æŸ¥",
        "å¦": "å¯èƒ½ä¸é€‚åˆDP"
      }
    },
    {
      title: "2. æ£€æŸ¥é‡å å­é—®é¢˜",
      content: "æ˜¯å¦å­˜åœ¨é‡å¤è®¡ç®—çš„å­é—®é¢˜",
      conditions: ["æ˜¯", "å¦"],
      results: {
        "æ˜¯": "é€‚åˆDP",
        "å¦": "è€ƒè™‘åˆ†æ²»æˆ–è´ªå¿ƒ"
      }
    },
    {
      title: "3. ç¡®å®šçŠ¶æ€ç»´åº¦",
      content: "è¯†åˆ«éœ€è¦çš„çŠ¶æ€å˜é‡æ•°é‡",
      conditions: ["1ç»´", "2ç»´", "3ç»´+"],
      results: {
        "1ç»´": "çº¿æ€§DP",
        "2ç»´": "çŸ©é˜µDPæˆ–åŒºé—´DP",
        "3ç»´+": "å¤šç»´DPæˆ–çŠ¶æ€å‹ç¼©"
      }
    },
    {
      title: "4. é€‰æ‹©ç®—æ³•ç­–ç•¥",
      content: "æ ¹æ®é—®é¢˜ç‰¹å¾é€‰æ‹©å…·ä½“DPæ–¹æ³•",
      results: {
        "çº¿æ€§åºåˆ—": "çº¿æ€§DP",
        "çº¦æŸä¼˜åŒ–": "èƒŒåŒ…DP",
        "åŒºé—´æ“ä½œ": "åŒºé—´DP",
        "æ ‘ç»“æ„": "æ ‘å½¢DP",
        "ç»„åˆä¼˜åŒ–": "çŠ¶æ€å‹ç¼©DP"
      }
    }
  ]}
/>

## äº¤äº’å¼æ¼”ç¤º

### æ–æ³¢é‚£å¥‘æ•°åˆ—å¯è§†åŒ–

<AlgorithmVisualizer
  title="æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—è¿‡ç¨‹"
  algorithm="fibonacci-demo"
  steps={[
    {
      title: "é€’å½’è®¡ç®—",
      content: "ç›´æ¥é€’å½’ï¼Œäº§ç”Ÿå¤§é‡é‡å¤è®¡ç®—",
      code: "fib(n) = fib(n-1) + fib(n-2)",
      complexity: "O(2^n)"
    },
    {
      title: "è®°å¿†åŒ–ä¼˜åŒ–",
      content: "å­˜å‚¨å·²è®¡ç®—ç»“æœï¼Œé¿å…é‡å¤",
      code: "memo[n] = fib(n-1) + fib(n-2)",
      complexity: "O(n)"
    },
    {
      title: "è¿­ä»£ä¼˜åŒ–",
      content: "è‡ªåº•å‘ä¸Šè®¡ç®—ï¼Œç©ºé—´O(1)",
      code: "a, b = b, a + b",
      complexity: "O(n)"
    },
    {
      title: "çŸ©é˜µå¿«é€Ÿå¹‚",
      content: "åˆ©ç”¨çŸ©é˜µä¹˜æ³•å¯¹æ•°æ—¶é—´",
      code: "[[1,1],[1,0]]^n",
      complexity: "O(log n)"
    }
  ]}
/>

### èƒŒåŒ…é—®é¢˜å¯è§†åŒ–

<ArrayVisualizer
  title="0-1èƒŒåŒ…é—®é¢˜çŠ¶æ€è½¬ç§»"
  description="å±•ç¤ºèƒŒåŒ…é—®é¢˜ä¸­çŠ¶æ€è½¬ç§»çš„è¿‡ç¨‹"
  data={[
    { capacity: 0, value: 0, items: [] },
    { capacity: 2, value: 3, items: ["A"] },
    { capacity: 3, value: 4, items: ["B"] },
    { capacity: 5, value: 7, items: ["A", "B"] }
  ]}
  highlightIndices={[1, 2, 3]}
/>

## å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®ç°æ—…è¡Œå•†é—®é¢˜

<ExerciseBlock
  title="æ—…è¡Œå•†é—®é¢˜DPå®ç°"
  description="å®ç°ä½¿ç”¨åŠ¨æ€è§„åˆ’è§£å†³æ—…è¡Œå•†é—®é¢˜çš„ç®—æ³•ã€‚"
  difficulty="å›°éš¾"
  type="coding"
  initialCode={`# TODO: å®ç°æ—…è¡Œå•†é—®é¢˜çš„DPè§£æ³•
def traveling_salesman_dp(distances: list) -> tuple:
    """
    åŠ¨æ€è§„åˆ’è§£å†³æ—…è¡Œå•†é—®é¢˜

    Args:
        distances: è·ç¦»çŸ©é˜µï¼Œdistances[i][j]è¡¨ç¤ºåŸå¸‚iåˆ°åŸå¸‚jçš„è·ç¦»

    Returns:
        (æœ€çŸ­è·¯å¾„é•¿åº¦, æœ€çŸ­è·¯å¾„)
    """
    n = len(distances)
    if n == 0:
        return 0, []
    if n == 1:
        return 0, [0]

    # dp[mask][current] = è®¿é—®è¿‡çš„åŸå¸‚é›†åˆmaskï¼Œå½“å‰åœ¨currentåŸå¸‚çš„æœ€çŸ­è·ç¦»
    # éœ€è¦ä½¿ç”¨çŠ¶æ€å‹ç¼©
    pass`}
  expectedOutput="è¿”å›æœ€çŸ­è·¯å¾„é•¿åº¦å’Œå¯¹åº”çš„è·¯å¾„"
  solution={`def traveling_salesman_dp(distances: list) -> tuple:
    n = len(distances)
    if n == 0:
        return 0, []
    if n == 1:
        return 0, [0]

    # dp[mask][current] = å½“å‰çŠ¶æ€çš„æœ€çŸ­è·ç¦»
    dp = [[float('inf')] * n for _ in range(1 << n)]
    # parent[mask][current] = ç”¨äºé‡æ„è·¯å¾„
    parent = [[-1] * n for _ in range(1 << n)]

    # ä»åŸå¸‚0å¼€å§‹
    dp[1][0] = 0

    # éå†æ‰€æœ‰çŠ¶æ€
    for mask in range(1 << n):
        for current in range(n):
            if dp[mask][current] == float('inf'):
                continue

            # å°è¯•è®¿é—®ä¸‹ä¸€ä¸ªåŸå¸‚
            for next_city in range(n):
                if not (mask & (1 << next_city)):
                    next_mask = mask | (1 << next_city)
                    new_distance = dp[mask][current] + distances[current][next_city]

                    if new_distance < dp[next_mask][next_city]:
                        dp[next_mask][next_city] = new_distance
                        parent[next_mask][next_city] = current

    # æ‰¾åˆ°å›åˆ°èµ·ç‚¹çš„æœ€çŸ­è·¯å¾„
    final_mask = (1 << n) - 1
    min_distance = float('inf')
    last_city = -1

    for city in range(1, n):
        total_distance = dp[final_mask][city] + distances[city][0]
        if total_distance < min_distance:
            min_distance = total_distance
            last_city = city

    if min_distance == float('inf'):
        return float('inf'), []

    # é‡æ„è·¯å¾„
    path = []
    current_mask = final_mask
    current_city = last_city

    while current_city != -1:
        path.append(current_city)
        prev_city = parent[current_mask][current_city]
        if prev_city == -1:
            break
        current_mask &= ~(1 << current_city)
        current_city = prev_city

    path.append(0)  # å›åˆ°èµ·ç‚¹
    path.reverse()

    return min_distance, path`}
/>

### ç»ƒä¹ 2ï¼šå®ç°ç¼–è¾‘è·ç¦»çš„å¯è§†åŒ–

<ExerciseBlock
  title="ç¼–è¾‘è·ç¦»å¯è§†åŒ–"
  description="å®ç°ä¸€ä¸ªå¯ä»¥å¯è§†åŒ–ç¼–è¾‘è·ç¦»è®¡ç®—è¿‡ç¨‹çš„å‡½æ•°ã€‚"
  difficulty="ä¸­ç­‰"
  type="coding"
  initialCode={`# TODO: å®ç°ç¼–è¾‘è·ç¦»çš„å¯è§†åŒ–
def visualize_edit_distance(word1: str, word2: str) -> dict:
    """
    å¯è§†åŒ–ç¼–è¾‘è·ç¦»çš„è®¡ç®—è¿‡ç¨‹

    Args:
        word1: ç¬¬ä¸€ä¸ªå•è¯
        word2: ç¬¬äºŒä¸ªå•è¯

    Returns:
        åŒ…å«DPè¡¨å’Œæ“ä½œåºåˆ—çš„å­—å…¸
    """
    # è®¡ç®—DPè¡¨
    # è®°å½•æ¯ä¸€æ­¥çš„æ“ä½œ
    # è¿”å›å¯è§†åŒ–æ•°æ®
    pass`}
  expectedOutput="è¿”å›åŒ…å«DPè¡¨å’Œè¯¦ç»†æ“ä½œè¿‡ç¨‹çš„æ•°æ®ç»“æ„"
  solution={`def visualize_edit_distance(word1: str, word2: str) -> dict:
    m, n = len(word1), len(word2)

    # DPè¡¨
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    # æ“ä½œè¡¨
    operations = [[None] * (n + 1) for _ in range(m + 1)]

    # åˆå§‹åŒ–
    for i in range(m + 1):
        dp[i][0] = i
        operations[i][0] = f"åˆ é™¤{i}æ¬¡"
    for j in range(n + 1):
        dp[0][j] = j
        operations[0][j] = f"æ’å…¥{j}æ¬¡"

    # å¡«å……DPè¡¨
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
                operations[i][j] = operations[i-1][j-1]
            else:
                delete_cost = dp[i-1][j] + 1
                insert_cost = dp[i][j-1] + 1
                replace_cost = dp[i-1][j-1] + 1

                if delete_cost <= insert_cost and delete_cost <= replace_cost:
                    dp[i][j] = delete_cost
                    operations[i][j] = f"{operations[i-1][j]} åˆ é™¤'{word1[i-1]}'"
                elif insert_cost <= delete_cost and insert_cost <= replace_cost:
                    dp[i][j] = insert_cost
                    operations[i][j] = f"{operations[i][j-1]} æ’å…¥'{word2[j-1]}'"
                else:
                    dp[i][j] = replace_cost
                    operations[i][j] = f"{operations[i-1][j-1]} æ›¿æ¢'{word1[i-1]}'ä¸º'{word2[j-1]}'"

    return {
        'dp_table': dp,
        'operations': operations,
        'final_distance': dp[m][n],
        'final_operation': operations[m][n],
        'word1': word1,
        'word2': word2
    }`}
/>

## æ€»ç»“ä¸è¦ç‚¹

### æ ¸å¿ƒæ¦‚å¿µå›é¡¾

1. **æœ€ä¼˜å­ç»“æ„**: é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£
2. **é‡å å­é—®é¢˜**: é€’å½’æ±‚è§£æ—¶é‡å¤è®¡ç®—ç›¸åŒå­é—®é¢˜
3. **çŠ¶æ€å®šä¹‰**: æè¿°é—®é¢˜å½“å‰çŠ¶å†µçš„å˜é‡ç»„åˆ
4. **çŠ¶æ€è½¬ç§»**: å»ºç«‹çŠ¶æ€é—´çš„é€’æ¨å…³ç³»
5. **è¾¹ç•Œæ¡ä»¶**: ç¡®ä¿é€’æ¨çš„åŸºç¡€æ­£ç¡®æ€§

### ç®—æ³•è®¾è®¡æŠ€å·§

1. **é—®é¢˜åˆ†æ**: è¯†åˆ«æœ€ä¼˜å­ç»“æ„å’Œé‡å å­é—®é¢˜
2. **çŠ¶æ€è®¾è®¡**: é€‰æ‹©åˆé€‚çš„çŠ¶æ€å˜é‡å’Œç»´åº¦
3. **è½¬ç§»æ–¹ç¨‹**: å»ºç«‹æ­£ç¡®çš„é€’æ¨å…³ç³»
4. **è¾¹ç•Œå¤„ç†**: è®¾ç½®æ­£ç¡®çš„åˆå§‹æ¡ä»¶
5. **ç©ºé—´ä¼˜åŒ–**: åº”ç”¨æ»šåŠ¨æ•°ç»„ç­‰æŠ€å·§

### å®é™…åº”ç”¨è¦ç‚¹

- **ç®—æ³•é€‰æ‹©**: æ ¹æ®é—®é¢˜ç‰¹å¾é€‰æ‹©åˆé€‚çš„DPæ¨¡å¼
- **å¤æ‚åº¦åˆ†æ**: å‡†ç¡®åˆ†ææ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- **ä¼˜åŒ–ç­–ç•¥**: åº”ç”¨å„ç§ä¼˜åŒ–æŠ€å·§æå‡æ€§èƒ½
- **ä»£ç å®ç°**: æ³¨æ„ä»£ç çš„æ¸…æ™°æ€§å’Œå¯ç»´æŠ¤æ€§

## è¿›ä¸€æ­¥å­¦ä¹ 

### ç›¸å…³ç®—æ³•

- **è®°å¿†åŒ–æœç´¢**: è‡ªé¡¶å‘ä¸‹çš„DPå®ç°æ–¹å¼
- **æ–œç‡ä¼˜åŒ–**: ç”¨äºä¼˜åŒ–ç‰¹å®šå½¢å¼çš„DPè½¬ç§»
- **å››è¾¹å½¢ä¸ç­‰å¼**: ä¼˜åŒ–åŒºé—´DPçš„è½¬ç§»é¡ºåº
- **å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–**: ä¼˜åŒ–æ»‘åŠ¨çª—å£ç±»å‹çš„DP

### æ¨èèµ„æº

1. **ç®—æ³•å¯¼è®º** - ç¬¬15ç« ï¼šåŠ¨æ€è§„åˆ’
2. **åŠ¨æ€è§„åˆ’ç»å…¸é—®é¢˜** - å„ç§DPé—®é¢˜è¯¦è§£
3. **LeetCode DPæ ‡ç­¾** - å¤§é‡DPç»ƒä¹ é¢˜
4. **CodeForces** - ç«èµ›ä¸­çš„DPåº”ç”¨

---

## è¯¾ç¨‹å¯¼èˆª

**ä¸Šä¸€è¯¾**: [L08 - æœ€å°ç”Ÿæˆæ ‘](/mit6006-algorithms/lectures/L08-minimum-spanning-tree)
**ä¸‹ä¸€è¯¾**: [L10 - å­—ç¬¦ä¸²ç®—æ³•](/mit6006-algorithms/lectures/L10-string-algorithms)
**è¯¾ç¨‹ä¸»é¡µ**: [MIT 6.006 ç®—æ³•å¯¼è®º](/mit6006-algorithms)