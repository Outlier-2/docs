---
title: "Lecture 6: Goæ¨¡å¼"
description: "Goè¯­è¨€åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ç¼–ç¨‹æ¨¡å¼å’Œæœ€ä½³å®è·µ"
---

# Lecture 6: Goæ¨¡å¼

## æœ¬å‘¨å†…å®¹

- **Goè®¾è®¡å“²å­¦**ï¼šç®€æ´æ€§ã€ç»„åˆæ€§ã€å¹¶å‘æ€§å’Œå·¥ç¨‹å®è·µ
- **å¹¶å‘æ¨¡å¼**ï¼šWorker Poolã€Pipelineã€Fan-in/Fan-outã€CSPæ¨¡å‹
- **é”™è¯¯å¤„ç†**ï¼šé‡è¯•æœºåˆ¶ã€æ–­è·¯å™¨æ¨¡å¼ã€è¶…æ—¶æ§åˆ¶
- **ç½‘ç»œç¼–ç¨‹**ï¼šè¿æ¥æ± ã€è´Ÿè½½å‡è¡¡ã€æœåŠ¡å‘ç°
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå†…å­˜ç®¡ç†ã€å¹¶å‘æ§åˆ¶ã€èµ„æºåˆ©ç”¨

## è¯¾ç¨‹è§†é¢‘

<iframe width="560" height="315" src="https://www.youtube.com/embed/YS4e4q9gBaE" title="Goå¹¶å‘ç¼–ç¨‹æ¨¡å¼" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## æ ¸å¿ƒæ¦‚å¿µ

### Goè®¾è®¡å“²å­¦

**ç®€æ´æ€§ (Simplicity)**
- å°‘å³æ˜¯å¤šï¼šè¯­è¨€ç‰¹æ€§æœ€å°åŒ–
- æ¸…æ™°çš„è¯­æ³•å’Œè¯­ä¹‰
- å‡å°‘è®¤çŸ¥è´Ÿæ‹…

**ç»„åˆæ€§ (Composition)**
- åµŒå…¥å¼ç»„åˆ
- æ¥å£ç»„åˆ
- å°å‹ã€ä¸“æ³¨çš„ç»„ä»¶

**å¹¶å‘æ€§ (Concurrency)**
- CSPï¼ˆé€šä¿¡é¡ºåºè¿›ç¨‹ï¼‰æ¨¡å‹
- Goroutineè½»é‡çº§çº¿ç¨‹
- Channelç±»å‹å®‰å…¨çš„é€šä¿¡

**å·¥ç¨‹å®è·µ**
- æ¸…æ™°çš„é”™è¯¯å¤„ç†
- æ ‡å‡†åŒ–çš„é¡¹ç›®ç»“æ„
- å¼ºå¤§çš„å·¥å…·é“¾

### Goåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¼˜åŠ¿

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Goè¯­è¨€ä¼˜åŠ¿                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”§ ç®€å•æ˜“å­¦    - è¯­æ³•ç®€æ´ï¼Œä¸Šæ‰‹å¿«é€Ÿ                   â”‚
â”‚  âš¡ é«˜æ€§èƒ½      - ç¼–è¯‘å‹è¯­è¨€ï¼Œæ¥è¿‘C++æ€§èƒ½              â”‚
â”‚  ğŸš€ å¹¶å‘åŸç”Ÿ    - Goroutineå’ŒChannelåŸç”Ÿæ”¯æŒ           â”‚
â”‚  ğŸ“¦ æ ‡å‡†åº“ä¸°å¯Œ  - net/httpã€syncã€contextç­‰            â”‚
â”‚  ğŸ”„ éƒ¨ç½²ç®€å•    - é™æ€é“¾æ¥ï¼Œå•æ–‡ä»¶éƒ¨ç½²                 â”‚
â”‚  ğŸ› ï¸ å·¥å…·é“¾å¼ºå¤§ - go testã€go fmtã€go modç­‰          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## å¹¶å‘ç¼–ç¨‹æ¨¡å¼

### 1. Worker Poolæ¨¡å¼

Worker Poolæ˜¯æœ€å¸¸ç”¨çš„å¹¶å‘æ¨¡å¼ä¹‹ä¸€ï¼Œç”¨äºåˆ†å‘ä»»åŠ¡åˆ°å¤šä¸ªå·¥ä½œåç¨‹ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// WorkerPool å·¥ä½œæ± ç»“æ„
type WorkerPool struct {
    tasks       chan Task
    results     chan Result
    workerCount int
    wg          sync.WaitGroup
}

// Task ä»»åŠ¡æ¥å£
type Task interface {
    Execute() Result
}

// Result ç»“æœæ¥å£
type Result interface{}

// NewWorkerPool åˆ›å»ºå·¥ä½œæ± 
func NewWorkerPool(workerCount int) *WorkerPool {
    return &WorkerPool{
        tasks:       make(chan Task, 100),
        results:     make(chan Result, 100),
        workerCount: workerCount,
    }
}

// Start å¯åŠ¨å·¥ä½œæ± 
func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

// Stop åœæ­¢å·¥ä½œæ± 
func (wp *WorkerPool) Stop() {
    close(wp.tasks)
    wp.wg.Wait()
    close(wp.results)
}

// worker å·¥ä½œåç¨‹
func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()

    for task := range wp.tasks {
        result := task.Execute()
        wp.results <- result
        fmt.Printf("Worker %d completed task\n", id)
    }
}

// Submit æäº¤ä»»åŠ¡
func (wp *WorkerPool) Submit(task Task) {
    wp.tasks <- task
}

// Results è·å–ç»“æœé€šé“
func (wp *WorkerPool) Results() <-chan Result {
    return wp.results
}

// å…·ä½“ä»»åŠ¡å®ç°
type MathTask struct {
    a, b int
    op   string
}

func (mt *MathTask) Execute() Result {
    time.Sleep(time.Millisecond * 100) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ

    switch mt.op {
    case "+":
        return mt.a + mt.b
    case "-":
        return mt.a - mt.b
    case "*":
        return mt.a * mt.b
    case "/":
        return mt.a / mt.b
    default:
        return fmt.Errorf("unknown operation: %s", mt.op)
    }
}

func main() {
    // åˆ›å»ºå·¥ä½œæ± 
    pool := NewWorkerPool(3)
    pool.Start()
    defer pool.Stop()

    // æäº¤ä»»åŠ¡
    tasks := []Task{
        &MathTask{10, 5, "+"},
        &MathTask{20, 3, "*"},
        &MathTask{15, 4, "-"},
        &MathTask{100, 2, "/"},
        &MathTask{7, 8, "*"},
    }

    for _, task := range tasks {
        pool.Submit(task)
    }

    // æ”¶é›†ç»“æœ
    for i := 0; i < len(tasks); i++ {
        result := <-pool.Results()
        fmt.Printf("Result: %v\n", result)
    }
}
```

### 2. Pipelineæ¨¡å¼

Pipelineæ¨¡å¼å°†å¤æ‚å¤„ç†è¿‡ç¨‹åˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µå¤„ç†å®Œæˆåä¼ é€’ç»™ä¸‹ä¸€é˜¶æ®µã€‚

```go
package main

import (
    "fmt"
    "strconv"
    "strings"
    "sync"
)

// Stage å®šä¹‰å¤„ç†é˜¶æ®µ
type Stage func(in <-chan interface{}) <-chan interface{}

// Pipeline ç®¡é“ç»“æ„
type Pipeline struct {
    stages []Stage
}

// NewPipeline åˆ›å»ºç®¡é“
func NewPipeline() *Pipeline {
    return &Pipeline{
        stages: make([]Stage, 0),
    }
}

// AddStage æ·»åŠ å¤„ç†é˜¶æ®µ
func (p *Pipeline) AddStage(stage Stage) {
    p.stages = append(p.stages, stage)
}

// Execute æ‰§è¡Œç®¡é“
func (p *Pipeline) Execute(input <-chan interface{}) <-chan interface{} {
    result := input

    for _, stage := range p.stages {
        result = stage(result)
    }

    return result
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºå¤„ç†é˜¶æ®µ
func createProcessor(processor func(interface{}) interface{}) Stage {
    return func(in <-chan interface{}) <-chan interface{} {
        out := make(chan interface{})

        go func() {
            defer close(out)

            for data := range in {
                result := processor(data)
                out <- result
            }
        }()

        return out
    }
}

// æ•°æ®å¤„ç†ç¤ºä¾‹
type Data struct {
    ID    int
    Value string
}

func main() {
    // åˆ›å»ºè¾“å…¥æ•°æ®
    input := make(chan interface{}, 10)

    go func() {
        defer close(input)

        // è¾“å…¥æ•°æ®
        data := []string{"hello", "world", "go", "pipeline", "example"}
        for i, item := range data {
            input <- Data{ID: i, Value: item}
        }
    }()

    // åˆ›å»ºç®¡é“
    pipeline := NewPipeline()

    // æ·»åŠ å¤„ç†é˜¶æ®µ
    pipeline.AddStage(createProcessor(func(data interface{}) interface{} {
        d := data.(Data)
        // é˜¶æ®µ1ï¼šè½¬æ¢ä¸ºå¤§å†™
        d.Value = strings.ToUpper(d.Value)
        return d
    }))

    pipeline.AddStage(createProcessor(func(data interface{}) interface{} {
        d := data.(Data)
        // é˜¶æ®µ2ï¼šæ·»åŠ å‰ç¼€
        d.Value = fmt.Sprintf("PROCESSED_%s", d.Value)
        return d
    }))

    pipeline.AddStage(createProcessor(func(data interface{}) interface{} {
        d := data.(Data)
        // é˜¶æ®µ3ï¼šè®¡ç®—é•¿åº¦
        return fmt.Sprintf("ID:%d, Value:%s, Length:%d",
            d.ID, d.Value, len(d.Value))
    }))

    // æ‰§è¡Œç®¡é“
    output := pipeline.Execute(input)

    // æ”¶é›†ç»“æœ
    for result := range output {
        fmt.Printf("Final Result: %s\n", result.(string))
    }
}
```

### 3. Fan-in/Fan-outæ¨¡å¼

Fan-outå°†ä»»åŠ¡åˆ†å‘åˆ°å¤šä¸ªåç¨‹ï¼ŒFan-inå°†å¤šä¸ªåç¨‹çš„ç»“æœåˆå¹¶ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// Fan-outï¼šåˆ†å‘ä»»åŠ¡åˆ°å¤šä¸ªworker
func fanOut(tasks []Task, workerCount int) []<-chan Result {
    workers := make([]<-chan Result, workerCount)

    for i := 0; i < workerCount; i++ {
        workers[i] = worker(i, tasks)
    }

    return workers
}

// Worker å¤„ç†ä»»åŠ¡çš„worker
func worker(id int, tasks []Task) <-chan Result {
    results := make(chan Result)

    go func() {
        defer close(results)

        for _, task := range tasks {
            if id == len(tasks)%workerCount {
                result := task.Execute()
                results <- result
            }
        }
    }()

    return results
}

// Fan-inï¼šåˆå¹¶å¤šä¸ªworkerçš„ç»“æœ
func fanIn(workers []<-chan Result) <-chan Result {
    merged := make(chan Result)

    var wg sync.WaitGroup
    wg.Add(len(workers))

    for _, worker := range workers {
        go func(w <-chan Result) {
            defer wg.Done()

            for result := range w {
                merged <- result
            }
        }(worker)
    }

    go func() {
        wg.Wait()
        close(merged)
    }()

    return merged
}

// å¹¶è¡Œè®¡ç®—ç¤ºä¾‹
func main() {
    // åˆ›å»ºä»»åŠ¡
    tasks := []Task{}
    for i := 0; i < 20; i++ {
        tasks = append(tasks, &MathTask{i, i+1, "+"})
    }

    // Fan-outï¼šåˆ†å‘åˆ°5ä¸ªworker
    workers := fanOut(tasks, 5)

    // Fan-inï¼šåˆå¹¶ç»“æœ
    results := fanIn(workers)

    // æ”¶é›†ç»“æœ
    for result := range results {
        fmt.Printf("Result: %v\n", result)
    }
}
```

## é”™è¯¯å¤„ç†æ¨¡å¼

### 1. é‡è¯•æœºåˆ¶

```go
package retry

import (
    "context"
    "fmt"
    "math"
    "math/rand"
    "time"
)

// RetryConfig é‡è¯•é…ç½®
type RetryConfig struct {
    MaxAttempts int
    BaseDelay   time.Duration
    MaxDelay    time.Duration
    Jitter      bool
}

// RetryOperation é‡è¯•æ“ä½œ
func RetryOperation(ctx context.Context, config RetryConfig, operation func() error) error {
    var lastErr error

    for attempt := 0; attempt < config.MaxAttempts; attempt++ {
        if attempt > 0 {
            // è®¡ç®—é€€é¿æ—¶é—´
            delay := calculateBackoff(config, attempt)

            select {
            case <-time.After(delay):
                // ç»§ç»­é‡è¯•
            case <-ctx.Done():
                return ctx.Err()
            }
        }

        // æ‰§è¡Œæ“ä½œ
        err := operation()
        if err == nil {
            return nil
        }

        lastErr = err

        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
        if !shouldRetry(err) {
            return err
        }
    }

    return fmt.Errorf("operation failed after %d attempts, last error: %v",
        config.MaxAttempts, lastErr)
}

// æŒ‡æ•°é€€é¿è®¡ç®—
func calculateBackoff(config RetryConfig, attempt int) time.Duration {
    delay := time.Duration(math.Pow(2, float64(attempt))) * config.BaseDelay

    if delay > config.MaxDelay {
        delay = config.MaxDelay
    }

    if config.Jitter {
        // æ·»åŠ éšæœºæŠ–åŠ¨
        jitter := time.Duration(rand.Int63n(int64(delay)))
        delay = delay/2 + jitter
    }

    return delay
}

// åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
func shouldRetry(err error) bool {
    // æ ¹æ®é”™è¯¯ç±»å‹åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
    switch err {
    case context.DeadlineExceeded, context.Canceled:
        return false
    default:
        return true
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    config := RetryConfig{
        MaxAttempts: 5,
        BaseDelay:   time.Second,
        MaxDelay:    time.Second * 10,
        Jitter:      true,
    }

    ctx := context.Background()

    err := RetryOperation(ctx, config, func() error {
        // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
        if rand.Intn(3) != 0 {
            return fmt.Errorf("temporary failure")
        }
        return nil
    })

    if err != nil {
        fmt.Printf("Operation failed: %v\n", err)
    } else {
        fmt.Println("Operation succeeded")
    }
}
```

### 2. æ–­è·¯å™¨æ¨¡å¼

```go
package circuitbreaker

import (
    "sync"
    "time"
)

// State æ–­è·¯å™¨çŠ¶æ€
type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

// CircuitBreaker æ–­è·¯å™¨ç»“æ„
type CircuitBreaker struct {
    mu             sync.Mutex
    state          State
    failureCount   int
    successCount   int
    threshold      int
    timeout        time.Duration
    lastFailure    time.Time
    resetTimeout   time.Duration
}

// NewCircuitBreaker åˆ›å»ºæ–­è·¯å™¨
func NewCircuitBreaker(threshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:        StateClosed,
        threshold:    threshold,
        timeout:      timeout,
        resetTimeout: time.Minute,
    }
}

// Execute æ‰§è¡Œæ“ä½œ
func (cb *CircuitBreaker) Execute(operation func() error) error {
    cb.mu.Lock()

    // æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
    if cb.state == StateOpen {
        if time.Since(cb.lastFailure) > cb.resetTimeout {
            cb.state = StateHalfOpen
            cb.successCount = 0
        } else {
            cb.mu.Unlock()
            return fmt.Errorf("circuit breaker is open")
        }
    }

    cb.mu.Unlock()

    // æ‰§è¡Œæ“ä½œ
    err := operation()

    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err != nil {
        // æ“ä½œå¤±è´¥
        cb.failureCount++
        cb.lastFailure = time.Now()

        if cb.failureCount >= cb.threshold {
            cb.state = StateOpen
        }

        return err
    } else {
        // æ“ä½œæˆåŠŸ
        cb.failureCount = 0

        if cb.state == StateHalfOpen {
            cb.successCount++
            if cb.successCount >= 3 {
                cb.state = StateClosed
            }
        }

        return nil
    }
}

// State è·å–å½“å‰çŠ¶æ€
func (cb *CircuitBreaker) State() State {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    return cb.state
}

// Reset é‡ç½®æ–­è·¯å™¨
func (cb *CircuitBreaker) Reset() {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    cb.state = StateClosed
    cb.failureCount = 0
    cb.successCount = 0
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    cb := NewCircuitBreaker(3, time.Second*5)

    for i := 0; i < 10; i++ {
        err := cb.Execute(func() error {
            // æ¨¡æ‹Ÿæ“ä½œ
            if i < 5 {
                return fmt.Errorf("operation failed")
            }
            return nil
        })

        fmt.Printf("Attempt %d: State=%v, Error=%v\n",
            i, cb.State(), err)

        time.Sleep(time.Second)
    }
}
```

## ç½‘ç»œç¼–ç¨‹æ¨¡å¼

### 1. è¿æ¥æ± 

```go
package pool

import (
    "net"
    "sync"
    "time"
)

// ConnectionPool è¿æ¥æ± ç»“æ„
type ConnectionPool struct {
    mu         sync.Mutex
    connections chan net.Conn
    factory    func() (net.Conn, error)
    maxConns   int
    current    int
}

// NewConnectionPool åˆ›å»ºè¿æ¥æ± 
func NewConnectionPool(factory func() (net.Conn, error), maxConns int) *ConnectionPool {
    return &ConnectionPool{
        connections: make(chan net.Conn, maxConns),
        factory:    factory,
        maxConns:   maxConns,
    }
}

// Get è·å–è¿æ¥
func (p *ConnectionPool) Get() (net.Conn, error) {
    p.mu.Lock()
    defer p.mu.Unlock()

    select {
    case conn := <-p.connections:
        // ä»æ± ä¸­è·å–è¿æ¥
        return conn, nil
    default:
        // åˆ›å»ºæ–°è¿æ¥
        if p.current < p.maxConns {
            p.current++
            conn, err := p.factory()
            if err != nil {
                p.current--
                return nil, err
            }
            return conn, nil
        }

        // ç­‰å¾…è¿æ¥é‡Šæ”¾
        p.mu.Unlock()
        conn := <-p.connections
        p.mu.Lock()
        return conn, nil
    }
}

// Put é‡Šæ”¾è¿æ¥
func (p *ConnectionPool) Put(conn net.Conn) {
    p.mu.Lock()
    defer p.mu.Unlock()

    select {
    case p.connections <- conn:
        // è¿æ¥æˆåŠŸæ”¾å›æ± ä¸­
    default:
        // æ± å·²æ»¡ï¼Œå…³é—­è¿æ¥
        conn.Close()
        p.current--
    }
}

// Close å…³é—­è¿æ¥æ± 
func (p *ConnectionPool) Close() error {
    p.mu.Lock()
    defer p.mu.Unlock()

    close(p.connections)

    for conn := range p.connections {
        conn.Close()
    }

    p.current = 0
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åˆ›å»ºè¿æ¥æ± 
    pool := NewConnectionPool(func() (net.Conn, error) {
        return net.Dial("tcp", "localhost:8080")
    }, 10)
    defer pool.Close()

    // ä½¿ç”¨è¿æ¥
    for i := 0; i < 20; i++ {
        conn, err := pool.Get()
        if err != nil {
            fmt.Printf("Error getting connection: %v\n", err)
            continue
        }

        // ä½¿ç”¨è¿æ¥
        _, err = conn.Write([]byte("Hello, Server!"))
        if err != nil {
            fmt.Printf("Error writing to connection: %v\n", err)
        } else {
            fmt.Printf("Successfully wrote to connection %d\n", i)
        }

        // é‡Šæ”¾è¿æ¥
        pool.Put(conn)
    }
}
```

### 2. è¶…æ—¶æ§åˆ¶

```go
package timeout

import (
    "context"
    "fmt"
    "net"
    "time"
)

// TimeoutDialer å¸¦è¶…æ—¶çš„æ‹¨å·å™¨
type TimeoutDialer struct {
    dialTimeout   time.Duration
    readTimeout  time.Duration
    writeTimeout time.Duration
}

// NewTimeoutDialer åˆ›å»ºè¶…æ—¶æ‹¨å·å™¨
func NewTimeoutDialer(dialTimeout, readTimeout, writeTimeout time.Duration) *TimeoutDialer {
    return &TimeoutDialer{
        dialTimeout:   dialTimeout,
        readTimeout:  readTimeout,
        writeTimeout: writeTimeout,
    }
}

// Dial å¸¦è¶…æ—¶çš„æ‹¨å·
func (d *TimeoutDialer) Dial(network, address string) (net.Conn, error) {
    ctx, cancel := context.WithTimeout(context.Background(), d.dialTimeout)
    defer cancel()

    dialer := &net.Dialer{}
    conn, err := dialer.DialContext(ctx, network, address)
    if err != nil {
        return nil, fmt.Errorf("dial timeout: %v", err)
    }

    // è®¾ç½®è¯»å†™è¶…æ—¶
    if d.readTimeout > 0 {
        conn.SetReadDeadline(time.Now().Add(d.readTimeout))
    }

    if d.writeTimeout > 0 {
        conn.SetWriteDeadline(time.Now().Add(d.writeTimeout))
    }

    return conn, nil
}

// TimeoutClient å¸¦è¶…æ—¶çš„å®¢æˆ·ç«¯
type TimeoutClient struct {
    dialer *TimeoutDialer
}

// NewTimeoutClient åˆ›å»ºè¶…æ—¶å®¢æˆ·ç«¯
func NewTimeoutClient(dialTimeout, readTimeout, writeTimeout time.Duration) *TimeoutClient {
    return &TimeoutClient{
        dialer: NewTimeoutDialer(dialTimeout, readTimeout, writeTimeout),
    }
}

// Do æ‰§è¡Œå¸¦è¶…æ—¶çš„è¯·æ±‚
func (c *TimeoutClient) Do(address string, request []byte) ([]byte, error) {
    conn, err := c.dialer.Dial("tcp", address)
    if err != nil {
        return nil, err
    }
    defer conn.Close()

    // å†™å…¥è¯·æ±‚
    _, err = conn.Write(request)
    if err != nil {
        return nil, fmt.Errorf("write timeout: %v", err)
    }

    // è¯»å–å“åº”
    buffer := make([]byte, 4096)
    n, err := conn.Read(buffer)
    if err != nil {
        return nil, fmt.Errorf("read timeout: %v", err)
    }

    return buffer[:n], nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    client := NewTimeoutClient(
        time.Second*5,  // æ‹¨å·è¶…æ—¶
        time.Second*10, // è¯»å–è¶…æ—¶
        time.Second*5,  // å†™å…¥è¶…æ—¶
    )

    request := []byte("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
    response, err := client.Do("example.com:80", request)
    if err != nil {
        fmt.Printf("Request failed: %v\n", err)
        return
    }

    fmt.Printf("Response: %s\n", string(response))
}
```

## æ€§èƒ½ä¼˜åŒ–æ¨¡å¼

### 1. å¯¹è±¡æ± 

```go
package pool

import (
    "sync"
)

// ObjectPool å¯¹è±¡æ± 
type ObjectPool struct {
    pool      sync.Pool
    newFunc   func() interface{}
    resetFunc func(interface{})
}

// NewObjectPool åˆ›å»ºå¯¹è±¡æ± 
func NewObjectPool(newFunc func() interface{}, resetFunc func(interface{})) *ObjectPool {
    return &ObjectPool{
        pool: sync.Pool{
            New: newFunc,
        },
        newFunc:   newFunc,
        resetFunc: resetFunc,
    }
}

// Get è·å–å¯¹è±¡
func (p *ObjectPool) Get() interface{} {
    return p.pool.Get()
}

// Put æ”¾å›å¯¹è±¡
func (p *ObjectPool) Put(obj interface{}) {
    if p.resetFunc != nil {
        p.resetFunc(obj)
    }
    p.pool.Put(obj)
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šBufferæ± 
func main() {
    bufferPool := NewObjectPool(
        func() interface{} {
            return make([]byte, 0, 1024)
        },
        func(obj interface{}) {
            buf := obj.([]byte)
            buf = buf[:0] // é‡ç½®buffer
        },
    )

    // ä½¿ç”¨buffer
    buf := bufferPool.Get().([]byte)
    buf = append(buf, "Hello, World!"...)

    // ä½¿ç”¨å®Œåæ”¾å›æ± ä¸­
    bufferPool.Put(buf)
}
```

### 2. æ‰¹é‡å¤„ç†

```go
package batch

import (
    "sync"
    "time"
)

// BatchProcessor æ‰¹é‡å¤„ç†å™¨
type BatchProcessor struct {
    batchSize    int
    flushTimeout time.Duration
    buffer       []interface{}
    processor    func([]interface{})
    mu           sync.Mutex
    ticker       *time.Ticker
    done         chan struct{}
}

// NewBatchProcessor åˆ›å»ºæ‰¹é‡å¤„ç†å™¨
func NewBatchProcessor(batchSize int, flushTimeout time.Duration, processor func([]interface{})) *BatchProcessor {
    bp := &BatchProcessor{
        batchSize:    batchSize,
        flushTimeout: flushTimeout,
        buffer:       make([]interface{}, 0, batchSize),
        processor:    processor,
        ticker:       time.NewTicker(flushTimeout),
        done:         make(chan struct{}),
    }

    go bp.flushLoop()

    return bp
}

// Add æ·»åŠ é¡¹ç›®
func (bp *BatchProcessor) Add(item interface{}) {
    bp.mu.Lock()
    defer bp.mu.Unlock()

    bp.buffer = append(bp.buffer, item)

    if len(bp.buffer) >= bp.batchSize {
        bp.flush()
    }
}

// flush åˆ·æ–°ç¼“å†²åŒº
func (bp *BatchProcessor) flush() {
    if len(bp.buffer) == 0 {
        return
    }

    // å¤åˆ¶ç¼“å†²åŒºé¿å…å¤„ç†è¿‡ç¨‹ä¸­çš„ç«äº‰
    batch := make([]interface{}, len(bp.buffer))
    copy(batch, bp.buffer)
    bp.buffer = bp.buffer[:0]

    // å¼‚æ­¥å¤„ç†
    go bp.processor(batch)
}

// flushLoop å®šæœŸåˆ·æ–°
func (bp *BatchProcessor) flushLoop() {
    for {
        select {
        case <-bp.ticker.C:
            bp.mu.Lock()
            bp.flush()
            bp.mu.Unlock()
        case <-bp.done:
            return
        }
    }
}

// Close å…³é—­å¤„ç†å™¨
func (bp *BatchProcessor) Close() {
    bp.ticker.Stop()
    close(bp.done)

    bp.mu.Lock()
    bp.flush()
    bp.mu.Unlock()
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    processor := NewBatchProcessor(100, time.Second, func(items []interface{}) {
        fmt.Printf("Processing batch of %d items\n", len(items))
        // å¤„ç†æ‰¹é‡æ•°æ®...
    })
    defer processor.Close()

    // æ·»åŠ æ•°æ®
    for i := 0; i < 250; i++ {
        processor.Add(i)
        time.Sleep(time.Millisecond * 10)
    }
}
```

## å®è·µé¡¹ç›®ï¼šåˆ†å¸ƒå¼ä»»åŠ¡å¤„ç†ç³»ç»Ÿ

### é¡¹ç›®æ¦‚è¿°

åŸºäºGoæ¨¡å¼å®ç°ä¸€ä¸ªåˆ†å¸ƒå¼ä»»åŠ¡å¤„ç†ç³»ç»Ÿï¼ŒåŒ…å«ï¼š

1. **ä»»åŠ¡é˜Ÿåˆ—**ï¼šä½¿ç”¨Channelå’ŒWorker Pool
2. **é”™è¯¯å¤„ç†**ï¼šé‡è¯•æœºåˆ¶å’Œæ–­è·¯å™¨
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¯¹è±¡æ± å’Œæ‰¹é‡å¤„ç†
4. **ç›‘æ§**ï¼šæŒ‡æ ‡æ”¶é›†å’Œå¥åº·æ£€æŸ¥

### å®Œæ•´å®ç°

```go
package main

import (
    "context"
    "fmt"
    "log"
    "sync"
    "time"
)

// Task ä»»åŠ¡å®šä¹‰
type Task struct {
    ID        int
    Payload   interface{}
    Retry     int
    CreatedAt time.Time
}

// Result ç»“æœå®šä¹‰
type Result struct {
    TaskID    int
    Success   bool
    Value     interface{}
    Error     error
    Duration  time.Duration
}

// TaskProcessor ä»»åŠ¡å¤„ç†å™¨
type TaskProcessor struct {
    workerPool    *WorkerPool
    retryConfig   RetryConfig
    circuitBreaker *CircuitBreaker
    metrics       *Metrics
}

// NewTaskProcessor åˆ›å»ºä»»åŠ¡å¤„ç†å™¨
func NewTaskProcessor() *TaskProcessor {
    return &TaskProcessor{
        workerPool: NewWorkerPool(5),
        retryConfig: RetryConfig{
            MaxAttempts: 3,
            BaseDelay:   time.Second,
            MaxDelay:    time.Second * 10,
            Jitter:      true,
        },
        circuitBreaker: NewCircuitBreaker(5, time.Second*30),
        metrics:       NewMetrics(),
    }
}

// Start å¯åŠ¨å¤„ç†å™¨
func (tp *TaskProcessor) Start() {
    tp.workerPool.Start()
}

// Stop åœæ­¢å¤„ç†å™¨
func (tp *TaskProcessor) Stop() {
    tp.workerPool.Stop()
}

// Process å¤„ç†ä»»åŠ¡
func (tp *TaskProcessor) Process(task Task) Result {
    start := time.Now()

    result := Result{
        TaskID: task.ID,
    }

    // è®°å½•æŒ‡æ ‡
    tp.metrics.Increment("tasks_total")

    // ä½¿ç”¨æ–­è·¯å™¨ä¿æŠ¤
    err := tp.circuitBreaker.Execute(func() error {
        // ä½¿ç”¨é‡è¯•æœºåˆ¶
        return RetryOperation(context.Background(), tp.retryConfig, func() error {
            // å®é™…å¤„ç†ä»»åŠ¡
            return tp.executeTask(task)
        })
    })

    result.Duration = time.Since(start)

    if err != nil {
        result.Success = false
        result.Error = err
        tp.metrics.Increment("tasks_failed")
    } else {
        result.Success = true
        tp.metrics.Increment("tasks_succeeded")
    }

    // è®°å½•å¤„ç†æ—¶é—´
    tp.metrics.Observe("task_duration_seconds", result.Duration.Seconds())

    return result
}

// executeTask æ‰§è¡Œå…·ä½“ä»»åŠ¡
func (tp *TaskProcessor) executeTask(task Task) error {
    // æ¨¡æ‹Ÿä»»åŠ¡å¤„ç†
    time.Sleep(time.Millisecond * time.Duration(100+task.ID%200))

    // æ¨¡æ‹Ÿéšæœºå¤±è´¥
    if task.ID%10 == 0 {
        return fmt.Errorf("task %d failed", task.ID)
    }

    return nil
}

// Metrics æŒ‡æ ‡æ”¶é›†
type Metrics struct {
    mu    sync.Mutex
    data  map[string]float64
    count map[string]int
}

// NewMetrics åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
func NewMetrics() *Metrics {
    return &Metrics{
        data:  make(map[string]float64),
        count: make(map[string]int),
    }
}

// Increment å¢åŠ è®¡æ•°
func (m *Metrics) Increment(name string) {
    m.mu.Lock()
    defer m.mu.Unlock()

    m.count[name]++
}

// Observe è§‚å¯Ÿå€¼
func (m *Metrics) Observe(name string, value float64) {
    m.mu.Lock()
    defer m.mu.Unlock()

    m.data[name] = value
}

// Get è·å–æŒ‡æ ‡
func (m *Metrics) Get(name string) (float64, bool) {
    m.mu.Lock()
    defer m.mu.Unlock()

    value, exists := m.data[name]
    return value, exists
}

// GetCount è·å–è®¡æ•°
func (m *Metrics) GetCount(name string) (int, bool) {
    m.mu.Lock()
    defer m.mu.Unlock()

    count, exists := m.count[name]
    return count, exists
}

func main() {
    // åˆ›å»ºä»»åŠ¡å¤„ç†å™¨
    processor := NewTaskProcessor()
    processor.Start()
    defer processor.Stop()

    // åˆ›å»ºä»»åŠ¡
    tasks := make([]Task, 100)
    for i := 0; i < 100; i++ {
        tasks[i] = Task{
            ID:        i,
            Payload:   fmt.Sprintf("Task-%d", i),
            CreatedAt: time.Now(),
        }
    }

    // å¤„ç†ä»»åŠ¡
    var wg sync.WaitGroup

    for _, task := range tasks {
        wg.Add(1)
        go func(t Task) {
            defer wg.Done()

            result := processor.Process(t)

            if result.Success {
                log.Printf("Task %d succeeded in %v",
                    result.TaskID, result.Duration)
            } else {
                log.Printf("Task %d failed: %v",
                    result.TaskID, result.Error)
            }
        }(task)
    }

    wg.Wait()

    // è¾“å‡ºæŒ‡æ ‡
    metrics := processor.metrics
    if count, exists := metrics.GetCount("tasks_total"); exists {
        log.Printf("Total tasks: %d", count)
    }

    if count, exists := metrics.GetCount("tasks_succeeded"); exists {
        log.Printf("Succeeded tasks: %d", count)
    }

    if count, exists := metrics.GetCount("tasks_failed"); exists {
        log.Printf("Failed tasks: %d", count)
    }
}
```

## ç»ƒä¹ é¢˜

### æ¦‚å¿µé¢˜

1. **CSPæ¨¡å‹**ï¼šè§£é‡ŠGoçš„CSPæ¨¡å‹ä¸å…¶ä»–å¹¶å‘æ¨¡å‹çš„åŒºåˆ«ã€‚

2. **æ¨¡å¼é€‰æ‹©**ï¼šä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨Worker Poolï¼Œä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨Pipelineï¼Ÿ

3. **é”™è¯¯å¤„ç†**ï¼šä¸ºä»€ä¹ˆåˆ†å¸ƒå¼ç³»ç»Ÿä¸­éœ€è¦é‡è¯•æœºåˆ¶å’Œæ–­è·¯å™¨ï¼Ÿ

4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¯¹è±¡æ± å’Œæ‰¹é‡å¤„ç†çš„é€‚ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿ

### ç¼–ç¨‹é¢˜

1. **å®ç°RPCæ¡†æ¶**ï¼šåŸºäºGoæ¨¡å¼å®ç°ä¸€ä¸ªç®€å•çš„RPCæ¡†æ¶ã€‚

2. **åˆ†å¸ƒå¼ç¼“å­˜**ï¼šå®ç°ä¸€ä¸ªåˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿï¼ŒåŒ…å«ç¼“å­˜æ·˜æ±°å’Œä¸€è‡´æ€§å“ˆå¸Œã€‚

3. **æœåŠ¡å‘ç°**ï¼šå®ç°ä¸€ä¸ªæœåŠ¡å‘ç°ç³»ç»Ÿï¼Œæ”¯æŒå¥åº·æ£€æŸ¥å’Œè´Ÿè½½å‡è¡¡ã€‚

4. **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šå®ç°ä¸€ä¸ªåŸºäºChannelçš„æ¶ˆæ¯é˜Ÿåˆ—ï¼Œæ”¯æŒä¼˜å…ˆçº§å’Œå»¶è¿Ÿã€‚

### è®¾è®¡é¢˜

1. **å¾®æœåŠ¡æ¶æ„**ï¼šè®¾è®¡ä¸€ä¸ªåŸºäºGoçš„å¾®æœåŠ¡æ¶æ„ï¼ŒåŒ…å«æœåŠ¡æ³¨å†Œã€å‘ç°ã€è°ƒç”¨é“¾è¿½è¸ªã€‚

2. **åˆ†å¸ƒå¼é”**ï¼šå®ç°ä¸€ä¸ªåˆ†å¸ƒå¼é”æœåŠ¡ï¼Œæ”¯æŒå¯é‡å…¥å’Œè¶…æ—¶é‡Šæ”¾ã€‚

3. **é…ç½®ä¸­å¿ƒ**ï¼šè®¾è®¡ä¸€ä¸ªé…ç½®ä¸­å¿ƒï¼Œæ”¯æŒåŠ¨æ€é…ç½®å’Œç‰ˆæœ¬ç®¡ç†ã€‚

4. **ç›‘æ§ç³»ç»Ÿ**ï¼šå®ç°ä¸€ä¸ªåˆ†å¸ƒå¼ç›‘æ§ç³»ç»Ÿï¼Œæ”¶é›†å’Œåˆ†æç³»ç»ŸæŒ‡æ ‡ã€‚

## å¸¸è§é—®é¢˜

### Q: Goroutineæ³„æ¼å¦‚ä½•é¿å…ï¼Ÿ

A: ä½¿ç”¨contextåŒ…æ¥ç®¡ç†Goroutineç”Ÿå‘½å‘¨æœŸï¼Œç¡®ä¿èµ„æºæ­£ç¡®é‡Šæ”¾ã€‚å¯ä»¥ä½¿ç”¨sync.WaitGroupæˆ–ä¸“é—¨çš„ç›‘æ§å·¥å…·æ¥æ£€æµ‹æ³„æ¼ã€‚

### Q: Channelçš„ç¼“å†²å¤§å°å¦‚ä½•è®¾ç½®ï¼Ÿ

A: æ ¹æ®å®é™…åœºæ™¯è°ƒæ•´ã€‚å¯¹äºç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ï¼Œç¼“å†²å¤§å°åº”è¯¥èƒ½å¤„ç†çŸ­æš‚çš„ç”Ÿäº§å³°å€¼ï¼Œä½†ä¸å®œè¿‡å¤§ä»¥é¿å…å†…å­˜æµªè´¹ã€‚

### Q: å¦‚ä½•å¤„ç†åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ç½‘ç»œåˆ†åŒºï¼Ÿ

A: ä½¿ç”¨æ–­è·¯å™¨æ¨¡å¼æ¥éš”ç¦»æ•…éšœæœåŠ¡ï¼Œç»“åˆé‡è¯•æœºåˆ¶å’Œä¼˜é›…é™çº§ç­–ç•¥ã€‚å®ç°å¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨æ•…éšœæ¢å¤ã€‚

## æ‰©å±•èµ„æº

### å®˜æ–¹æ–‡æ¡£

1. **[Goå¹¶å‘ç¼–ç¨‹](https://go.dev/doc/effective_go#concurrency)** - Goå®˜æ–¹å¹¶å‘ç¼–ç¨‹æŒ‡å—
2. **[contextåŒ…](https://pkg.go.dev/context)** - ContextåŒ…æ–‡æ¡£
3. **[syncåŒ…](https://pkg.go.dev/sync)** - åŒæ­¥åŸè¯­æ–‡æ¡£

### å¼€æºé¡¹ç›®

1. **[Go-Kit](https://github.com/go-kit/kit)** - å¾®æœåŠ¡å·¥å…·åŒ…
2. **[Gin](https://github.com/gin-gonic/gin)** - Webæ¡†æ¶
3. **[Cobra](https://github.com/spf13/cobra)** - CLIæ¡†æ¶

### åœ¨çº¿è¯¾ç¨‹

1. **[Goç¼–ç¨‹è¯­è¨€](https://tour.golang.org/)** - Goå®˜æ–¹æ•™ç¨‹
2. **[Goå¹¶å‘æ¨¡å¼](https://go.dev/blog/pipelines)** - Goå®˜æ–¹å¹¶å‘æ¨¡å¼åšå®¢
3. **[åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡](https://www.coursera.org/learn/cloud-computing)** - åˆ†å¸ƒå¼ç³»ç»Ÿè¯¾ç¨‹

## ä¸‹ä¸€æ­¥å­¦ä¹ 

åœ¨å®ŒæˆGoæ¨¡å¼å­¦ä¹ åï¼Œä½ åº”è¯¥ç»§ç»­æ·±å…¥ï¼š

1. **ç³»ç»Ÿè®¾è®¡**ï¼šå­¦ä¹ å¦‚ä½•è®¾è®¡é«˜å¯ç”¨ã€å¯æ‰©å±•çš„åˆ†å¸ƒå¼ç³»ç»Ÿ
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ·±å…¥å­¦ä¹ Goæ€§èƒ½åˆ†æå’Œä¼˜åŒ–æŠ€å·§
3. **äº‘åŸç”Ÿ**ï¼šå­¦ä¹ å®¹å™¨åŒ–å’ŒKubernetesç›¸å…³æŠ€æœ¯
4. **ç›‘æ§è¿ç»´**ï¼šå­¦ä¹ åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç›‘æ§å’Œè¿ç»´å®è·µ

---

*Goè¯­è¨€çš„ç®€æ´æ€§å’Œå¼ºå¤§çš„å¹¶å‘ç‰¹æ€§ä½¿å…¶æˆä¸ºæ„å»ºç°ä»£åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç†æƒ³é€‰æ‹©ã€‚æŒæ¡è¿™äº›æ¨¡å¼å°†å¸®åŠ©ä½ æ„å»ºé«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„åˆ†å¸ƒå¼ç³»ç»Ÿã€‚*