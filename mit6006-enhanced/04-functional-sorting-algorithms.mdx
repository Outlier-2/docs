---
title: "排序算法的函数式深度解析"
description: "深入理解排序算法的函数式实现、优化策略和性能分析"
category: "算法"
tags: ["排序算法", "函数式编程", "性能优化", "算法分析"]
difficulty: "中级到高级"
---

# 排序算法的函数式深度解析

## 概念概览

排序算法是计算机科学中的基础问题，也是算法学习的重要起点。本章从函数式编程的角度重新审视传统排序算法，探讨如何在保持算法核心思想的同时，应用函数式编程原则来实现更加优雅、可维护的排序解决方案。

## 排序算法的函数式理论基础

### 1. 排序问题的函数式定义

#### 1.1 排序的数学定义

给定一个序列 $S = \langle s_1, s_2, ..., s_n \rangle$，排序问题要求找到一个排列 $S' = \langle s'_1, s'_2, ..., s'_n \rangle$，使得对于所有的 $i < j$，有 $s'_i \leq s'_j$。

在函数式编程中，排序是一个纯函数：$sort: List[T] \rightarrow List[T]$，其中：
- $sort(S)$ 返回一个新列表
- 原列表 $S$ 保持不变
- 对于所有输入 $S$，有 $sort(S)$ 是有序的

#### 1.2 函数式排序的特性

```python
from typing import List, TypeVar, Callable, Optional
from abc import ABC, abstractmethod

T = TypeVar('T')

class FunctionalSorter(ABC):
    """函数式排序器的抽象基类"""

    @abstractmethod
    def sort(self, data: List[T]) -> List[T]:
        """
        排序函数：必须满足以下特性：
        1. 纯函数：相同输入永远产生相同输出
        2. 不可变：不修改输入列表
        3. 稳定性：相等元素的相对顺序保持不变（如果算法支持）
        """
        pass

    @abstractmethod
    def time_complexity(self) -> str:
        """时间复杂度"""
        pass

    @abstractmethod
    def space_complexity(self) -> str:
        """空间复杂度"""
        pass

    def is_stable(self) -> bool:
        """是否稳定排序"""
        return False

    def is_adaptive(self) -> bool:
        """是否自适应排序"""
        return False
```

### 2. 基础排序算法的函数式实现

#### 2.1 冒泡排序的函数式实现

```python
class FunctionalBubbleSort(FunctionalSorter):
    """函数式冒泡排序"""

    def sort(self, data: List[T]) -> List[T]:
        """
        函数式冒泡排序：
        通过多次遍历列表，将最大的元素"冒泡"到末尾

        时间复杂度：O(n²)
        空间复杂度：O(n)（由于不可变性）
        """
        def bubble_pass(arr: List[T], i: int) -> List[T]:
            """单次冒泡遍历"""
            if i >= len(arr) - 1:
                return arr

            def compare_and_swap(j: int) -> List[T]:
                if j >= len(arr) - 1:
                    return arr
                if arr[j] > arr[j + 1]:
                    # 创建新列表（不可变交换）
                    new_arr = arr.copy()
                    new_arr[j], new_arr[j + 1] = new_arr[j + 1], new_arr[j]
                    return new_arr
                return arr

            # 递归地比较和交换
            result = arr
            for j in range(len(arr) - 1):
                result = compare_and_swap(j)

            return result

        # 多次冒泡遍历
        result = data.copy()
        for i in range(len(result)):
            new_result = bubble_pass(result, i)
            if new_result == result:  # 如果没有交换，说明已经有序
                break
            result = new_result

        return result

    def time_complexity(self) -> str:
        return "O(n²)"

    def space_complexity(self) -> str:
        return "O(n)"

    def is_adaptive(self) -> bool:
        return True  # 对基本有序的数组有优化

# 优化版本：带标志位的冒泡排序
class OptimizedFunctionalBubbleSort(FunctionalSorter):
    """优化的函数式冒泡排序"""

    def sort(self, data: List[T]) -> List[T]:
        """带标志位的冒泡排序，减少不必要的遍历"""
        def bubble_pass_with_flag(arr: List[T]) -> tuple[List[T], bool]:
            """单次冒泡遍历，返回是否发生了交换"""
            new_arr = arr.copy()
            swapped = False

            for i in range(len(new_arr) - 1):
                if new_arr[i] > new_arr[i + 1]:
                    new_arr[i], new_arr[i + 1] = new_arr[i + 1], new_arr[i]
                    swapped = True

            return new_arr, swapped

        result = data.copy()
        for i in range(len(result)):
            new_result, swapped = bubble_pass_with_flag(result)
            if not swapped:  # 如果没有交换，提前终止
                break
            result = new_result

        return result

    def time_complexity(self) -> str:
        return "O(n²) (但最坏情况下有优化)"

    def space_complexity(self) -> str:
        return "O(n)"

    def is_adaptive(self) -> bool:
        return True
```

#### 2.2 选择排序的函数式实现

```python
class FunctionalSelectionSort(FunctionalSorter):
    """函数式选择排序"""

    def sort(self, data: List[T]) -> List[T]:
        """
        函数式选择排序：
        每次找到最小元素，放到有序部分的末尾

        时间复杂度：O(n²)
        空间复杂度：O(n)
        """
        def find_min_index(arr: List[T], start: int) -> int:
            """从start位置开始找到最小元素的索引"""
            min_index = start
            for i in range(start + 1, len(arr)):
                if arr[i] < arr[min_index]:
                    min_index = i
            return min_index

        result = data.copy()

        for i in range(len(result)):
            # 找到最小元素的索引
            min_index = find_min_index(result, i)

            # 如果最小元素不在当前位置，交换
            if min_index != i:
                new_result = result.copy()
                new_result[i], new_result[min_index] = new_result[min_index], new_result[i]
                result = new_result

        return result

    def time_complexity(self) -> str:
        return "O(n²)"

    def space_complexity(self) -> str:
        return "O(n)"
```

#### 2.3 插入排序的函数式实现

```python
class FunctionalInsertionSort(FunctionalSorter):
    """函数式插入排序"""

    def sort(self, data: List[T]) -> List[T]:
        """
        函数式插入排序：
        逐个将元素插入到已排序部分的正确位置

        时间复杂度：O(n²)
        空间复杂度：O(n)
        """
        def insert_sorted(arr: List[T], value: T) -> List[T]:
            """将值插入到已排序列表的正确位置"""
            result = []
            inserted = False

            for item in arr:
                if not inserted and item > value:
                    result.append(value)
                    inserted = True
                result.append(item)

            if not inserted:
                result.append(value)

            return result

        # 逐步构建有序列表
        result = []
        for item in data:
            result = insert_sorted(result, item)

        return result

    def time_complexity(self) -> str:
        return "O(n²)"

    def space_complexity(self) -> str:
        return "O(n)"

    def is_adaptive(self) -> bool:
        return True  # 对基本有序的数组效率较高
```

## 高级排序算法的函数式实现

### 1. 归并排序的函数式实现

#### 1.1 经典归并排序

```python
class FunctionalMergeSort(FunctionalSorter):
    """函数式归并排序"""

    def sort(self, data: List[T]) -> List[T]:
        """
        函数式归并排序：
        分治策略，递归地将列表分成两半，然后合并有序的子列表

        时间复杂度：O(n log n)
        空间复杂度：O(n)
        """
        def merge(left: List[T], right: List[T]) -> List[T]:
            """合并两个有序列表"""
            result = []
            i = j = 0

            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1

            # 添加剩余元素
            result.extend(left[i:])
            result.extend(right[j:])

            return result

        # 基本情况：空列表或单元素列表已经有序
        if len(data) <= 1:
            return data.copy()

        # 递归排序
        mid = len(data) // 2
        left_sorted = self.sort(data[:mid])
        right_sorted = self.sort(data[mid:])

        # 合并结果
        return merge(left_sorted, right_sorted)

    def time_complexity(self) -> str:
        return "O(n log n)"

    def space_complexity(self) -> str:
        return "O(n)"

    def is_stable(self) -> bool:
        return True  # 归并排序是稳定的
```

#### 1.2 优化的归并排序

```python
class OptimizedFunctionalMergeSort(FunctionalSorter):
    """优化的函数式归并排序"""

    def sort(self, data: List[T]) -> List[T]:
        """优化的归并排序，包含多种优化策略"""
        # 优化1：对小数组使用插入排序
        INSERTION_THRESHOLD = 16

        def insertion_sort_small(arr: List[T]) -> List[T]:
            """对小数组使用插入排序"""
            if len(arr) <= 1:
                return arr

            result = []
            for item in arr:
                # 插入到正确位置
                inserted = False
                temp = []
                for existing in result:
                    if not inserted and existing > item:
                        temp.append(item)
                        inserted = True
                    temp.append(existing)
                if not inserted:
                    temp.append(item)
                result = temp

            return result

        def merge_optimized(left: List[T], right: List[T]) -> List[T]:
            """优化的合并操作"""
            # 优化2：避免重复创建小列表
            result = []
            left_iter = iter(left)
            right_iter = iter(right)

            left_val = next(left_iter, None)
            right_val = next(right_iter, None)

            while left_val is not None and right_val is not None:
                if left_val <= right_val:
                    result.append(left_val)
                    left_val = next(left_iter, None)
                else:
                    result.append(right_val)
                    right_val = next(right_iter, None)

            # 添加剩余元素
            if left_val is not None:
                result.append(left_val)
                result.extend(left_iter)

            if right_val is not None:
                result.append(right_val)
                result.extend(right_iter)

            return result

        def merge_sort_recursive(arr: List[T]) -> List[T]:
            """递归的归并排序"""
            # 基本情况
            if len(arr) <= 1:
                return arr

            # 优化：对小数组使用插入排序
            if len(arr) <= INSERTION_THRESHOLD:
                return insertion_sort_small(arr)

            # 递归排序
            mid = len(arr) // 2
            left_sorted = merge_sort_recursive(arr[:mid])
            right_sorted = merge_sort_recursive(arr[mid:])

            return merge_optimized(left_sorted, right_sorted)

        return merge_sort_recursive(data)

    def time_complexity(self) -> str:
        return "O(n log n) (实际运行更快)"

    def space_complexity(self) -> str:
        return "O(n)"

    def is_stable(self) -> bool:
        return True
```

### 2. 快速排序的函数式实现

#### 2.1 经典快速排序

```python
class FunctionalQuickSort(FunctionalSorter):
    """函数式快速排序"""

    def sort(self, data: List[T]) -> List[T]:
        """
        函数式快速排序：
        选择基准元素，将列表分成小于基准和大于基准的两部分，递归排序

        时间复杂度：平均O(n log n)，最坏O(n²)
        空间复杂度：O(n)（由于递归和不可变性）
        """
        if len(data) <= 1:
            return data.copy()

        # 选择基准元素（这里选择第一个元素）
        pivot = data[0]

        # 分区操作
        left = [x for x in data[1:] if x <= pivot]
        right = [x for x in data[1:] if x > pivot]

        # 递归排序并合并
        return self.sort(left) + [pivot] + self.sort(right)

    def time_complexity(self) -> str:
        return "平均O(n log n)，最坏O(n²)"

    def space_complexity(self) -> str:
        return "O(n) (递归栈)"
```

#### 2.2 优化的快速排序

```python
class OptimizedFunctionalQuickSort(FunctionalSorter):
    """优化的函数式快速排序"""

    def sort(self, data: List[T]) -> List[T]:
        """包含多种优化策略的快速排序"""
        # 优化1：对小数组使用插入排序
        INSERTION_THRESHOLD = 16

        def insertion_sort_small(arr: List[T]) -> List[T]:
            """小数组插入排序"""
            if len(arr) <= 1:
                return arr

            result = []
            for item in arr:
                temp = []
                inserted = False
                for existing in result:
                    if not inserted and existing > item:
                        temp.append(item)
                        inserted = True
                    temp.append(existing)
                if not inserted:
                    temp.append(item)
                result = temp

            return result

        def choose_pivot(arr: List[T]) -> T:
            """优化2：三数取中法选择基准"""
            if len(arr) <= 2:
                return arr[0]

            first, middle, last = arr[0], arr[len(arr) // 2], arr[-1]
            return sorted([first, middle, last])[1]

        def partition(arr: List[T], pivot: T) -> tuple[List[T], List[T]]:
            """分区操作，将数组分成小于等于基准和大于基准的两部分"""
            less_equal = []
            greater = []

            for item in arr:
                if item <= pivot:
                    less_equal.append(item)
                else:
                    greater.append(item)

            return less_equal, greater

        def quick_sort_recursive(arr: List[T]) -> List[T]:
            """递归的快速排序"""
            if len(arr) <= 1:
                return arr

            # 优化：对小数组使用插入排序
            if len(arr) <= INSERTION_THRESHOLD:
                return insertion_sort_small(arr)

            # 选择基准
            pivot = choose_pivot(arr)

            # 分区
            less_equal, greater = partition(arr, pivot)

            # 递归排序
            sorted_less = quick_sort_recursive(less_equal)
            sorted_greater = quick_sort_recursive(greater)

            # 合并结果
            return sorted_less + sorted_greater

        return quick_sort_recursive(data)

    def time_complexity(self) -> str:
        return "平均O(n log n)，最坏情况减少"

    def space_complexity(self) -> str:
        return "O(n)"
```

#### 2.3 三路快速排序

```python
class FunctionalThreeWayQuickSort(FunctionalSorter):
    """函数式三路快速排序（处理重复元素）"""

    def sort(self, data: List[T]) -> List[T]:
        """
        三路快速排序：
        将数组分成小于基准、等于基准、大于基准的三部分
        特别适合有大量重复元素的情况
        """
        if len(data) <= 1:
            return data.copy()

        # 选择基准
        pivot = data[0]

        # 三路分区
        less = [x for x in data if x < pivot]
        equal = [x for x in data if x == pivot]
        greater = [x for x in data if x > pivot]

        # 递归排序并合并
        return self.sort(less) + equal + self.sort(greater)

    def time_complexity(self) -> str:
        return "O(n log n)，对重复元素有优化"

    def space_complexity(self) -> str:
        return "O(n)"
```

### 3. 堆排序的函数式实现

#### 3.1 基于列表的堆排序

```python
class FunctionalHeapSort(FunctionalSorter):
    """函数式堆排序"""

    def sort(self, data: List[T]) -> List[T]:
        """
        函数式堆排序：
        使用堆数据结构进行排序

        时间复杂度：O(n log n)
        空间复杂度：O(n)
        """
        def heapify(arr: List[T], n: int, i: int) -> List[T]:
            """堆化操作"""
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2

            if left < n and arr[left] > arr[largest]:
                largest = left

            if right < n and arr[right] > arr[largest]:
                largest = right

            if largest != i:
                # 交换
                new_arr = arr.copy()
                new_arr[i], new_arr[largest] = new_arr[largest], new_arr[i]
                # 递归堆化
                return heapify(new_arr, n, largest)

            return arr

        def build_heap(arr: List[T]) -> List[T]:
            """构建最大堆"""
            n = len(arr)
            result = arr.copy()

            # 从最后一个非叶子节点开始
            for i in range(n // 2 - 1, -1, -1):
                result = heapify(result, n, i)

            return result

        # 构建最大堆
        heap = build_heap(data)

        # 逐个提取最大元素
        result = []
        for i in range(len(heap) - 1, -1, -1):
            # 交换堆顶和当前元素
            new_heap = heap.copy()
            new_heap[0], new_heap[i] = new_heap[i], new_heap[0]

            # 将最大元素添加到结果
            result.insert(0, new_heap[i])

            # 重新堆化
            heap = heapify(new_heap, i, 0)

        return result

    def time_complexity(self) -> str:
        return "O(n log n)"

    def space_complexity(self) -> str:
        return "O(n)"
```

## 函数式排序算法的性能优化

### 1. 记忆化技术

#### 1.1 缓存排序结果

```python
from functools import lru_cache

class MemoizedFunctionalSorter(FunctionalSorter):
    """带记忆化的函数式排序器"""

    def __init__(self, base_sorter: FunctionalSorter):
        self.base_sorter = base_sorter

    @lru_cache(maxsize=1000)
    def sort(self, data: tuple[T, ...]) -> tuple[T, ...]:
        """带缓存的排序函数"""
        # 将列表转换为元组以便缓存
        return tuple(self.base_sorter.sort(list(data)))

    def sort_list(self, data: List[T]) -> List[T]:
        """排序列表的包装函数"""
        return list(self.sort(tuple(data)))

    def time_complexity(self) -> str:
        return self.base_sorter.time_complexity() + " (带缓存优化)"

    def space_complexity(self) -> str:
        return self.base_sorter.space_complexity() + " (加上缓存空间)"

    def cache_info(self):
        """获取缓存信息"""
        return self.sort.cache_info()
```

### 2. 并行排序

#### 2.1 并行归并排序

```python
from concurrent.futures import ThreadPoolExecutor
import multiprocessing

class ParallelFunctionalMergeSort(FunctionalSorter):
    """并行函数式归并排序"""

    def __init__(self, base_sorter: FunctionalSorter = None):
        self.base_sorter = base_sorter or FunctionalMergeSort()

    def sort(self, data: List[T]) -> List[T]:
        """并行归并排序"""
        if len(data) <= 1000:  # 小数组直接排序
            return self.base_sorter.sort(data)

        # 分割数据
        mid = len(data) // 2
        left_data = data[:mid]
        right_data = data[mid:]

        # 并行排序
        with ThreadPoolExecutor(max_workers=2) as executor:
            left_future = executor.submit(self.sort, left_data)
            right_future = executor.submit(self.sort, right_data)

            left_sorted = left_future.result()
            right_sorted = right_future.result()

        # 合并结果
        return self._merge(left_sorted, right_sorted)

    def _merge(self, left: List[T], right: List[T]) -> List[T]:
        """合并两个有序列表"""
        result = []
        i = j = 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1

        result.extend(left[i:])
        result.extend(right[j:])

        return result

    def time_complexity(self) -> str:
        return "O(n log n / p) 其中p是处理器数量"

    def space_complexity(self) -> str:
        return "O(n)"
```

### 3. 自适应排序

#### 3.1 混合排序策略

```python
class AdaptiveFunctionalSorter(FunctionalSorter):
    """自适应函数式排序器"""

    def __init__(self):
        self.small_sorter = FunctionalInsertionSort()
        self.medium_sorter = FunctionalMergeSort()
        self.large_sorter = OptimizedFunctionalQuickSort()

    def sort(self, data: List[T]) -> List[T]:
        """根据数据特征选择最优排序算法"""
        n = len(data)

        if n <= 16:
            # 小数组使用插入排序
            return self.small_sorter.sort(data)
        elif n <= 1000:
            # 中等数组使用归并排序
            return self.medium_sorter.sort(data)
        else:
            # 大数组使用快速排序
            return self.large_sorter.sort(data)

    def time_complexity(self) -> str:
        return "自适应：根据数据规模选择最优算法"

    def space_complexity(self) -> str:
        return "O(n)"
```

## 排序算法的函数式组合

### 1. 算法组合模式

#### 1.1 策略模式实现

```python
from typing import Dict, Any

class SortingStrategy:
    """排序策略的函数式实现"""

    def __init__(self, name: str, sorter: FunctionalSorter,
                 conditions: Dict[str, Any] = None):
        self.name = name
        self.sorter = sorter
        self.conditions = conditions or {}

    def can_handle(self, data: List[T]) -> bool:
        """检查是否可以处理给定的数据"""
        for key, value in self.conditions.items():
            if key == 'min_size' and len(data) < value:
                return False
            if key == 'max_size' and len(data) > value:
                return False
            if key == 'is_sorted' and value != self._is_sorted(data):
                return False
        return True

    def _is_sorted(self, data: List[T]) -> bool:
        """检查是否已排序"""
        return all(data[i] <= data[i + 1] for i in range(len(data) - 1))

    def sort(self, data: List[T]) -> List[T]:
        """执行排序"""
        return self.sorter.sort(data)

class SortingStrategyManager:
    """排序策略管理器"""

    def __init__(self):
        self.strategies: List[SortingStrategy] = [
            SortingStrategy("Insertion Sort", FunctionalInsertionSort(),
                          {"max_size": 16}),
            SortingStrategy("Merge Sort", FunctionalMergeSort(),
                          {"min_size": 17, "max_size": 1000}),
            SortingStrategy("Quick Sort", OptimizedFunctionalQuickSort(),
                          {"min_size": 1001}),
        ]

    def sort(self, data: List[T]) -> tuple[List[T], str]:
        """选择最优策略并排序"""
        for strategy in self.strategies:
            if strategy.can_handle(data):
                return strategy.sort(data), strategy.name

        # 默认使用快速排序
        return self.strategies[-1].sort(data), self.strategies[-1].name
```

#### 1.2 装饰器模式实现

```python
class SortingDecorator(FunctionalSorter):
    """排序装饰器基类"""

    def __init__(self, sorter: FunctionalSorter):
        self.sorter = sorter

    def sort(self, data: List[T]) -> List[T]:
        """装饰排序操作"""
        return self._decorate_sort(data)

    def _decorate_sort(self, data: List[T]) -> List[T]:
        """装饰排序的具体实现"""
        return self.sorter.sort(data)

class LoggingSortingDecorator(SortingDecorator):
    """带日志的排序装饰器"""

    def _decorate_sort(self, data: List[T]) -> List[T]:
        """添加日志记录"""
        import time
        print(f"Starting {self.sorter.__class__.__name__} with {len(data)} elements")

        start_time = time.time()
        result = self.sorter.sort(data)
        end_time = time.time()

        print(f"Completed in {end_time - start_time:.4f} seconds")
        return result

class ValidationSortingDecorator(SortingDecorator):
    """带验证的排序装饰器"""

    def _decorate_sort(self, data: List[T]) -> List[T]:
        """验证排序结果"""
        result = self.sorter.sort(data)

        # 验证排序结果
        if not self._is_sorted(result):
            raise RuntimeError("Sorting failed: result is not sorted")

        # 验证元素完整性
        if sorted(data) != result:
            raise RuntimeError("Sorting failed: elements changed")

        return result

    def _is_sorted(self, data: List[T]) -> bool:
        """检查是否已排序"""
        return all(data[i] <= data[i + 1] for i in range(len(data) - 1))
```

## 实际应用案例

### 1. 大数据集排序

#### 1.1 外部排序实现

```python
class ExternalFunctionalSorter:
    """函数式外部排序（处理内存无法容纳的大数据）"""

    def __init__(self, chunk_size: int = 1000000, temp_dir: str = "./temp"):
        self.chunk_size = chunk_size
        self.temp_dir = temp_dir
        self.sorter = FunctionalMergeSort()

    def sort_large_file(self, input_file: str, output_file: str) -> None:
        """排序大文件"""
        import os
        import tempfile

        # 创建临时目录
        os.makedirs(self.temp_dir, exist_ok=True)

        # 第一阶段：分块排序
        temp_files = []
        with open(input_file, 'r') as f:
            chunk = []
            for line in f:
                chunk.append(int(line.strip()))
                if len(chunk) >= self.chunk_size:
                    # 排序当前块
                    sorted_chunk = self.sorter.sort(chunk)
                    # 写入临时文件
                    temp_file = os.path.join(self.temp_dir, f"temp_{len(temp_files)}.tmp")
                    with open(temp_file, 'w') as temp_f:
                        for item in sorted_chunk:
                            temp_f.write(f"{item}\n")
                    temp_files.append(temp_file)
                    chunk = []

            # 处理剩余数据
            if chunk:
                sorted_chunk = self.sorter.sort(chunk)
                temp_file = os.path.join(self.temp_dir, f"temp_{len(temp_files)}.tmp")
                with open(temp_file, 'w') as temp_f:
                    for item in sorted_chunk:
                        temp_f.write(f"{item}\n")
                temp_files.append(temp_file)

        # 第二阶段：归并排序
        self._merge_files(temp_files, output_file)

        # 清理临时文件
        for temp_file in temp_files:
            os.remove(temp_file)
        os.rmdir(self.temp_dir)

    def _merge_files(self, temp_files: List[str], output_file: str) -> None:
        """归并多个已排序的临时文件"""
        import heapq

        # 打开所有临时文件
        file_handles = []
        for temp_file in temp_files:
            f = open(temp_file, 'r')
            file_handles.append(f)

        # 使用堆进行归并
        heap = []
        for i, f in enumerate(file_handles):
            line = f.readline()
            if line:
                heapq.heappush(heap, (int(line.strip()), i, f))

        # 写入结果
        with open(output_file, 'w') as out_f:
            while heap:
                value, file_index, f = heapq.heappop(heap)
                out_f.write(f"{value}\n")

                # 从同一个文件读取下一个值
                line = f.readline()
                if line:
                    heapq.heappush(heap, (int(line.strip()), file_index, f))

        # 关闭所有文件
        for f in file_handles:
            f.close()
```

### 2. 分布式排序

#### 2.1 MapReduce风格的排序

```python
class MapReduceSorter:
    """MapReduce风格的分布式排序"""

    def __init__(self, mapper_func=None, reducer_func=None):
        self.mapper_func = mapper_func or (lambda x: (x, x))
        self.reducer_func = reducer_func or (lambda x: x)

    def sort_distributed(self, data: List[T], num_workers: int = 4) -> List[T]:
        """分布式排序"""
        from concurrent.futures import ProcessPoolExecutor
        import multiprocessing

        # 分割数据
        chunk_size = len(data) // num_workers
        chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]

        # Map阶段：本地排序
        with ProcessPoolExecutor(max_workers=num_workers) as executor:
            mapped_chunks = list(executor.map(self._map_chunk, chunks))

        # Shuffle阶段：重新分区
        shuffled = self._shuffle(mapped_chunks, num_workers)

        # Reduce阶段：归并排序
        with ProcessPoolExecutor(max_workers=num_workers) as executor:
            reduced_chunks = list(executor.map(self._reduce_chunk, shuffled))

        # 最终合并
        final_result = []
        for chunk in reduced_chunks:
            final_result.extend(chunk)

        return final_result

    def _map_chunk(self, chunk: List[T]) -> List[tuple]:
        """Map阶段：对每个数据块进行本地排序"""
        # 应用映射函数
        mapped = [self.mapper_func(item) for item in chunk]

        # 本地排序
        mapped.sort(key=lambda x: x[0])

        return mapped

    def _shuffle(self, mapped_chunks: List[List[tuple]], num_workers: int) -> List[List[tuple]]:
        """Shuffle阶段：重新分区"""
        # 简化的shuffle：按范围分区
        all_items = []
        for chunk in mapped_chunks:
            all_items.extend(chunk)

        # 按键排序
        all_items.sort(key=lambda x: x[0])

        # 重新分区
        chunk_size = len(all_items) // num_workers
        shuffled_chunks = []
        for i in range(0, len(all_items), chunk_size):
            shuffled_chunks.append(all_items[i:i + chunk_size])

        return shuffled_chunks

    def _reduce_chunk(self, chunk: List[tuple]) -> List[T]:
        """Reduce阶段：对每个分区进行归并排序"""
        # 提取值
        values = [item[1] for item in chunk]

        # 应用归约函数
        reduced = [self.reducer_func(value) for value in values]

        return reduced
```

## 排序算法的测试和验证

### 1. 自动化测试

#### 1.1 单元测试框架

```python
import unittest
import random
import time
from typing import List, Type

class SortingTestSuite(unittest.TestCase):
    """排序算法测试套件"""

    def setUp(self):
        """设置测试数据"""
        self.test_cases = [
            # 空列表
            [],
            # 单元素列表
            [1],
            # 已排序列表
            [1, 2, 3, 4, 5],
            # 逆序列表
            [5, 4, 3, 2, 1],
            # 随机列表
            [3, 1, 4, 1, 5, 9, 2, 6, 5, 3],
            # 重复元素
            [2, 2, 2, 2, 2],
            # 大列表
            list(range(1000, 0, -1))
        ]

        self.sorters: List[Type[FunctionalSorter]] = [
            FunctionalBubbleSort,
            FunctionalInsertionSort,
            FunctionalMergeSort,
            FunctionalQuickSort,
            FunctionalHeapSort,
        ]

    def test_sorting_correctness(self):
        """测试排序正确性"""
        for sorter_class in self.sorters:
            with self.subTest(sorter=sorter_class.__name__):
                sorter = sorter_class()

                for i, test_data in enumerate(self.test_cases):
                    with self.subTest(test_case=i):
                        result = sorter.sort(test_data)

                        # 验证排序正确性
                        self.assertTrue(self._is_sorted(result),
                                       f"{sorter_class.__name__} failed on test case {i}")

                        # 验证元素完整性
                        self.assertEqual(sorted(test_data), result,
                                       f"{sorter_class.__name__} changed elements in test case {i}")

    def test_sorting_performance(self):
        """测试排序性能"""
        performance_results = {}

        for sorter_class in self.sorters:
            sorter = sorter_class()
            times = []

            # 测试不同规模的数据
            for size in [100, 1000, 5000]:
                test_data = [random.randint(1, 10000) for _ in range(size)]

                start_time = time.time()
                result = sorter.sort(test_data)
                end_time = time.time()

                times.append(end_time - start_time)

                # 验证结果正确性
                self.assertTrue(self._is_sorted(result))

            performance_results[sorter_class.__name__] = times

        # 打印性能报告
        self._print_performance_report(performance_results)

    def _is_sorted(self, data: List[T]) -> bool:
        """检查列表是否已排序"""
        return all(data[i] <= data[i + 1] for i in range(len(data) - 1))

    def _print_performance_report(self, results: Dict[str, List[float]]):
        """打印性能报告"""
        print("\n=== Performance Report ===")
        print(f"{'Algorithm':<25} {'100 elements':<15} {'1000 elements':<15} {'5000 elements':<15}")
        print("-" * 70)

        for algorithm, times in results.items():
            print(f"{algorithm:<25} {times[0]:<15.4f} {times[1]:<15.4f} {times[2]:<15.4f}")

    def test_stability(self):
        """测试排序稳定性"""
        # 创建包含重复键的测试数据
        test_data = [(1, 'a'), (2, 'b'), (1, 'c'), (3, 'd'), (2, 'e'), (1, 'f')]

        # 使用已知的稳定排序算法
        stable_sorter = FunctionalMergeSort()
        result = stable_sorter.sort(test_data)

        # 检查相同键的相对顺序是否保持不变
        ones = [(k, v) for k, v in result if k == 1]
        self.assertEqual(['a', 'c', 'f'], [v for k, v in ones])

        twos = [(k, v) for k, v in result if k == 2]
        self.assertEqual(['b', 'e'], [v for k, v in twos])

# 运行测试
if __name__ == '__main__':
    unittest.main()
```

## 总结

本章深入探讨了排序算法的函数式实现：

### 核心概念：

1. **函数式排序理论**：排序作为纯函数，保证不可变性和引用透明性
2. **基础排序算法**：冒泡排序、选择排序、插入排序的函数式实现
3. **高级排序算法**：归并排序、快速排序、堆排序的函数式优化
4. **性能优化策略**：记忆化、并行处理、自适应算法选择

### 实现技术：

1. **递归实现**：使用递归实现分治算法
2. **列表推导式**：使用Python的列表推导式进行函数式编程
3. **装饰器模式**：为排序算法添加日志、验证等功能
4. **策略模式**：根据数据特征动态选择最优算法

### 实际应用：

1. **大数据排序**：处理内存无法容纳的大数据集
2. **分布式排序**：使用MapReduce进行分布式排序
3. **外部排序**：基于磁盘的外部排序算法
4. **性能测试**：完整的测试框架验证算法正确性和性能

### 优化策略：

1. **算法选择**：根据数据规模和特征选择合适的算法
2. **并行处理**：利用多核处理器提高排序速度
3. **缓存优化**：使用记忆化减少重复计算
4. **内存管理**：优化内存使用，减少垃圾回收

通过深入理解这些概念和技术，学员可以掌握函数式排序算法的设计原理和实现方法，为后续学习更复杂的算法打下坚实基础。这些技术不仅在学术研究中有重要意义，在实际工程项目中也有广泛应用。