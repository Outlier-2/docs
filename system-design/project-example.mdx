---
title: "é¡¹ç›®æ¡ˆä¾‹ - è®¾è®¡ä¸€ä¸ªç¤¾äº¤åª’ä½“ç³»ç»Ÿ"
description: "ç»¼åˆå®è·µæ¡ˆä¾‹ï¼šä»é›¶å¼€å§‹è®¾è®¡ä¸€ä¸ªç±»ä¼¼Twitterçš„ç¤¾äº¤åª’ä½“ç³»ç»Ÿï¼Œåº”ç”¨æ‰€å­¦çš„ç³»ç»Ÿè®¾è®¡çŸ¥è¯†"
---

# é¡¹ç›®æ¡ˆä¾‹ - è®¾è®¡ä¸€ä¸ªç¤¾äº¤åª’ä½“ç³»ç»Ÿ

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®å°†è®¾è®¡ä¸€ä¸ªç±»ä¼¼Twitterçš„ç¤¾äº¤åª’ä½“ç³»ç»Ÿï¼Œåº”ç”¨å‰å‡ å‘¨å­¦ä¹ çš„ç³»ç»Ÿè®¾è®¡çŸ¥è¯†ï¼ŒåŒ…æ‹¬ç³»ç»Ÿè®¾è®¡æ€ç»´ã€è®¾è®¡æ¨¡å¼ã€å¾®æœåŠ¡æ¶æ„ç­‰ã€‚

## éœ€æ±‚åˆ†æ

### åŠŸèƒ½éœ€æ±‚

1. **ç”¨æˆ·ç®¡ç†**
   - ç”¨æˆ·æ³¨å†Œå’Œç™»å½•
   - ä¸ªäººèµ„æ–™ç®¡ç†
   - å…³æ³¨/å–æ¶ˆå…³æ³¨å…¶ä»–ç”¨æˆ·
   - ç”¨æˆ·æƒé™ç®¡ç†

2. **å†…å®¹ç®¡ç†**
   - å‘å¸ƒæ¨æ–‡ï¼ˆæ–‡æœ¬ã€å›¾ç‰‡ã€è§†é¢‘ï¼‰
   - ç¼–è¾‘å’Œåˆ é™¤æ¨æ–‡
   - æ¨æ–‡è½¬å‘å’Œå¼•ç”¨
   - æ¨æ–‡æœç´¢åŠŸèƒ½

3. **ç¤¾äº¤äº’åŠ¨**
   - ç‚¹èµæ¨æ–‡
   - è¯„è®ºæ¨æ–‡
   - ç§ä¿¡åŠŸèƒ½
   - é€šçŸ¥ç³»ç»Ÿ

4. **ä¿¡æ¯æµ**
   - æ—¶é—´çº¿å±•ç¤º
   - æ¨èå†…å®¹
   - çƒ­é—¨è¯é¢˜
   - è¶‹åŠ¿åˆ†æ

### éåŠŸèƒ½éœ€æ±‚

1. **æ€§èƒ½è¦æ±‚**
   - é¡µé¢åŠ è½½æ—¶é—´ < 2ç§’
   - APIå“åº”æ—¶é—´ < 200ms
   - æ”¯æŒ100ä¸‡æ—¥æ´»ç”¨æˆ·
   - å³°å€¼QPSï¼š10,000

2. **å¯æ‰©å±•æ€§**
   - æ”¯æŒç”¨æˆ·é‡å¢é•¿åˆ°1000ä¸‡
   - æ•°æ®é‡å¢é•¿åˆ°10TB
   - æ”¯æŒå…¨çƒéƒ¨ç½²

3. **å¯ç”¨æ€§**
   - 99.9%çš„ç³»ç»Ÿå¯ç”¨æ€§
   - æ•…éšœæ¢å¤æ—¶é—´ < 5åˆ†é’Ÿ
   - æ•°æ®å¤‡ä»½å’Œæ¢å¤

4. **å®‰å…¨æ€§**
   - ç”¨æˆ·æ•°æ®åŠ å¯†
   - é˜²æ­¢SQLæ³¨å…¥
   - APIè®¿é—®æ§åˆ¶
   - å†…å®¹å®¡æ ¸

## ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯"
        A[Webåº”ç”¨]
        B[iOSåº”ç”¨]
        C[Androidåº”ç”¨]
    end

    subgraph "CDN"
        D[CDN]
    end

    subgraph "è´Ÿè½½å‡è¡¡"
        E[è´Ÿè½½å‡è¡¡å™¨]
    end

    subgraph "APIç½‘å…³"
        F[API Gateway]
    end

    subgraph "å¾®æœåŠ¡é›†ç¾¤"
        G[ç”¨æˆ·æœåŠ¡]
        H[æ¨æ–‡æœåŠ¡]
        I[å…³ç³»æœåŠ¡]
        J[é€šçŸ¥æœåŠ¡]
        K[æœç´¢æœåŠ¡]
        L[æ¨èæœåŠ¡]
    end

    subgraph "æ¶ˆæ¯é˜Ÿåˆ—"
        M[Kafka]
    end

    subgraph "ç¼“å­˜å±‚"
        N[Redis Cluster]
    end

    subgraph "æ•°æ®å±‚"
        O[(ç”¨æˆ·DB)]
        P[(æ¨æ–‡DB)]
        Q[(å…³ç³»DB)]
        R[(æœç´¢å¼•æ“)]
    end

    subgraph "å­˜å‚¨å±‚"
        S[å¯¹è±¡å­˜å‚¨]
    end

    A --> E
    B --> E
    C --> E
    E --> F
    F --> G
    F --> H
    F --> I
    F --> J
    F --> K
    F --> L

    G --> O
    H --> P
    I --> Q
    K --> R

    H --> M
    J --> M
    L --> M

    G --> N
    H --> N
    I --> N
    K --> N

    H --> S
    J --> S

    D --> A
    D --> B
    D --> C
```

### å¾®æœåŠ¡æ‹†åˆ†

#### 1. ç”¨æˆ·æœåŠ¡ (User Service)
- **èŒè´£**ï¼šç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€èµ„æ–™ç®¡ç†ã€è®¤è¯æˆæƒ
- **æ•°æ®æ¨¡å‹**ï¼šç”¨æˆ·åŸºæœ¬ä¿¡æ¯ã€è®¤è¯ä¿¡æ¯ã€è®¾ç½®åå¥½
- **APIæ¥å£**ï¼š
  - `POST /api/users/register` - ç”¨æˆ·æ³¨å†Œ
  - `POST /api/users/login` - ç”¨æˆ·ç™»å½•
  - `GET /api/users/{id}` - è·å–ç”¨æˆ·ä¿¡æ¯
  - `PUT /api/users/{id}` - æ›´æ–°ç”¨æˆ·ä¿¡æ¯

```python
# ç”¨æˆ·æœåŠ¡æ ¸å¿ƒä»£ç 
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import Optional
import bcrypt
import jwt
from datetime import datetime, timedelta

app = FastAPI()

class User(BaseModel):
    id: Optional[str] = None
    username: str
    email: str
    password: str
    full_name: str
    bio: Optional[str] = None
    avatar_url: Optional[str] = None
    created_at: Optional[datetime] = None

class UserResponse(BaseModel):
    id: str
    username: str
    email: str
    full_name: str
    bio: Optional[str] = None
    avatar_url: Optional[str] = None
    created_at: datetime

class UserService:
    def __init__(self, db_client, redis_client):
        self.db_client = db_client
        self.redis_client = redis_client
        self.jwt_secret = "your-secret-key"

    async def register_user(self, user_data: dict) -> UserResponse:
        """æ³¨å†Œç”¨æˆ·"""
        # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
        if await self.db_client.users.find_one({"username": user_data["username"]}):
            raise HTTPException(status_code=400, detail="Username already exists")

        # æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
        if await self.db_client.users.find_one({"email": user_data["email"]}):
            raise HTTPException(status_code=400, detail="Email already exists")

        # åŠ å¯†å¯†ç 
        hashed_password = bcrypt.hashpw(
            user_data["password"].encode('utf-8'),
            bcrypt.gensalt()
        )

        # åˆ›å»ºç”¨æˆ·
        user = {
            "username": user_data["username"],
            "email": user_data["email"],
            "password": hashed_password,
            "full_name": user_data["full_name"],
            "bio": user_data.get("bio"),
            "avatar_url": user_data.get("avatar_url"),
            "created_at": datetime.utcnow()
        }

        result = await self.db_client.users.insert_one(user)
        user_id = str(result.inserted_id)

        # ç¼“å­˜ç”¨æˆ·ä¿¡æ¯
        await self.redis_client.set(f"user:{user_id}", json.dumps(user, default=str))

        return UserResponse(id=user_id, **user)

    async def authenticate_user(self, username: str, password: str) -> str:
        """ç”¨æˆ·è®¤è¯"""
        user = await self.db_client.users.find_one({"username": username})
        if not user or not bcrypt.checkpw(password.encode('utf-8'), user["password"]):
            raise HTTPException(status_code=401, detail="Invalid credentials")

        # ç”ŸæˆJWT token
        token = jwt.encode({
            "user_id": str(user["_id"]),
            "exp": datetime.utcnow() + timedelta(days=7)
        }, self.jwt_secret, algorithm="HS256")

        return token

    async def get_user(self, user_id: str) -> Optional[UserResponse]:
        """è·å–ç”¨æˆ·ä¿¡æ¯"""
        # å…ˆä»ç¼“å­˜è·å–
        cached_user = await self.redis_client.get(f"user:{user_id}")
        if cached_user:
            user_data = json.loads(cached_user)
            return UserResponse(id=user_id, **user_data)

        # ä»æ•°æ®åº“è·å–
        user = await self.db_client.users.find_one({"_id": ObjectId(user_id)})
        if user:
            user_data = {
                "username": user["username"],
                "email": user["email"],
                "full_name": user["full_name"],
                "bio": user.get("bio"),
                "avatar_url": user.get("avatar_url"),
                "created_at": user["created_at"]
            }
            # ç¼“å­˜ç”¨æˆ·ä¿¡æ¯
            await self.redis_client.set(f"user:{user_id}", json.dumps(user_data, default=str))
            return UserResponse(id=user_id, **user_data)

        return None

# APIç«¯ç‚¹
@app.post("/register", response_model=UserResponse)
async def register(user_data: dict):
    """ç”¨æˆ·æ³¨å†Œ"""
    return await user_service.register_user(user_data)

@app.post("/login")
async def login(username: str, password: str):
    """ç”¨æˆ·ç™»å½•"""
    token = await user_service.authenticate_user(username, password)
    return {"access_token": token}

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: str):
    """è·å–ç”¨æˆ·ä¿¡æ¯"""
    user = await user_service.get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

#### 2. æ¨æ–‡æœåŠ¡ (Tweet Service)
- **èŒè´£**ï¼šæ¨æ–‡å‘å¸ƒã€ç¼–è¾‘ã€åˆ é™¤ã€æŸ¥è¯¢
- **æ•°æ®æ¨¡å‹**ï¼šæ¨æ–‡å†…å®¹ã€åª’ä½“æ–‡ä»¶ã€ç»Ÿè®¡ä¿¡æ¯
- **APIæ¥å£**ï¼š
  - `POST /api/tweets` - å‘å¸ƒæ¨æ–‡
  - `GET /api/tweets/{id}` - è·å–æ¨æ–‡
  - `PUT /api/tweets/{id}` - ç¼–è¾‘æ¨æ–‡
  - `DELETE /api/tweets/{id}` - åˆ é™¤æ¨æ–‡

```python
# æ¨æ–‡æœåŠ¡æ ¸å¿ƒä»£ç 
from fastapi import FastAPI, HTTPException, File, UploadFile
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
import json
import aiofiles

app = FastAPI()

class Tweet(BaseModel):
    id: Optional[str] = None
    user_id: str
    content: str
    media_urls: List[str] = []
    reply_to_id: Optional[str] = None
    retweet_id: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

class TweetResponse(BaseModel):
    id: str
    user_id: str
    content: str
    media_urls: List[str]
    reply_to_id: Optional[str]
    retweet_id: Optional[str]
    created_at: datetime
    updated_at: datetime
    likes_count: int
    retweets_count: int
    replies_count: int

class TweetService:
    def __init__(self, db_client, redis_client, storage_client, kafka_producer):
        self.db_client = db_client
        self.redis_client = redis_client
        self.storage_client = storage_client
        self.kafka_producer = kafka_producer

    async def create_tweet(self, user_id: str, tweet_data: dict) -> TweetResponse:
        """åˆ›å»ºæ¨æ–‡"""
        tweet = {
            "user_id": user_id,
            "content": tweet_data["content"],
            "media_urls": tweet_data.get("media_urls", []),
            "reply_to_id": tweet_data.get("reply_to_id"),
            "retweet_id": tweet_data.get("retweet_id"),
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "likes_count": 0,
            "retweets_count": 0,
            "replies_count": 0
        }

        result = await self.db_client.tweets.insert_one(tweet)
        tweet_id = str(result.inserted_id)

        # ç¼“å­˜æ¨æ–‡
        await self.redis_client.set(f"tweet:{tweet_id}", json.dumps(tweet, default=str))

        # å‘å¸ƒæ¨æ–‡åˆ›å»ºäº‹ä»¶
        await self.kafka_producer.send("tweet_events", {
            "event_type": "tweet_created",
            "tweet_id": tweet_id,
            "user_id": user_id
        })

        return TweetResponse(id=tweet_id, **tweet)

    async def get_tweet(self, tweet_id: str) -> Optional[TweetResponse]:
        """è·å–æ¨æ–‡"""
        # å…ˆä»ç¼“å­˜è·å–
        cached_tweet = await self.redis_client.get(f"tweet:{tweet_id}")
        if cached_tweet:
            tweet_data = json.loads(cached_tweet)
            return TweetResponse(id=tweet_id, **tweet_data)

        # ä»æ•°æ®åº“è·å–
        tweet = await self.db_client.tweets.find_one({"_id": ObjectId(tweet_id)})
        if tweet:
            tweet_data = {
                "user_id": str(tweet["user_id"]),
                "content": tweet["content"],
                "media_urls": tweet["media_urls"],
                "reply_to_id": str(tweet["reply_to_id"]) if tweet["reply_to_id"] else None,
                "retweet_id": str(tweet["retweet_id"]) if tweet["retweet_id"] else None,
                "created_at": tweet["created_at"],
                "updated_at": tweet["updated_at"],
                "likes_count": tweet["likes_count"],
                "retweets_count": tweet["retweets_count"],
                "replies_count": tweet["replies_count"]
            }
            # ç¼“å­˜æ¨æ–‡
            await self.redis_client.set(f"tweet:{tweet_id}", json.dumps(tweet_data, default=str))
            return TweetResponse(id=tweet_id, **tweet_data)

        return None

    async def upload_media(self, user_id: str, file: UploadFile) -> str:
        """ä¸Šä¼ åª’ä½“æ–‡ä»¶"""
        # ç”Ÿæˆæ–‡ä»¶å
        file_extension = file.filename.split('.')[-1]
        filename = f"{user_id}_{datetime.utcnow().timestamp()}.{file_extension}"

        # ä¸Šä¼ åˆ°å¯¹è±¡å­˜å‚¨
        file_path = f"media/{filename}"
        async with aiofiles.open(f"/tmp/{filename}", 'wb') as f:
            content = await file.read()
            await f.write(content)

        await self.storage_client.upload_file(f"/tmp/{filename}", file_path)

        return f"https://cdn.example.com/{file_path}"

    async def get_timeline(self, user_id: str, limit: int = 20, offset: int = 0) -> List[TweetResponse]:
        """è·å–ç”¨æˆ·æ—¶é—´çº¿"""
        # è·å–ç”¨æˆ·å…³æ³¨çš„äºº
        following = await self.db_client.follows.find(
            {"follower_id": ObjectId(user_id)}
        ).to_list(length=1000)

        following_ids = [str(f["following_id"]) for f in following]

        # è·å–æ¨æ–‡
        tweets = await self.db_client.tweets.find({
            "user_id": {"$in": [ObjectId(uid) for uid in following_ids]}
        }).sort("created_at", -1).skip(offset).limit(limit).to_list(length=limit)

        return [
            TweetResponse(
                id=str(tweet["_id"]),
                user_id=str(tweet["user_id"]),
                content=tweet["content"],
                media_urls=tweet["media_urls"],
                reply_to_id=str(tweet["reply_to_id"]) if tweet["reply_to_id"] else None,
                retweet_id=str(tweet["retweet_id"]) if tweet["retweet_id"] else None,
                created_at=tweet["created_at"],
                updated_at=tweet["updated_at"],
                likes_count=tweet["likes_count"],
                retweets_count=tweet["retweets_count"],
                replies_count=tweet["replies_count"]
            )
            for tweet in tweets
        ]

# APIç«¯ç‚¹
@app.post("/tweets", response_model=TweetResponse)
async def create_tweet(tweet_data: dict, current_user: dict = Depends(get_current_user)):
    """åˆ›å»ºæ¨æ–‡"""
    return await tweet_service.create_tweet(current_user["user_id"], tweet_data)

@app.get("/tweets/{tweet_id}", response_model=TweetResponse)
async def get_tweet(tweet_id: str):
    """è·å–æ¨æ–‡"""
    tweet = await tweet_service.get_tweet(tweet_id)
    if not tweet:
        raise HTTPException(status_code=404, detail="Tweet not found")
    return tweet

@app.post("/tweets/{tweet_id}/media")
async def upload_tweet_media(tweet_id: str, file: UploadFile = File(...)):
    """ä¸Šä¼ æ¨æ–‡åª’ä½“æ–‡ä»¶"""
    # éªŒè¯æ¨æ–‡æ˜¯å¦å­˜åœ¨
    tweet = await tweet_service.get_tweet(tweet_id)
    if not tweet:
        raise HTTPException(status_code=404, detail="Tweet not found")

    # ä¸Šä¼ åª’ä½“æ–‡ä»¶
    media_url = await tweet_service.upload_media(tweet.user_id, file)

    # æ›´æ–°æ¨æ–‡
    await tweet_service.update_tweet_media(tweet_id, media_url)

    return {"media_url": media_url}

@app.get("/timeline", response_model=List[TweetResponse])
async def get_timeline(
    limit: int = 20,
    offset: int = 0,
    current_user: dict = Depends(get_current_user)
):
    """è·å–ç”¨æˆ·æ—¶é—´çº¿"""
    return await tweet_service.get_timeline(current_user["user_id"], limit, offset)
```

#### 3. å…³ç³»æœåŠ¡ (Relationship Service)
- **èŒè´£**ï¼šç”¨æˆ·å…³æ³¨/å–æ¶ˆå…³æ³¨ã€å¥½å‹å…³ç³»ç®¡ç†
- **æ•°æ®æ¨¡å‹**ï¼šå…³æ³¨å…³ç³»ã€å¥½å‹å…³ç³»ã€æ‹‰é»‘å…³ç³»
- **APIæ¥å£**ï¼š
  - `POST /api/follow/{user_id}` - å…³æ³¨ç”¨æˆ·
  - `DELETE /api/follow/{user_id}` - å–æ¶ˆå…³æ³¨
  - `GET /api/followers/{user_id}` - è·å–ç²‰ä¸åˆ—è¡¨
  - `GET /api/following/{user_id}` - è·å–å…³æ³¨åˆ—è¡¨

```python
# å…³ç³»æœåŠ¡æ ¸å¿ƒä»£ç 
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List
from datetime import datetime

app = FastAPI()

class Follow(BaseModel):
    follower_id: str
    following_id: str
    created_at: datetime

class RelationshipService:
    def __init__(self, db_client, redis_client):
        self.db_client = db_client
        self.redis_client = redis_client

    async def follow_user(self, follower_id: str, following_id: str) -> bool:
        """å…³æ³¨ç”¨æˆ·"""
        # æ£€æŸ¥æ˜¯å¦å·²ç»å…³æ³¨
        existing_follow = await self.db_client.follows.find_one({
            "follower_id": ObjectId(follower_id),
            "following_id": ObjectId(following_id)
        })

        if existing_follow:
            raise HTTPException(status_code=400, detail="Already following")

        # åˆ›å»ºå…³æ³¨å…³ç³»
        follow = {
            "follower_id": ObjectId(follower_id),
            "following_id": ObjectId(following_id),
            "created_at": datetime.utcnow()
        }

        await self.db_client.follows.insert_one(follow)

        # æ›´æ–°ç¼“å­˜
        await self.redis_client.sadd(f"following:{follower_id}", following_id)
        await self.redis_client.sadd(f"followers:{following_id}", follower_id)

        return True

    async def unfollow_user(self, follower_id: str, following_id: str) -> bool:
        """å–æ¶ˆå…³æ³¨"""
        # åˆ é™¤å…³æ³¨å…³ç³»
        result = await self.db_client.follows.delete_one({
            "follower_id": ObjectId(follower_id),
            "following_id": ObjectId(following_id)
        })

        if result.deleted_count == 0:
            raise HTTPException(status_code=404, detail="Not following")

        # æ›´æ–°ç¼“å­˜
        await self.redis_client.srem(f"following:{follower_id}", following_id)
        await self.redis_client.srem(f"followers:{following_id}", follower_id)

        return True

    async def get_followers(self, user_id: str, limit: int = 20) -> List[str]:
        """è·å–ç²‰ä¸åˆ—è¡¨"""
        # å…ˆä»ç¼“å­˜è·å–
        cached_followers = await self.redis_client.smembers(f"followers:{user_id}")
        if cached_followers:
            return list(cached_followers)[:limit]

        # ä»æ•°æ®åº“è·å–
        follows = await self.db_client.follows.find({
            "following_id": ObjectId(user_id)
        }).limit(limit).to_list(length=limit)

        followers = [str(f["follower_id"]) for f in follows]

        # ç¼“å­˜ç»“æœ
        for follower_id in followers:
            await self.redis_client.sadd(f"followers:{user_id}", follower_id)

        return followers

    async def get_following(self, user_id: str, limit: int = 20) -> List[str]:
        """è·å–å…³æ³¨åˆ—è¡¨"""
        # å…ˆä»ç¼“å­˜è·å–
        cached_following = await self.redis_client.smembers(f"following:{user_id}")
        if cached_following:
            return list(cached_following)[:limit]

        # ä»æ•°æ®åº“è·å–
        follows = await self.db_client.follows.find({
            "follower_id": ObjectId(user_id)
        }).limit(limit).to_list(length=limit)

        following = [str(f["following_id"]) for f in follows]

        # ç¼“å­˜ç»“æœ
        for following_id in following:
            await self.redis_client.sadd(f"following:{user_id}", following_id)

        return following

    async def get_follow_counts(self, user_id: str) -> dict:
        """è·å–å…³æ³¨ç»Ÿè®¡"""
        followers_count = await self.redis_client.scard(f"followers:{user_id}")
        following_count = await self.redis_client.scard(f"following:{user_id}")

        return {
            "followers_count": followers_count,
            "following_count": following_count
        }

# APIç«¯ç‚¹
@app.post("/follow/{user_id}")
async def follow_user(
    user_id: str,
    current_user: dict = Depends(get_current_user)
):
    """å…³æ³¨ç”¨æˆ·"""
    await relationship_service.follow_user(current_user["user_id"], user_id)
    return {"message": "Successfully followed user"}

@app.delete("/follow/{user_id}")
async def unfollow_user(
    user_id: str,
    current_user: dict = Depends(get_current_user)
):
    """å–æ¶ˆå…³æ³¨"""
    await relationship_service.unfollow_user(current_user["user_id"], user_id)
    return {"message": "Successfully unfollowed user"}

@app.get("/followers/{user_id}")
async def get_followers(user_id: str, limit: int = 20):
    """è·å–ç²‰ä¸åˆ—è¡¨"""
    return await relationship_service.get_followers(user_id, limit)

@app.get("/following/{user_id}")
async def get_following(user_id: str, limit: int = 20):
    """è·å–å…³æ³¨åˆ—è¡¨"""
    return await relationship_service.get_following(user_id, limit)

@app.get("/follow-stats/{user_id}")
async def get_follow_stats(user_id: str):
    """è·å–å…³æ³¨ç»Ÿè®¡"""
    return await relationship_service.get_follow_counts(user_id)
```

### æ•°æ®å­˜å‚¨è®¾è®¡

#### 1. æ•°æ®åº“è®¾è®¡

```python
# ç”¨æˆ·è¡¨ç»“æ„
class UserCollection:
    """ç”¨æˆ·é›†åˆ"""
    schema = {
        "username": "string",           # ç”¨æˆ·å
        "email": "string",             # é‚®ç®±
        "password": "string",           # å¯†ç å“ˆå¸Œ
        "full_name": "string",          # å…¨å
        "bio": "string?",              # ä¸ªäººç®€ä»‹
        "avatar_url": "string?",       # å¤´åƒURL
        "location": "string?",         # ä½ç½®
        "website": "string?",          # ç½‘ç«™
        "birth_date": "date?",         # å‡ºç”Ÿæ—¥æœŸ
        "created_at": "datetime",       # åˆ›å»ºæ—¶é—´
        "updated_at": "datetime"        # æ›´æ–°æ—¶é—´
    }

# æ¨æ–‡è¡¨ç»“æ„
class TweetCollection:
    """æ¨æ–‡é›†åˆ"""
    schema = {
        "user_id": "ObjectId",         # ç”¨æˆ·ID
        "content": "string",           # æ¨æ–‡å†…å®¹
        "media_urls": "array",         # åª’ä½“æ–‡ä»¶URLåˆ—è¡¨
        "reply_to_id": "ObjectId?",    # å›å¤çš„æ¨æ–‡ID
        "retweet_id": "ObjectId?",     # è½¬å‘çš„æ¨æ–‡ID
        "likes_count": "int",          # ç‚¹èµæ•°
        "retweets_count": "int",       # è½¬å‘æ•°
        "replies_count": "int",        # å›å¤æ•°
        "created_at": "datetime",      # åˆ›å»ºæ—¶é—´
        "updated_at": "datetime"       # æ›´æ–°æ—¶é—´
    }

# å…³æ³¨å…³ç³»è¡¨ç»“æ„
class FollowCollection:
    """å…³æ³¨å…³ç³»é›†åˆ"""
    schema = {
        "follower_id": "ObjectId",     # å…³æ³¨è€…ID
        "following_id": "ObjectId",    # è¢«å…³æ³¨è€…ID
        "created_at": "datetime"       # åˆ›å»ºæ—¶é—´
    }

# ç‚¹èµè¡¨ç»“æ„
class LikeCollection:
    """ç‚¹èµé›†åˆ"""
    schema = {
        "user_id": "ObjectId",         # ç”¨æˆ·ID
        "tweet_id": "ObjectId",        # æ¨æ–‡ID
        "created_at": "datetime"       # åˆ›å»ºæ—¶é—´
    }
```

#### 2. ç¼“å­˜è®¾è®¡

```python
# Redisç¼“å­˜è®¾è®¡
class CacheKeys:
    """ç¼“å­˜é”®è®¾è®¡"""
    # ç”¨æˆ·ç›¸å…³
    USER_PROFILE = "user:{user_id}"                    # ç”¨æˆ·ä¿¡æ¯
    USER_SESSION = "session:{session_id}"            # ç”¨æˆ·ä¼šè¯
    USER_FOLLOWING = "following:{user_id}"            # å…³æ³¨åˆ—è¡¨
    USER_FOLLOWERS = "followers:{user_id}"            # ç²‰ä¸åˆ—è¡¨
    USER_TWEETS = "user_tweets:{user_id}"             # ç”¨æˆ·æ¨æ–‡åˆ—è¡¨

    # æ¨æ–‡ç›¸å…³
    TWEET_DATA = "tweet:{tweet_id}"                    # æ¨æ–‡ä¿¡æ¯
    TWEET_LIKES = "tweet_likes:{tweet_id}"            # æ¨æ–‡ç‚¹èµç”¨æˆ·
    TWEET_RETWEETS = "tweet_retweets:{tweet_id}"       # æ¨æ–‡è½¬å‘ç”¨æˆ·
    TWEET_REPLIES = "tweet_replies:{tweet_id}"        # æ¨æ–‡å›å¤åˆ—è¡¨

    # æ—¶é—´çº¿ç›¸å…³
    TIMELINE = "timeline:{user_id}"                    # ç”¨æˆ·æ—¶é—´çº¿
    TRENDING = "trending"                             # çƒ­é—¨è¯é¢˜
    TRENDING_TOPICS = "trending_topics"               # çƒ­é—¨è¯é¢˜åˆ—è¡¨

    # ç»Ÿè®¡ç›¸å…³
    USER_STATS = "user_stats:{user_id}"               # ç”¨æˆ·ç»Ÿè®¡
    TWEET_STATS = "tweet_stats:{tweet_id}"            # æ¨æ–‡ç»Ÿè®¡
    DAILY_STATS = "daily_stats:{date}"               # æ—¥ç»Ÿè®¡

# ç¼“å­˜ç­–ç•¥
class CacheStrategy:
    """ç¼“å­˜ç­–ç•¥"""
    def __init__(self, redis_client):
        self.redis_client = redis_client

    async def cache_user_profile(self, user_id: str, user_data: dict):
        """ç¼“å­˜ç”¨æˆ·ä¿¡æ¯"""
        await self.redis_client.setex(
            f"user:{user_id}",
            3600,  # 1å°æ—¶è¿‡æœŸ
            json.dumps(user_data, default=str)
        )

    async def cache_tweet_data(self, tweet_id: str, tweet_data: dict):
        """ç¼“å­˜æ¨æ–‡ä¿¡æ¯"""
        await self.redis_client.setex(
            f"tweet:{tweet_id}",
            1800,  # 30åˆ†é’Ÿè¿‡æœŸ
            json.dumps(tweet_data, default=str)
        )

    async def cache_timeline(self, user_id: str, tweets: list):
        """ç¼“å­˜ç”¨æˆ·æ—¶é—´çº¿"""
        await self.redis_client.setex(
            f"timeline:{user_id}",
            300,  # 5åˆ†é’Ÿè¿‡æœŸ
            json.dumps(tweets, default=str)
        )

    async def increment_tweet_stats(self, tweet_id: str, stat_type: str):
        """å¢åŠ æ¨æ–‡ç»Ÿè®¡"""
        await self.redis_client.hincrby(
            f"tweet_stats:{tweet_id}",
            stat_type,
            1
        )
```

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. æ•°æ®åº“ä¼˜åŒ–

```python
# æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
class DatabaseIndexes:
    """æ•°æ®åº“ç´¢å¼•è®¾è®¡"""
    indexes = {
        "users": [
            {"username": 1},           # ç”¨æˆ·åå”¯ä¸€ç´¢å¼•
            {"email": 1},              # é‚®ç®±å”¯ä¸€ç´¢å¼•
            {"created_at": -1}         # åˆ›å»ºæ—¶é—´ç´¢å¼•
        ],
        "tweets": [
            {"user_id": 1, "created_at": -1},  # ç”¨æˆ·æ¨æ–‡æ—¶é—´çº¿ç´¢å¼•
            {"created_at": -1},                # å…¨å±€æ¨æ–‡æ—¶é—´çº¿ç´¢å¼•
            {"reply_to_id": 1},               # å›å¤å…³ç³»ç´¢å¼•
            {"retweet_id": 1}                 # è½¬å‘å…³ç³»ç´¢å¼•
        ],
        "follows": [
            {"follower_id": 1, "following_id": 1},  # å…³æ³¨å…³ç³»å¤åˆç´¢å¼•
            {"following_id": 1},                     # è¢«å…³æ³¨è€…ç´¢å¼•
            {"created_at": -1}                      # åˆ›å»ºæ—¶é—´ç´¢å¼•
        ],
        "likes": [
            {"user_id": 1, "tweet_id": 1},          # ç”¨æˆ·ç‚¹èµç´¢å¼•
            {"tweet_id": 1, "created_at": -1}       # æ¨æ–‡ç‚¹èµæ—¶é—´ç´¢å¼•
        ]
    }

# åˆ†ç‰‡ç­–ç•¥
class ShardingStrategy:
    """æ•°æ®åˆ†ç‰‡ç­–ç•¥"""
    def __init__(self):
        self.shard_count = 10

    def get_user_shard(self, user_id: str) -> int:
        """è·å–ç”¨æˆ·æ‰€åœ¨åˆ†ç‰‡"""
        return hash(user_id) % self.shard_count

    def get_tweet_shard(self, tweet_id: str) -> int:
        """è·å–æ¨æ–‡æ‰€åœ¨åˆ†ç‰‡"""
        return hash(tweet_id) % self.shard_count

    def get_shard_name(self, shard_id: int) -> str:
        """è·å–åˆ†ç‰‡åç§°"""
        return f"shard_{shard_id}"
```

#### 2. ç¼“å­˜ä¼˜åŒ–

```python
# å¤šçº§ç¼“å­˜
class MultiLevelCache:
    """å¤šçº§ç¼“å­˜å®ç°"""
    def __init__(self, redis_client, local_cache):
        self.redis_client = redis_client
        self.local_cache = local_cache

    async def get(self, key: str):
        """è·å–ç¼“å­˜æ•°æ®"""
        # å…ˆä»æœ¬åœ°ç¼“å­˜è·å–
        value = self.local_cache.get(key)
        if value is not None:
            return value

        # ä»Redisè·å–
        value = await self.redis_client.get(key)
        if value is not None:
            # ç¼“å­˜åˆ°æœ¬åœ°
            self.local_cache.set(key, value, timeout=60)
            return json.loads(value)

        return None

    async def set(self, key: str, value: dict, ttl: int = 3600):
        """è®¾ç½®ç¼“å­˜æ•°æ®"""
        # è®¾ç½®æœ¬åœ°ç¼“å­˜
        self.local_cache.set(key, json.dumps(value), timeout=60)

        # è®¾ç½®Redisç¼“å­˜
        await self.redis_client.setex(key, ttl, json.dumps(value))

# ç¼“å­˜é¢„çƒ­
class CacheWarmup:
    """ç¼“å­˜é¢„çƒ­ç­–ç•¥"""
    def __init__(self, db_client, cache_client):
        self.db_client = db_client
        self.cache_client = cache_client

    async def warmup_user_cache(self, user_id: str):
        """é¢„çƒ­ç”¨æˆ·ç¼“å­˜"""
        # è·å–ç”¨æˆ·ä¿¡æ¯
        user = await self.db_client.users.find_one({"_id": ObjectId(user_id)})
        if user:
            await self.cache_client.cache_user_profile(user_id, user)

        # è·å–ç”¨æˆ·ç»Ÿè®¡
        stats = await self.get_user_stats(user_id)
        await self.cache_client.set(f"user_stats:{user_id}", stats)

    async def warmup_tweet_cache(self, tweet_id: str):
        """é¢„çƒ­æ¨æ–‡ç¼“å­˜"""
        # è·å–æ¨æ–‡ä¿¡æ¯
        tweet = await self.db_client.tweets.find_one({"_id": ObjectId(tweet_id)})
        if tweet:
            await self.cache_client.cache_tweet_data(tweet_id, tweet)

    async def warmup_timeline_cache(self, user_id: str):
        """é¢„çƒ­æ—¶é—´çº¿ç¼“å­˜"""
        # è·å–ç”¨æˆ·æ—¶é—´çº¿
        timeline = await self.get_user_timeline(user_id)
        await self.cache_client.cache_timeline(user_id, timeline)
```

### å®‰å…¨è®¾è®¡

#### 1. è®¤è¯æˆæƒ

```python
# JWTè®¤è¯
class JWTAuth:
    """JWTè®¤è¯å®ç°"""
    def __init__(self, secret_key: str):
        self.secret_key = secret_key

    def create_token(self, user_id: str, expires_in: int = 3600) -> str:
        """åˆ›å»ºJWT token"""
        payload = {
            "user_id": user_id,
            "exp": datetime.utcnow() + timedelta(seconds=expires_in),
            "iat": datetime.utcnow()
        }
        return jwt.encode(payload, self.secret_key, algorithm="HS256")

    def verify_token(self, token: str) -> dict:
        """éªŒè¯JWT token"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Invalid token")

# APIæƒé™æ§åˆ¶
class PermissionManager:
    """æƒé™ç®¡ç†å™¨"""
    def __init__(self):
        self.permissions = {
            "user": ["read_profile", "create_tweet", "like_tweet"],
            "admin": ["user_management", "content_moderation", "analytics"],
            "moderator": ["content_moderation", "user_suspend"]
        }

    def check_permission(self, user_role: str, permission: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æƒé™"""
        return permission in self.permissions.get(user_role, [])

    def require_permission(self, permission: str):
        """æƒé™è£…é¥°å™¨"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                current_user = kwargs.get("current_user")
                if not current_user:
                    raise HTTPException(status_code=401, detail="Authentication required")

                if not self.check_permission(current_user["role"], permission):
                    raise HTTPException(status_code=403, detail="Insufficient permissions")

                return await func(*args, **kwargs)
            return wrapper
        return decorator
```

#### 2. æ•°æ®å®‰å…¨

```python
# æ•°æ®åŠ å¯†
class DataEncryption:
    """æ•°æ®åŠ å¯†æœåŠ¡"""
    def __init__(self, encryption_key: str):
        self.encryption_key = encryption_key
        self.cipher_suite = Fernet(encryption_key.encode())

    def encrypt_sensitive_data(self, data: str) -> str:
        """åŠ å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher_suite.encrypt(data.encode()).decode()

    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()

# å†…å®¹å®¡æ ¸
class ContentModeration:
    """å†…å®¹å®¡æ ¸æœåŠ¡"""
    def __init__(self):
        self.banned_words = self.load_banned_words()
        self.spam_patterns = self.load_spam_patterns()

    async def moderate_content(self, content: str) -> dict:
        """å®¡æ ¸å†…å®¹"""
        issues = []

        # æ£€æŸ¥æ•æ„Ÿè¯
        for word in self.banned_words:
            if word.lower() in content.lower():
                issues.append({
                    "type": "banned_word",
                    "word": word,
                    "severity": "high"
                })

        # æ£€æŸ¥åƒåœ¾å†…å®¹æ¨¡å¼
        for pattern in self.spam_patterns:
            if pattern.match(content):
                issues.append({
                    "type": "spam_pattern",
                    "pattern": pattern.pattern,
                    "severity": "medium"
                })

        # æ£€æŸ¥å†…å®¹é•¿åº¦
        if len(content) > 280:
            issues.append({
                "type": "length_limit",
                "max_length": 280,
                "actual_length": len(content),
                "severity": "low"
            })

        return {
            "is_approved": len(issues) == 0,
            "issues": issues,
            "confidence": self.calculate_confidence(issues)
        }

    def calculate_confidence(self, issues: list) -> float:
        """è®¡ç®—å®¡æ ¸ç½®ä¿¡åº¦"""
        if not issues:
            return 1.0

        severity_weights = {"high": 0.8, "medium": 0.5, "low": 0.2}
        total_weight = sum(severity_weights.get(issue["severity"], 0.1) for issue in issues)

        return max(0.0, 1.0 - total_weight)
```

### ç›‘æ§å’Œå‘Šè­¦

#### 1. æ€§èƒ½ç›‘æ§

```python
# æ€§èƒ½æŒ‡æ ‡æ”¶é›†
class MetricsCollector:
    """æ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨"""
    def __init__(self):
        self.metrics = defaultdict(list)
        self.lock = threading.Lock()

    def record_request_time(self, endpoint: str, duration: float):
        """è®°å½•è¯·æ±‚æ—¶é—´"""
        with self.lock:
            self.metrics[f"request_time_{endpoint}"].append(duration)

    def record_error_count(self, endpoint: str, error_type: str):
        """è®°å½•é”™è¯¯æ•°é‡"""
        with self.lock:
            self.metrics[f"error_count_{endpoint}_{error_type}"].append(1)

    def get_metrics_summary(self, endpoint: str) -> dict:
        """è·å–æŒ‡æ ‡æ‘˜è¦"""
        request_times = self.metrics.get(f"request_time_{endpoint}", [])
        if not request_times:
            return {}

        return {
            "avg_request_time": sum(request_times) / len(request_times),
            "max_request_time": max(request_times),
            "min_request_time": min(request_times),
            "p95_request_time": sorted(request_times)[int(len(request_times) * 0.95)],
            "total_requests": len(request_times)
        }

# å¥åº·æ£€æŸ¥
class HealthChecker:
    """å¥åº·æ£€æŸ¥æœåŠ¡"""
    def __init__(self):
        self.services = {
            "user_service": "http://user-service:8001/health",
            "tweet_service": "http://tweet-service:8002/health",
            "relationship_service": "http://relationship-service:8003/health",
            "notification_service": "http://notification-service:8004/health",
            "redis": "redis://localhost:6379",
            "mongodb": "mongodb://localhost:27017"
        }

    async def check_health(self) -> dict:
        """æ£€æŸ¥æ‰€æœ‰æœåŠ¡å¥åº·çŠ¶æ€"""
        results = {}

        for service_name, endpoint in self.services.items():
            try:
                if service_name == "redis":
                    await self.check_redis_health(endpoint)
                    results[service_name] = {"status": "healthy"}
                elif service_name == "mongodb":
                    await self.check_mongodb_health(endpoint)
                    results[service_name] = {"status": "healthy"}
                else:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(endpoint, timeout=5) as response:
                            if response.status == 200:
                                results[service_name] = {"status": "healthy"}
                            else:
                                results[service_name] = {"status": "unhealthy"}
            except Exception as e:
                results[service_name] = {"status": "unhealthy", "error": str(e)}

        return results
```

#### 2. å‘Šè­¦ç³»ç»Ÿ

```python
# å‘Šè­¦è§„åˆ™
class AlertRule:
    """å‘Šè­¦è§„åˆ™"""
    def __init__(self, name: str, condition: callable, severity: str):
        self.name = name
        self.condition = condition
        self.severity = severity

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""
    def __init__(self):
        self.rules = self.create_alert_rules()
        self.alert_history = []
        self.notification_channels = []

    def create_alert_rules(self) -> List[AlertRule]:
        """åˆ›å»ºå‘Šè­¦è§„åˆ™"""
        return [
            AlertRule(
                "high_error_rate",
                lambda metrics: metrics.get("error_rate", 0) > 0.05,
                "high"
            ),
            AlertRule(
                "slow_response_time",
                lambda metrics: metrics.get("avg_response_time", 0) > 1000,
                "medium"
            ),
            AlertRule(
                "low_availability",
                lambda metrics: metrics.get("availability", 1.0) < 0.99,
                "critical"
            ),
            AlertRule(
                "high_memory_usage",
                lambda metrics: metrics.get("memory_usage", 0) > 0.8,
                "medium"
            )
        ]

    def check_alerts(self, metrics: dict) -> List[dict]:
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        alerts = []
        for rule in self.rules:
            if rule.condition(metrics):
                alert = {
                    "rule_name": rule.name,
                    "severity": rule.severity,
                    "metrics": metrics,
                    "timestamp": datetime.utcnow().isoformat()
                }
                alerts.append(alert)
                self.alert_history.append(alert)

                # å‘é€å‘Šè­¦é€šçŸ¥
                self.send_alert_notification(alert)

        return alerts

    def send_alert_notification(self, alert: dict):
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        message = f"ğŸš¨ Alert: {alert['rule_name']} (Severity: {alert['severity']})"

        # å‘é€åˆ°ä¸åŒçš„é€šçŸ¥æ¸ é“
        for channel in self.notification_channels:
            try:
                channel.send(message, alert)
            except Exception as e:
                print(f"Failed to send alert to {channel}: {e}")
```

## éƒ¨ç½²å’Œè¿ç»´

### 1. å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
# Dockerfileç¤ºä¾‹
FROM python:3.9-slim

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY requirements.txt .
RUN pip install -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "8001:8000"
    environment:
      - DATABASE_URL=mongodb://mongodb:27017
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mongodb
      - redis

  tweet-service:
    build: ./tweet-service
    ports:
      - "8002:8000"
    environment:
      - DATABASE_URL=mongodb://mongodb:27017
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mongodb
      - redis

  relationship-service:
    build: ./relationship-service
    ports:
      - "8003:8000"
    environment:
      - DATABASE_URL=mongodb://mongodb:27017
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mongodb
      - redis

  api-gateway:
    build: ./api-gateway
    ports:
      - "8000:8000"
    environment:
      - USER_SERVICE_URL=http://user-service:8000
      - TWEET_SERVICE_URL=http://tweet-service:8000
      - RELATIONSHIP_SERVICE_URL=http://relationship-service:8000
    depends_on:
      - user-service
      - tweet-service
      - relationship-service

  mongodb:
    image: mongo:5.0
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mongodb_data:
  redis_data:
```

### 2. Kuberneteséƒ¨ç½²

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: your-registry/user-service:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          value: "mongodb://mongodb-service:27017"
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
```

### 3. CI/CDæµæ°´çº¿

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio

    - name: Run tests
      run: |
        pytest tests/ -v

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push
      uses: docker/build-push-action@v4
      with:
        push: true
        tags: your-registry/social-media-app:latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3

    - name: Set up Kubernetes
      uses: azure/setup-kubectl@v3

    - name: Deploy to Kubernetes
      run: |
        kubectl apply -f k8s/
```

## æ€»ç»“

è¿™ä¸ªç¤¾äº¤åª’ä½“ç³»ç»Ÿè®¾è®¡æ¡ˆä¾‹ç»¼åˆåº”ç”¨äº†å‰å‡ å‘¨å­¦ä¹ çš„ç³»ç»Ÿè®¾è®¡çŸ¥è¯†ï¼š

1. **ç³»ç»Ÿè®¾è®¡æ€ç»´**ï¼šåº”ç”¨äº†æŠ½è±¡åŒ–ã€æ¨¡å—åŒ–ã€åˆ†å±‚è®¾è®¡ç­‰æ€ç»´æ¨¡å¼
2. **è®¾è®¡æ¨¡å¼**ï¼šä½¿ç”¨äº†å·¥å‚æ¨¡å¼ã€ç­–ç•¥æ¨¡å¼ã€è§‚å¯Ÿè€…æ¨¡å¼ç­‰å¤šç§è®¾è®¡æ¨¡å¼
3. **å¾®æœåŠ¡æ¶æ„**ï¼šè®¾è®¡äº†å®Œæ•´çš„å¾®æœåŠ¡æ¶æ„ï¼ŒåŒ…å«æœåŠ¡æ‹†åˆ†ã€é€šä¿¡ã€å‘ç°ç­‰
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå®ç°äº†å¤šçº§ç¼“å­˜ã€æ•°æ®åº“ä¼˜åŒ–ã€è´Ÿè½½å‡è¡¡ç­‰æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
5. **å®¹é”™è®¾è®¡**ï¼šåº”ç”¨äº†ç†”æ–­å™¨ã€é‡è¯•æœºåˆ¶ã€é™æµç­‰å®¹é”™æ¨¡å¼
6. **å®‰å…¨è®¾è®¡**ï¼šå®ç°äº†è®¤è¯æˆæƒã€æ•°æ®åŠ å¯†ã€å†…å®¹å®¡æ ¸ç­‰å®‰å…¨æœºåˆ¶

è¿™ä¸ªæ¡ˆä¾‹å±•ç¤ºäº†å¦‚ä½•å°†ç†è®ºçŸ¥è¯†åº”ç”¨åˆ°å®é™…çš„ç³»ç»Ÿè®¾è®¡ä¸­ï¼Œä¸ºè¯»è€…æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„å‚è€ƒå®ç°ã€‚

## æ‰©å±•ç»ƒä¹ 

1. **æ€§èƒ½ä¼˜åŒ–**ï¼šä¸ºç³»ç»Ÿæ·»åŠ æ›´å¤šçš„æ€§èƒ½ä¼˜åŒ–æªæ–½ï¼Œå¦‚æ•°æ®åº“è¯»å†™åˆ†ç¦»ã€CDNåŠ é€Ÿç­‰ã€‚

2. **åŠŸèƒ½æ‰©å±•**ï¼šæ·»åŠ ç›´æ’­åŠŸèƒ½ã€ç¾¤ç»„èŠå¤©ã€å•†ä¸šå¹¿å‘Šç­‰é«˜çº§åŠŸèƒ½ã€‚

3. **å›½é™…åŒ–**ï¼šæ”¯æŒå¤šè¯­è¨€ã€å¤šåœ°åŒºéƒ¨ç½²ï¼Œè€ƒè™‘æ—¶åŒºã€è´§å¸ç­‰æœ¬åœ°åŒ–éœ€æ±‚ã€‚

4. **æ•°æ®åˆ†æ**ï¼šæ„å»ºç”¨æˆ·è¡Œä¸ºåˆ†æç³»ç»Ÿï¼Œæä¾›ä¸ªæ€§åŒ–æ¨èå’Œå•†ä¸šæ™ºèƒ½ã€‚

---

**è®°ä½**ï¼šä¼˜ç§€çš„ç³»ç»Ÿè®¾è®¡éœ€è¦åœ¨ç†è®ºçŸ¥è¯†å’Œå®è·µç»éªŒä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼Œä¸æ–­è¿­ä»£ä¼˜åŒ–ï¼