---
title: "高阶函数与Lambda表达式深度解析"
description: "深入理解高阶函数、lambda表达式、函数组合和柯里化在算法设计中的应用"
category: "函数式编程"
tags: ["高阶函数", "Lambda表达式", "函数组合", "柯里化"]
difficulty: "中级"
---

# 高阶函数与Lambda表达式深度解析

## 概念概览

高阶函数和lambda表达式是函数式编程的核心工具，它们使得函数可以作为一等公民进行操作。本章深入探讨这些概念在算法设计中的高级应用，包括数学理论基础、性能优化策略和实际工程实践。

## Lambda表达式的深度理解

### Lambda表达式的数学基础

Lambda表达式基于λ演算（Lambda Calculus），这是由Alonzo Church在1930年代提出的形式系统。

#### λ演算的基本语法：

1. **变量**：$x, y, z, ...$
2. **抽象**：$\lambda x.M$ （函数定义）
3. **应用**：$(M N)$ （函数调用）

#### β归约规则：
$$(\lambda x.M) N \rightarrow M[x := N]$$

这意味着将函数应用到参数时，用参数替换函数体中的变量。

### Python中Lambda表达式的深度剖析

#### 1. 基本语法和限制

```python
# 基本Lambda表达式
add = lambda x, y: x + y
square = lambda x: x ** 2

# Lambda表达式的限制
# 只能包含单个表达式，不能包含语句
# 以下代码会报错：
# invalid_lambda = lambda x:
#     if x > 0:
#         return x
#     else:
#         return -x

# 正确的写法（使用条件表达式）
absolute = lambda x: x if x >= 0 else -x
```

#### 2. Lambda表达式的作用域和闭包

```python
def create_multiplier(factor):
    """
    创建乘法器函数的工厂函数

    闭包机制：lambda表达式捕获了外部作用域的factor变量
    """
    return lambda x: x * factor

# 创建不同的乘法器
double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))   # 10
print(triple(5))   # 15

# 演示闭包的陷阱
adders = []
for i in range(5):
    adders.append(lambda x: x + i)  # 捕获的是变量i的引用

print(adders[0](10))  # 14 (而不是预期的10)
print(adders[1](10))  # 14 (而不是预期的11)

# 解决方案：使用默认参数捕获值
adders_fixed = []
for i in range(5):
    adders_fixed.append(lambda x, i=i: x + i)  # 默认参数在定义时求值

print(adders_fixed[0](10))  # 10
print(adders_fixed[1](10))  # 11
```

#### 3. Lambda表达式的高级应用

```python
from functools import reduce
from typing import List, Callable, Any

# 1. 复杂的数据转换
transform_data = lambda data: [
    {'id': item['id'], 'processed': item['value'] * 2}
    for item in data
    if item.get('active', False)
]

# 2. 函数式数据处理管道
data_pipeline = lambda operations: lambda data: reduce(
    lambda acc, op: op(acc),
    operations,
    data
)

# 使用示例
operations = [
    lambda x: [item * 2 for item in x],
    lambda x: [item for item in x if item > 10],
    lambda x: sum(x)
]

process = data_pipeline(operations)
result = process([1, 2, 3, 4, 5, 6])
print(result)  # 12 + 14 + 16 + 18 + 20 + 22 = 102? 不对，应该是12+14+16+18+20+22=102
# 实际上：[2,4,6,8,10,12] -> [12,14,16,18,20,22] -> 12+14+16+18+20+22 = 102
```

## 高阶函数的深度应用

### 1. 函数作为参数的高级用法

#### 1.1 策略模式的高阶函数实现

```python
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from abc import ABC, abstractmethod

class SortStrategy(ABC):
    """排序策略的抽象基类"""

    @abstractmethod
    def sort(self, data: List[Any]) -> List[Any]:
        pass

class BubbleSort(SortStrategy):
    """冒泡排序策略"""

    def sort(self, data: List[Any]) -> List[Any]:
        data = data.copy()
        n = len(data)
        for i in range(n):
            for j in range(0, n - i - 1):
                if data[j] > data[j + 1]:
                    data[j], data[j + 1] = data[j + 1], data[j]
        return data

class QuickSort(SortStrategy):
    """快速排序策略"""

    def sort(self, data: List[Any]) -> List[Any]:
        if len(data) <= 1:
            return data

        pivot = data[0]
        left = [x for x in data[1:] if x <= pivot]
        right = [x for x in data[1:] if x > pivot]

        return self.sort(left) + [pivot] + self.sort(right)

# 高阶函数实现策略模式
def sort_with_strategy(data: List[Any], strategy: SortStrategy) -> List[Any]:
    """使用策略模式进行排序"""
    return strategy.sort(data)

# 函数式策略模式（更简洁）
def functional_sort(data: List[Any], sort_func: Callable[[List[Any]], List[Any]]) -> List[Any]:
    """函数式排序策略"""
    return sort_func(data)

# 各种排序函数
def bubble_sort_func(data: List[Any]) -> List[Any]:
    """冒泡排序函数"""
    data = data.copy()
    n = len(data)
    for i in range(n):
        for j in range(0, n - i - 1):
            if data[j] > data[j + 1]:
                data[j], data[j + 1] = data[j + 1], data[j]
    return data

def quick_sort_func(data: List[Any]) -> List[Any]:
    """快速排序函数"""
    if len(data) <= 1:
        return data

    pivot = data[0]
    left = [x for x in data[1:] if x <= pivot]
    right = [x for x in data[1:] if x > pivot]

    return quick_sort_func(left) + [pivot] + quick_sort_func(right)

# 使用示例
data = [64, 34, 25, 12, 22, 11, 90]

# 面向对象方式
bubble_strategy = BubbleSort()
quick_strategy = QuickSort()

print(f"Bubble Sort: {sort_with_strategy(data, bubble_strategy)}")
print(f"Quick Sort: {sort_with_strategy(data, quick_strategy)}")

# 函数式方式
print(f"Bubble Sort (Functional): {functional_sort(data, bubble_sort_func)}")
print(f"Quick Sort (Functional): {functional_sort(data, quick_sort_func)}")
```

#### 1.2 高阶函数与算法优化

```python
from typing import Callable, List, TypeVar, Optional
from functools import lru_cache
import time

T = TypeVar('T')

def memoize_with_key(key_func: Callable[[T], Any] = lambda x: x):
    """
    带自定义键的记忆化装饰器

    Args:
        key_func: 用于生成缓存键的函数
    """
    def decorator(func: Callable[[T], T]) -> Callable[[T], T]:
        cache = {}

        def wrapper(arg: T) -> T:
            key = key_func(arg)
            if key not in cache:
                cache[key] = func(arg)
            return cache[key]

        wrapper.cache = cache
        wrapper.cache_info = lambda: f"Cache size: {len(cache)}"
        return wrapper

    return decorator

def measure_performance(func: Callable) -> Callable:
    """性能测量装饰器"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.6f} seconds")
        return result
    return wrapper

# 斐波那契数列的不同实现
@measure_performance
def fibonacci_naive(n: int) -> int:
    """朴素的斐波那契实现（指数时间复杂度）"""
    if n <= 1:
        return n
    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)

@measure_performance
@lru_cache(maxsize=None)
def fibonacci_memoized(n: int) -> int:
    """记忆化的斐波那契实现（线性时间复杂度）"""
    if n <= 1:
        return n
    return fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)

@measure_performance
@memoize_with_key()
def fibonacci_custom_memo(n: int) -> int:
    """自定义记忆化的斐波那契实现"""
    if n <= 1:
        return n
    return fibonacci_custom_memo(n - 1) + fibonacci_custom_memo(n - 2)

# 使用示例
print("Naive Fibonacci (n=30):")
result1 = fibonacci_naive(30)

print("\nMemoized Fibonacci (n=30):")
result2 = fibonacci_memoized(30)

print("\nCustom Memoized Fibonacci (n=30):")
result3 = fibonacci_custom_memo(30)

print(f"\nResults: {result1}, {result2}, {result3}")
```

### 2. 函数作为返回值的高级应用

#### 2.1 函数工厂和闭包

```python
from typing import Callable, List, Dict, Any
import operator

def create_comparator(key_func: Callable[[Any], Any], reverse: bool = False) -> Callable[[Any, Any], bool]:
    """
    创建比较器函数

    Args:
        key_func: 提取比较键的函数
        reverse: 是否反转比较结果

    Returns:
        比较函数
    """
    def comparator(a: Any, b: Any) -> bool:
        key_a = key_func(a)
        key_b = key_func(b)

        if reverse:
            return key_a > key_b
        else:
            return key_a < key_b

    return comparator

def create_filter(conditions: List[Callable[[Any], bool]]) -> Callable[[Any], bool]:
    """
    创建复合过滤器

    Args:
        conditions: 条件函数列表

    Returns:
        复合过滤函数
    """
    def filter_func(item: Any) -> bool:
        return all(condition(item) for condition in conditions)

    return filter_func

def create_transformer(transformations: List[Callable[[Any], Any]]) -> Callable[[Any], Any]:
    """
    创建数据转换器

    Args:
        transformations: 转换函数列表

    Returns:
        复合转换函数
    """
    def transform_func(item: Any) -> Any:
        result = item
        for transform in transformations:
            result = transform(result)
        return result

    return transform_func

# 使用示例
students = [
    {'name': 'Alice', 'age': 20, 'score': 85},
    {'name': 'Bob', 'age': 22, 'score': 92},
    {'name': 'Charlie', 'age': 21, 'score': 78},
    {'name': 'David', 'age': 23, 'score': 88}
]

# 创建比较器
age_comparator = create_comparator(lambda x: x['age'])
score_comparator = create_comparator(lambda x: x['score'], reverse=True)

# 创建过滤器
adult_filter = create_filter([
    lambda x: x['age'] >= 18,
    lambda x: x['score'] >= 80
])

# 创建转换器
student_transformer = create_transformer([
    lambda x: {**x, 'grade': 'A' if x['score'] >= 90 else 'B' if x['score'] >= 80 else 'C'},
    lambda x: {k: v for k, v in x.items() if k != 'score'}
])

# 应用这些高阶函数
sorted_by_age = sorted(students, key=age_comparator)
filtered_students = list(filter(adult_filter, students))
transformed_students = [student_transformer(s) for s in students]

print("Sorted by age:")
for student in sorted_by_age:
    print(student)

print("\nFiltered adults with good scores:")
for student in filtered_students:
    print(student)

print("\nTransformed students:")
for student in transformed_students:
    print(student)
```

#### 2.2 偏函数应用和函数绑定

```python
from functools import partial
from typing import Callable, Any

def power(base: float, exponent: float) -> float:
    """幂函数"""
    return base ** exponent

def weighted_average(values: List[float], weights: List[float]) -> float:
    """加权平均"""
    if len(values) != len(weights):
        raise ValueError("Values and weights must have the same length")

    return sum(v * w for v, w in zip(values, weights)) / sum(weights)

def apply_operation(data: List[Any], operation: Callable[[Any], Any]) -> List[Any]:
    """应用操作到数据列表"""
    return [operation(item) for item in data]

# 创建偏函数
square = partial(power, exponent=2)
cube = partial(power, exponent=3)
sqrt = partial(power, exponent=0.5)

# 创建特定的加权平均函数
simple_average = partial(weighted_average, weights=[1, 1, 1])
equal_weights = partial(weighted_average, weights=[0.3, 0.3, 0.4])

# 创建特定的数据处理函数
square_all = partial(apply_operation, operation=square)
cube_all = partial(apply_operation, operation=cube)

# 使用示例
numbers = [1, 2, 3, 4, 5]

print(f"Squares: {square_all(numbers)}")
print(f"Cubes: {cube_all(numbers)}")

print(f"2^3 = {power(2, 3)}")
print(f"Square of 4: {square(4)}")
print(f"Cube of 4: {cube(4)}")

grades = [85, 90, 78]
weights = [0.3, 0.4, 0.3]

print(f"Weighted average: {weighted_average(grades, weights)}")
print(f"Simple average: {simple_average(grades)}")
print(f"Equal weights: {equal_weights(grades)}")
```

## 函数组合的深度理论

### 1. 数学理论基础

#### 1.1 函数组合的数学定义

给定两个函数 $f: B \rightarrow C$ 和 $g: A \rightarrow B$，它们的组合 $f \circ g: A \rightarrow C$ 定义为：

$$(f \circ g)(x) = f(g(x))$$

#### 1.2 函数组合的定律

1. **结合律**：$(f \circ g) \circ h = f \circ (g \circ h)$
2. **恒等律**：$f \circ id = id \circ f = f$
3. **分配律**：$f \circ (g + h) = f \circ g + f \circ h$（在某些条件下）

### 2. 函数组合的实现模式

#### 2.1 基础函数组合

```python
from typing import Callable, TypeVar, Any
from functools import reduce

T = TypeVar('T')
R = TypeVar('R')

def compose(f: Callable[[R], T], g: Callable[[T], R]) -> Callable[[T], T]:
    """
    基础函数组合

    数学表示：h = f ∘ g
    实现方式：h(x) = f(g(x))
    """
    def h(x: T) -> T:
        return f(g(x))

    h.__name__ = f"compose({f.__name__}, {g.__name__})"
    return h

def compose_many(*functions: Callable) -> Callable:
    """
    多函数组合

    数学表示：compose_many(f, g, h) = f ∘ g ∘ h
    实现方式：compose_many(f, g, h)(x) = f(g(h(x)))
    """
    def composed(x: Any) -> Any:
        result = x
        for func in reversed(functions):
            result = func(result)
        return result

    if functions:
        func_names = [f.__name__ for f in functions]
        composed.__name__ = f"compose_many({', '.join(func_names)})"

    return composed

def pipe(*functions: Callable) -> Callable:
    """
    管道组合：与compose_many相反的执行顺序

    数学表示：pipe(f, g, h) = h ∘ g ∘ f
    实现方式：pipe(f, g, h)(x) = h(g(f(x)))
    """
    return compose_many(*reversed(functions))

# 使用示例
def add_one(x: int) -> int:
    return x + 1

def multiply_by_two(x: int) -> int:
    return x * 2

def square(x: int) -> int:
    return x ** 2

# 基础组合
add_then_multiply = compose(multiply_by_two, add_one)
print(f"add_then_multiply(5) = {add_then_multiply(5)}")  # (5 + 1) * 2 = 12

# 多函数组合
complex_pipeline = compose_many(square, multiply_by_two, add_one)
print(f"complex_pipeline(3) = {complex_pipeline(3)}")  # ((3 + 1) * 2) ** 2 = 64

# 管道组合
pipeline = pipe(add_one, multiply_by_two, square)
print(f"pipeline(3) = {pipeline(3)}")  # ((3 + 1) * 2) ** 2 = 64
```

#### 2.2 函数组合的泛化实现

```python
from typing import Generic, TypeVar, Callable, Any
from abc import ABC, abstractmethod

T = TypeVar('T')
R = TypeVar('R')

class Composable(ABC, Generic[T]):
    """可组合的抽象基类"""

    @abstractmethod
    def compose(self, other: 'Composable[R]') -> 'Composable[T]':
        """组合操作"""
        pass

    @abstractmethod
    def apply(self, value: Any) -> Any:
        """应用函数"""
        pass

class Function(Composable[T]):
    """函数的可组合包装器"""

    def __init__(self, func: Callable):
        self.func = func

    def compose(self, other: 'Function[R]') -> 'Function[T]':
        """组合函数"""
        def composed(x):
            return self.func(other.func(x))
        return Function(composed)

    def apply(self, value: Any) -> Any:
        """应用函数"""
        return self.func(value)

    def __call__(self, value: Any) -> Any:
        """使函数可调用"""
        return self.apply(value)

    def __repr__(self) -> str:
        return f"Function({self.func.__name__})"

# 函数组合操作符
def __rshift__(self: Function, other: Function) -> Function:
    """重载 >> 操作符用于函数组合"""
    return self.compose(other)

Function.__rshift__ = __rshift__

# 使用示例
add_one_func = Function(add_one)
multiply_func = Function(multiply_by_two)
square_func = Function(square)

# 使用 >> 操作符组合
pipeline = add_one_func >> multiply_func >> square_func
print(f"pipeline(3) = {pipeline(3)}")  # ((3 + 1) * 2) ** 2 = 64

# 使用 compose 方法
composed = square_func.compose(multiply_func).compose(add_one_func)
print(f"composed(3) = {composed(3)}")  # ((3 + 1) * 2) ** 2 = 64
```

### 3. 高级函数组合模式

#### 3.1 Kleisli组合

```python
from typing import Callable, TypeVar, Generic, Optional, List
from dataclasses import dataclass

T = TypeVar('T')
R = TypeVar('R')

class Maybe(Generic[T]):
    """Maybe monad - 处理可能失败的计算"""

    def __init__(self, value: Optional[T] = None):
        self.value = value

    def bind(self, func: Callable[[T], 'Maybe[R]']) -> 'Maybe[R]':
        """Kleisli组合：bind操作"""
        if self.value is None:
            return Maybe()
        return func(self.value)

    def __rshift__(self, func: Callable[[T], 'Maybe[R]']) -> 'Maybe[R]':
        """重载 >> 操作符用于Kleisli组合"""
        return self.bind(func)

    def __repr__(self) -> str:
        return f"Just({self.value})" if self.value is not None else "Nothing"

def safe_divide(a: float, b: float) -> Maybe[float]:
    """安全的除法操作"""
    if b == 0:
        return Maybe()
    return Maybe(a / b)

def safe_sqrt(x: float) -> Maybe[float]:
    """安全的平方根操作"""
    if x < 0:
        return Maybe()
    return Maybe(x ** 0.5)

def safe_log(x: float) -> Maybe[float]:
    """安全的对数操作"""
    if x <= 0:
        return Maybe()
    import math
    return Maybe(math.log(x))

# Kleisli组合
def kleisli_compose(f: Callable[[T], Maybe[R]], g: Callable[[R], Maybe[S]]) -> Callable[[T], Maybe[S]]:
    """
    Kleisli组合：组合两个Maybe返回的函数

    数学表示：kleisli_compose(f, g) = g >=> f
    """
    def composed(x: T) -> Maybe[S]:
        return f(x).bind(g)

    return composed

# 使用Kleisli组合
sqrt_then_log = kleisli_compose(safe_sqrt, safe_log)

# 使用 >> 操作符
result = Maybe(16.0) >> safe_sqrt >> safe_log
print(f"Kleisli composition result: {result}")  # Just(1.3862943611198906)

# 失败情况
failure = Maybe(-16.0) >> safe_sqrt >> safe_log
print(f"Failure case: {failure}")  # Nothing
```

#### 3.2 函数组合与错误处理

```python
from typing import Callable, TypeVar, Union, List
from dataclasses import dataclass

T = TypeVar('T')
R = TypeVar('R')
E = TypeVar('E')

@dataclass
class Success(Generic[T]):
    """成功结果"""
    value: T

@dataclass
class Failure(Generic[E]):
    """失败结果"""
    error: E

Result = Union[Success[T], Failure[E]]

def safe_execute(func: Callable[..., T], *args, **kwargs) -> Result[T, Exception]:
    """安全执行函数，返回Result类型"""
    try:
        return Success(func(*args, **kwargs))
    except Exception as e:
        return Failure(e)

def result_compose(f: Callable[[T], Result[R, E]], g: Callable[[R], Result[S, E]]) -> Callable[[T], Result[S, E]]:
    """Result类型的函数组合"""
    def composed(x: T) -> Result[S, E]:
        result1 = f(x)
        if isinstance(result1, Failure):
            return result1

        result2 = g(result1.value)
        return result2

    return composed

# 使用示例
def divide_safely(a: float, b: float) -> Result[float, str]:
    """安全除法"""
    if b == 0:
        return Failure("Division by zero")
    return Success(a / b)

def sqrt_safely(x: float) -> Result[float, str]:
    """安全平方根"""
    if x < 0:
        return Failure("Negative number")
    import math
    return Success(math.sqrt(x))

def log_safely(x: float) -> Result[float, str]:
    """安全对数"""
    if x <= 0:
        return Failure("Non-positive number")
    import math
    return Success(math.log(x))

# 组合Result类型的函数
sqrt_then_log = result_compose(divide_safely, lambda x: sqrt_safely(x))
full_pipeline = result_compose(sqrt_then_log, lambda x: log_safely(x))

# 使用组合
result = full_pipeline(16.0, 2.0)  # 16/2 = 8, sqrt(8) ≈ 2.828, log(2.828) ≈ 1.040
print(f"Result pipeline: {result}")

if isinstance(result, Success):
    print(f"Final result: {result.value:.4f}")
else:
    print(f"Error: {result.error}")
```

## 实际应用案例

### 1. 函数式数据处理管道

```python
from typing import List, Dict, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum
import json

class ProcessingError(Enum):
    """处理错误类型"""
    INVALID_DATA = "invalid_data"
    MISSING_FIELD = "missing_field"
    VALUE_ERROR = "value_error"

@dataclass
class ProcessingResult:
    """处理结果"""
    success: bool
    data: Any = None
    error: Optional[ProcessingError] = None
    message: str = ""

class DataProcessor:
    """函数式数据处理器"""

    def __init__(self):
        self.pipeline: List[Callable] = []

    def add_step(self, step: Callable) -> 'DataProcessor':
        """添加处理步骤"""
        self.pipeline.append(step)
        return self

    def process(self, data: Any) -> ProcessingResult:
        """执行处理管道"""
        current_data = data

        for step in self.pipeline:
            try:
                result = step(current_data)
                if isinstance(result, ProcessingResult):
                    if not result.success:
                        return result
                    current_data = result.data
                else:
                    current_data = result
            except Exception as e:
                return ProcessingResult(
                    success=False,
                    error=ProcessingError.INVALID_DATA,
                    message=f"Step failed: {str(e)}"
                )

        return ProcessingResult(success=True, data=current_data)

    def __or__(self, step: Callable) -> 'DataProcessor':
        """管道操作符"""
        return self.add_step(step)

def validate_schema(schema: Dict[str, type]) -> Callable:
    """验证数据模式"""
    def validator(data: Dict[str, Any]) -> ProcessingResult:
        for field, expected_type in schema.items():
            if field not in data:
                return ProcessingResult(
                    success=False,
                    error=ProcessingError.MISSING_FIELD,
                    message=f"Missing field: {field}"
                )

            if not isinstance(data[field], expected_type):
                return ProcessingResult(
                    success=False,
                    error=ProcessingError.VALUE_ERROR,
                    message=f"Field {field} should be {expected_type}"
                )

        return ProcessingResult(success=True, data=data)

    return validator

def transform_fields(transformations: Dict[str, Callable]) -> Callable:
    """转换字段"""
    def transformer(data: Dict[str, Any]) -> ProcessingResult:
        try:
            result = data.copy()
            for field, transform in transformations.items():
                if field in result:
                    result[field] = transform(result[field])

            return ProcessingResult(success=True, data=result)
        except Exception as e:
            return ProcessingResult(
                success=False,
                error=ProcessingError.VALUE_ERROR,
                message=f"Transform failed: {str(e)}"
            )

    return transformer

def filter_data(predicate: Callable[[Any], bool]) -> Callable:
    """过滤数据"""
    def filter_func(data: Any) -> ProcessingResult:
        if isinstance(data, list):
            filtered = [item for item in data if predicate(item)]
            return ProcessingResult(success=True, data=filtered)
        elif predicate(data):
            return ProcessingResult(success=True, data=data)
        else:
            return ProcessingResult(
                success=False,
                error=ProcessingError.INVALID_DATA,
                message="Data filtered out"
            )

    return filter_func

def aggregate_data(agg_func: Callable) -> Callable:
    """聚合数据"""
    def aggregator(data: Any) -> ProcessingResult:
        try:
            if isinstance(data, list):
                result = agg_func(data)
                return ProcessingResult(success=True, data=result)
            else:
                return ProcessingResult(success=True, data=data)
        except Exception as e:
            return ProcessingResult(
                success=False,
                error=ProcessingError.VALUE_ERROR,
                message=f"Aggregation failed: {str(e)}"
            )

    return aggregator

# 使用示例
raw_data = [
    {"name": "Alice", "age": 25, "salary": 50000, "department": "Engineering"},
    {"name": "Bob", "age": 30, "salary": 60000, "department": "Marketing"},
    {"name": "Charlie", "age": 35, "salary": 70000, "department": "Engineering"},
    {"name": "David", "age": 40, "salary": 80000, "department": "Management"},
    {"name": "Eve", "age": 28, "salary": 55000, "department": "Engineering"}
]

# 创建处理管道
processor = DataProcessor()

processor = (processor
    | validate_schema({"name": str, "age": int, "salary": int, "department": str})
    | filter_data(lambda x: x["age"] >= 25)
    | transform_fields({
        "salary": lambda x: x * 1.1,  # 加薪10%
        "age": lambda x: x + 1        # 年龄加1
    })
    | filter_data(lambda x: x["department"] == "Engineering")
    | aggregate_data(lambda x: sum(item["salary"] for item in x) / len(x))
)

# 执行处理
result = processor.process(raw_data)

if result.success:
    print(f"Average salary in Engineering: ${result.data:.2f}")
else:
    print(f"Processing failed: {result.message}")
```

### 2. 函数式算法框架

```python
from typing import Callable, TypeVar, List, Optional, Any
from abc import ABC, abstractmethod
from functools import lru_cache

T = TypeVar('T')
R = TypeVar('R')

class Algorithm(ABC):
    """算法的抽象基类"""

    @abstractmethod
    def execute(self, input_data: Any) -> Any:
        """执行算法"""
        pass

    @abstractmethod
    def time_complexity(self) -> str:
        """时间复杂度"""
        pass

    @abstractmethod
    def space_complexity(self) -> str:
        """空间复杂度"""
        pass

class FunctionalAlgorithm(Algorithm):
    """函数式算法基类"""

    def __init__(self, name: str, func: Callable, time_comp: str, space_comp: str):
        self.name = name
        self.func = func
        self._time_complexity = time_comp
        self._space_complexity = space_comp

    def execute(self, input_data: Any) -> Any:
        """执行算法"""
        return self.func(input_data)

    def time_complexity(self) -> str:
        """时间复杂度"""
        return self._time_complexity

    def space_complexity(self) -> str:
        """空间复杂度"""
        return self._space_complexity

class AlgorithmRegistry:
    """算法注册表"""

    def __init__(self):
        self.algorithms: Dict[str, Algorithm] = {}

    def register(self, name: str, algorithm: Algorithm) -> None:
        """注册算法"""
        self.algorithms[name] = algorithm

    def get(self, name: str) -> Optional[Algorithm]:
        """获取算法"""
        return self.algorithms.get(name)

    def list_algorithms(self) -> List[str]:
        """列出所有算法"""
        return list(self.algorithms.keys())

# 创建算法注册表
registry = AlgorithmRegistry()

# 注册排序算法
def bubble_sort_implementation(data: List[int]) -> List[int]:
    """冒泡排序实现"""
    data = data.copy()
    n = len(data)
    for i in range(n):
        for j in range(0, n - i - 1):
            if data[j] > data[j + 1]:
                data[j], data[j + 1] = data[j + 1], data[j]
    return data

def quick_sort_implementation(data: List[int]) -> List[int]:
    """快速排序实现"""
    if len(data) <= 1:
        return data

    pivot = data[0]
    left = [x for x in data[1:] if x <= pivot]
    right = [x for x in data[1:] if x > pivot]

    return quick_sort_implementation(left) + [pivot] + quick_sort_implementation(right)

def merge_sort_implementation(data: List[int]) -> List[int]:
    """归并排序实现"""
    if len(data) <= 1:
        return data

    mid = len(data) // 2
    left = merge_sort_implementation(data[:mid])
    right = merge_sort_implementation(data[mid:])

    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result

# 注册算法
registry.register("bubble_sort", FunctionalAlgorithm(
    "Bubble Sort",
    bubble_sort_implementation,
    "O(n²)",
    "O(1)"
))

registry.register("quick_sort", FunctionalAlgorithm(
    "Quick Sort",
    quick_sort_implementation,
    "O(n log n)",
    "O(log n)"
))

registry.register("merge_sort", FunctionalAlgorithm(
    "Merge Sort",
    merge_sort_implementation,
    "O(n log n)",
    "O(n)"
))

# 算法选择器
def select_algorithm(data_size: int) -> str:
    """根据数据大小选择算法"""
    if data_size < 100:
        return "bubble_sort"
    elif data_size < 10000:
        return "quick_sort"
    else:
        return "merge_sort"

# 使用示例
import random
import time

# 生成测试数据
small_data = [random.randint(1, 100) for _ in range(50)]
medium_data = [random.randint(1, 1000) for _ in range(1000)]
large_data = [random.randint(1, 10000) for _ in range(5000)]

# 测试不同大小的数据
for data, size in [(small_data, "small"), (medium_data, "medium"), (large_data, "large")]:
    print(f"\nTesting {size} data (size: {len(data)})")

    algorithm_name = select_algorithm(len(data))
    algorithm = registry.get(algorithm_name)

    if algorithm:
        print(f"Selected algorithm: {algorithm.name}")
        print(f"Time complexity: {algorithm.time_complexity()}")
        print(f"Space complexity: {algorithm.space_complexity()}")

        start_time = time.time()
        result = algorithm.execute(data)
        end_time = time.time()

        print(f"Execution time: {end_time - start_time:.6f} seconds")
        print(f"Sorted (first 10): {result[:10]}")
```

## 总结

本章深入探讨了高阶函数和lambda表达式的理论基础和实际应用：

### 核心概念：

1. **Lambda表达式**：基于λ演算的匿名函数，支持闭包和高阶函数操作
2. **高阶函数**：接受或返回函数的函数，支持策略模式、工厂模式等设计模式
3. **函数组合**：基于数学理论的函数组合模式，支持链式操作和管道处理
4. **柯里化和偏函数**：将多参数函数转换为单参数函数的技术

### 实际应用：

1. **数据处理管道**：使用函数组合构建复杂的数据处理流程
2. **算法框架**：高阶函数在算法选择和执行中的应用
3. **错误处理**：Kleisli组合和Result类型的错误处理模式
4. **性能优化**：记忆化、缓存和惰性求值等优化技术

### 数学基础：

- λ演算的语法和语义
- 函数组合的数学定律
- Kleisli组合和Monad理论
- 复杂度分析和优化理论

通过深入理解这些概念，学员可以掌握函数式编程的核心技能，设计出更加优雅、高效和可维护的算法系统。这些技术不仅适用于学术研究，也能在实际工程项目中发挥重要作用。