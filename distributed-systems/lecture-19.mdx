---
title: "Lecture 19: ç›‘æ§å’Œè°ƒè¯• - åˆ†å¸ƒå¼ç³»ç»Ÿå¯è§‚æµ‹æ€§"
description: "æ·±å…¥ç†è§£åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç›‘æ§ã€æ—¥å¿—ã€è¿½è¸ªå’Œæ•…éšœè¯Šæ–­æŠ€æœ¯"
---

# Lecture 19: ç›‘æ§å’Œè°ƒè¯• - åˆ†å¸ƒå¼ç³»ç»Ÿå¯è§‚æµ‹æ€§

## æœ¬å‘¨å†…å®¹

- **ç›‘æ§æŒ‡æ ‡ä½“ç³»**ï¼šREDã€USEã€é»„é‡‘ä¿¡å·æŒ‡æ ‡å’Œè‡ªå®šä¹‰æŒ‡æ ‡
- **æ—¥å¿—ç³»ç»Ÿæ¶æ„**ï¼šELKã€EFKã€Lokiæ ˆå’Œæœ€ä½³å®è·µ
- **åˆ†å¸ƒå¼è¿½è¸ª**ï¼šOpenTracingã€OpenTelemetryå’Œé“¾è·¯åˆ†æ
- **å‘Šè­¦æœºåˆ¶**ï¼šå¤šçº§å‘Šè­¦ã€æ™ºèƒ½å‘Šè­¦å’Œå‘Šè­¦æ”¶æ•›
- **å®è·µé¡¹ç›®**ï¼šæ„å»ºå®Œæ•´çš„å¯è§‚æµ‹æ€§å¹³å°

## è¯¾ç¨‹è§†é¢‘

<iframe width="560" height="315" src="https://www.youtube.com/embed/e6g0tY4c5b4" title="åˆ†å¸ƒå¼ç³»ç»Ÿç›‘æ§å’Œè°ƒè¯•" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## æ ¸å¿ƒæ¦‚å¿µ

### å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±

å¯è§‚æµ‹æ€§ï¼ˆObservabilityï¼‰æ˜¯ç†è§£ç³»ç»Ÿå†…éƒ¨çŠ¶æ€çš„èƒ½åŠ›ï¼Œé€šè¿‡å¤–éƒ¨è¾“å‡ºæ¥æ¨æ–­ç³»ç»Ÿè¡Œä¸ºã€‚ä¸‰å¤§æ”¯æŸ±åˆ†åˆ«æ˜¯ï¼š

**å¯è§‚æµ‹æ€§æ¶æ„**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å¯è§‚æµ‹æ€§å¹³å°                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æŒ‡æ ‡ç›‘æ§   â”‚   æ—¥å¿—ç³»ç»Ÿ   â”‚   é“¾è·¯è¿½è¸ª   â”‚     å‘Šè­¦ç³»ç»Ÿ     â”‚
â”‚ (Metrics)   â”‚   (Logs)    â”‚  (Tracing)  â”‚   (Alerting)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Prometheus  â”‚ Elasticsearchâ”‚    Jaeger   â”‚    AlertManager â”‚
â”‚   Grafana   â”‚    Kibana   â”‚   Zipkin    â”‚    PagerDuty    â”‚
â”‚   InfluxDB  â”‚    Fluentd  â”‚ OpenTelemetryâ”‚    Slack/Webhookâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç›‘æ§æŒ‡æ ‡ä½“ç³»è¯¦è§£

#### 1. æŒ‡æ ‡ç±»å‹å’Œé‡‡é›†

```go
// æŒ‡æ ‡ç±»å‹å®šä¹‰
type MetricType int

const (
    MetricTypeCounter MetricType = iota
    MetricTypeGauge
    MetricTypeHistogram
    MetricTypeSummary
)

// æŒ‡æ ‡æ•°æ®ç»“æ„
type Metric struct {
    Name      string
    Type      MetricType
    Labels    map[string]string
    Value     float64
    Timestamp time.Time
}

// æŒ‡æ ‡æ”¶é›†å™¨æ¥å£
type MetricsCollector interface {
    Collect() ([]Metric, error)
    Describe() []string
}

// è®¡æ•°å™¨å®ç°
type Counter struct {
    name   string
    labels map[string]string
    value  float64
    mu     sync.Mutex
}

func NewCounter(name string, labels map[string]string) *Counter {
    return &Counter{
        name:   name,
        labels: labels,
        value:  0,
    }
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Add(v float64) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value += v
}

func (c *Counter) Collect() []Metric {
    c.mu.Lock()
    defer c.mu.Unlock()

    return []Metric{
        {
            Name:      c.name,
            Type:      MetricTypeCounter,
            Labels:    c.labels,
            Value:     c.value,
            Timestamp: time.Now(),
        },
    }
}

// ä»ªè¡¨ç›˜å®ç°
type Gauge struct {
    name   string
    labels map[string]string
    value  float64
    mu     sync.Mutex
}

func NewGauge(name string, labels map[string]string) *Gauge {
    return &Gauge{
        name:   name,
        labels: labels,
        value:  0,
    }
}

func (g *Gauge) Set(v float64) {
    g.mu.Lock()
    defer g.mu.Unlock()
    g.value = v
}

func (g *Gauge) Inc() {
    g.mu.Lock()
    defer g.mu.Unlock()
    g.value++
}

func (g *Gauge) Dec() {
    g.mu.Lock()
    defer g.mu.Unlock()
    g.value--
}

func (g *Gauge) Collect() []Metric {
    g.mu.Lock()
    defer g.mu.Unlock()

    return []Metric{
        {
            Name:      g.name,
            Type:      MetricTypeGauge,
            Labels:    g.labels,
            Value:     g.value,
            Timestamp: time.Now(),
        },
    }
}

// ç›´æ–¹å›¾å®ç°
type Histogram struct {
    name      string
    labels    map[string]string
    buckets   []float64
    counts    []float64
    sum       float64
    count     float64
    mu        sync.Mutex
}

func NewHistogram(name string, labels map[string]string, buckets []float64) *Histogram {
    return &Histogram{
        name:    name,
        labels:  labels,
        buckets: buckets,
        counts:  make([]float64, len(buckets)+1),
        sum:     0,
        count:   0,
    }
}

func (h *Histogram) Observe(v float64) {
    h.mu.Lock()
    defer h.mu.Unlock()

    h.sum += v
    h.count++

    // æ‰¾åˆ°åˆé€‚çš„bucket
    for i, bucket := range h.buckets {
        if v <= bucket {
            h.counts[i]++
            return
        }
    }
    h.counts[len(h.counts)-1]++
}

func (h *Histogram) Collect() []Metric {
    h.mu.Lock()
    defer h.mu.Unlock()

    metrics := make([]Metric, 0, len(h.counts)+2)

    // æ·»åŠ bucketæŒ‡æ ‡
    for i, count := range h.counts {
        bucketLabels := make(map[string]string)
        for k, v := range h.labels {
            bucketLabels[k] = v
        }

        if i < len(h.buckets) {
            bucketLabels["le"] = fmt.Sprintf("%.2f", h.buckets[i])
        } else {
            bucketLabels["le"] = "+Inf"
        }

        metrics = append(metrics, Metric{
            Name:      h.name + "_bucket",
            Type:      MetricTypeHistogram,
            Labels:    bucketLabels,
            Value:     count,
            Timestamp: time.Now(),
        })
    }

    // æ·»åŠ sumå’ŒcountæŒ‡æ ‡
    metrics = append(metrics, Metric{
        Name:      h.name + "_sum",
        Type:      MetricTypeHistogram,
        Labels:    h.labels,
        Value:     h.sum,
        Timestamp: time.Now(),
    })

    metrics = append(metrics, Metric{
        Name:      h.name + "_count",
        Type:      MetricTypeHistogram,
        Labels:    h.labels,
        Value:     h.count,
        Timestamp: time.Now(),
    })

    return metrics
}
```

#### 2. REDå’ŒUSEæŒ‡æ ‡

```go
// REDæŒ‡æ ‡å®ç°
type REDMetrics struct {
    requestRate  *Counter
    errorRate    *Counter
    duration     *Histogram
}

func NewREDMetrics(serviceName string) *REDMetrics {
    return &REDMetrics{
        requestRate: NewCounter("http_requests_total", map[string]string{"service": serviceName}),
        errorRate:   NewCounter("http_errors_total", map[string]string{"service": serviceName}),
        duration:    NewHistogram("http_request_duration_seconds",
                                map[string]string{"service": serviceName},
                                []float64{0.1, 0.5, 1.0, 2.5, 5.0, 10.0}),
    }
}

func (rm *REDMetrics) RecordRequest(duration time.Duration, isError bool) {
    rm.requestRate.Inc()
    if isError {
        rm.errorRate.Inc()
    }
    rm.duration.Observe(duration.Seconds())
}

// USEæŒ‡æ ‡å®ç°
type USEMetrics struct {
    utilization map[string]*Gauge
    saturation  map[string]*Gauge
    errors      map[string]*Counter
}

func NewUSEMetrics() *USEMetrics {
    return &USEMetrics{
        utilization: make(map[string]*Gauge),
        saturation:  make(map[string]*Gauge),
        errors:      make(map[string]*Counter),
    }
}

func (um *USEMetrics) RecordUtilization(resource string, value float64) {
    if _, exists := um.utilization[resource]; !exists {
        um.utilization[resource] = NewGauge("resource_utilization",
            map[string]string{"resource": resource, "type": "utilization"})
    }
    um.utilization[resource].Set(value)
}

func (um *USEMetrics) RecordSaturation(resource string, value float64) {
    if _, exists := um.saturation[resource]; !exists {
        um.saturation[resource] = NewGauge("resource_utilization",
            map[string]string{"resource": resource, "type": "saturation"})
    }
    um.saturation[resource].Set(value)
}

func (um *USEMetrics) RecordError(resource string) {
    if _, exists := um.errors[resource]; !exists {
        um.errors[resource] = NewCounter("resource_errors_total",
            map[string]string{"resource": resource})
    }
    um.errors[resource].Inc()
}
```

#### 3. æŒ‡æ ‡å­˜å‚¨å’ŒæŸ¥è¯¢

```go
// æ—¶åºæ•°æ®åº“æ¥å£
type TimeSeriesDB interface {
    WriteMetrics(metrics []Metric) error
    QueryRange(query string, start, end time.Time) ([]MetricPoint, error)
    QueryInstant(query string, timestamp time.Time) (float64, error)
}

// å†…å­˜æ—¶åºæ•°æ®åº“å®ç°
type InMemoryTimeSeriesDB struct {
    data map[string][]MetricPoint
    mu   sync.RWMutex
}

type MetricPoint struct {
    Timestamp time.Time
    Value     float64
    Labels    map[string]string
}

func NewInMemoryTimeSeriesDB() *InMemoryTimeSeriesDB {
    return &InMemoryTimeSeriesDB{
        data: make(map[string][]MetricPoint),
    }
}

func (db *InMemoryTimeSeriesDB) WriteMetrics(metrics []Metric) error {
    db.mu.Lock()
    defer db.mu.Unlock()

    for _, metric := range metrics {
        key := metric.name
        for k, v := range metric.Labels {
            key += fmt.Sprintf(":%s=%s", k, v)
        }

        point := MetricPoint{
            Timestamp: metric.Timestamp,
            Value:     metric.Value,
            Labels:    metric.Labels,
        }

        db.data[key] = append(db.data[key], point)

        // ä¿æŒæ•°æ®ç‚¹æ•°é‡åœ¨åˆç†èŒƒå›´å†…
        if len(db.data[key]) > 10000 {
            db.data[key] = db.data[key][1:]
        }
    }

    return nil
}

func (db *InMemoryTimeSeriesDB) QueryRange(query string, start, end time.Time) ([]MetricPoint, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()

    var results []MetricPoint

    for key, points := range db.data {
        if strings.Contains(key, query) {
            for _, point := range points {
                if point.Timestamp.After(start) && point.Timestamp.Before(end) {
                    results = append(results, point)
                }
            }
        }
    }

    return results, nil
}

func (db *InMemoryTimeSeriesDB) QueryInstant(query string, timestamp time.Time) (float64, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()

    for key, points := range db.data {
        if strings.Contains(key, query) {
            for i := len(points) - 1; i >= 0; i-- {
                if points[i].Timestamp.Before(timestamp) || points[i].Timestamp.Equal(timestamp) {
                    return points[i].Value, nil
                }
            }
        }
    }

    return 0, fmt.Errorf("no data found for query: %s", query)
}
```

### æ—¥å¿—ç³»ç»Ÿæ¶æ„

#### 1. æ—¥å¿—æ”¶é›†å’Œèšåˆ

```go
// æ—¥å¿—çº§åˆ«
type LogLevel int

const (
    DebugLevel LogLevel = iota
    InfoLevel
    WarnLevel
    ErrorLevel
    FatalLevel
)

// æ—¥å¿—æ¡ç›®
type LogEntry struct {
    Timestamp time.Time
    Level     LogLevel
    Message   string
    Fields    map[string]interface{}
    Caller    string
    StackTrace string
}

// æ—¥å¿—æ ¼å¼åŒ–æ¥å£
type LogFormatter interface {
    Format(entry LogEntry) ([]byte, error)
}

// JSONæ ¼å¼åŒ–å™¨
type JSONFormatter struct{}

func (jf *JSONFormatter) Format(entry LogEntry) ([]byte, error) {
    data := make(map[string]interface{})
    data["timestamp"] = entry.Timestamp.Format(time.RFC3339)
    data["level"] = entry.Level.String()
    data["message"] = entry.Message
    data["caller"] = entry.Caller

    for k, v := range entry.Fields {
        data[k] = v
    }

    if entry.StackTrace != "" {
        data["stack_trace"] = entry.StackTrace
    }

    return json.Marshal(data)
}

// æ—¥å¿—è¾“å‡ºæ¥å£
type LogOutput interface {
    Write(entry LogEntry) error
    Close() error
}

// æ–‡ä»¶è¾“å‡º
type FileOutput struct {
    file    *os.File
    encoder *json.Encoder
    mu      sync.Mutex
}

func NewFileOutput(filename string) (*FileOutput, error) {
    file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }

    return &FileOutput{
        file:    file,
        encoder: json.NewEncoder(file),
    }, nil
}

func (fo *FileOutput) Write(entry LogEntry) error {
    fo.mu.Lock()
    defer fo.mu.Unlock()
    return fo.encoder.Encode(entry)
}

func (fo *FileOutput) Close() error {
    fo.mu.Lock()
    defer fo.mu.Unlock()
    return fo.file.Close()
}

// æ§åˆ¶å°è¾“å‡º
type ConsoleOutput struct {
    formatter LogFormatter
}

func NewConsoleOutput(formatter LogFormatter) *ConsoleOutput {
    return &ConsoleOutput{
        formatter: formatter,
    }
}

func (co *ConsoleOutput) Write(entry LogEntry) error {
    data, err := co.formatter.Format(entry)
    if err != nil {
        return err
    }
    fmt.Println(string(data))
    return nil
}

func (co *ConsoleOutput) Close() error {
    return nil
}
```

#### 2. æ—¥å¿—æ”¶é›†å™¨

```go
// æ—¥å¿—æ”¶é›†å™¨
type Logger struct {
    name     string
    level    LogLevel
    outputs  []LogOutput
    fields   map[string]interface{}
    mu       sync.Mutex
}

func NewLogger(name string, level LogLevel) *Logger {
    return &Logger{
        name:    name,
        level:   level,
        outputs: make([]LogOutput, 0),
        fields:  make(map[string]interface{}),
    }
}

func (l *Logger) AddOutput(output LogOutput) {
    l.mu.Lock()
    defer l.mu.Unlock()
    l.outputs = append(l.outputs, output)
}

func (l *Logger) WithField(key string, value interface{}) *Logger {
    l.mu.Lock()
    defer l.mu.Unlock()

    newLogger := &Logger{
        name:    l.name,
        level:   l.level,
        outputs: l.outputs,
        fields:  make(map[string]interface{}),
    }

    // å¤åˆ¶çˆ¶å­—æ®µ
    for k, v := range l.fields {
        newLogger.fields[k] = v
    }
    newLogger.fields[key] = value

    return newLogger
}

func (l *Logger) WithFields(fields map[string]interface{}) *Logger {
    l.mu.Lock()
    defer l.mu.Unlock()

    newLogger := &Logger{
        name:    l.name,
        level:   l.level,
        outputs: l.outputs,
        fields:  make(map[string]interface{}),
    }

    // å¤åˆ¶çˆ¶å­—æ®µ
    for k, v := range l.fields {
        newLogger.fields[k] = v
    }

    // æ·»åŠ æ–°å­—æ®µ
    for k, v := range fields {
        newLogger.fields[k] = v
    }

    return newLogger
}

func (l *Logger) log(level LogLevel, message string, fields map[string]interface{}) {
    if level < l.level {
        return
    }

    entry := LogEntry{
        Timestamp: time.Now(),
        Level:     level,
        Message:   message,
        Fields:    make(map[string]interface{}),
    }

    // åˆå¹¶å­—æ®µ
    l.mu.Lock()
    for k, v := range l.fields {
        entry.Fields[k] = v
    }
    l.mu.Unlock()

    for k, v := range fields {
        entry.Fields[k] = v
    }

    // è·å–è°ƒç”¨è€…ä¿¡æ¯
    if pc, file, line, ok := runtime.Caller(2); ok {
        entry.Caller = fmt.Sprintf("%s:%d %s", filepath.Base(file), line,
            runtime.FuncForPC(pc).Name())
    }

    // è·å–å †æ ˆè·Ÿè¸ªï¼ˆé”™è¯¯çº§åˆ«ï¼‰
    if level >= ErrorLevel {
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        entry.StackTrace = string(buf[:n])
    }

    // å†™å…¥æ‰€æœ‰è¾“å‡º
    for _, output := range l.outputs {
        if err := output.Write(entry); err != nil {
            fmt.Printf("Failed to write log entry: %v\n", err)
        }
    }
}

func (l *Logger) Debug(message string, fields ...map[string]interface{}) {
    l.log(DebugLevel, message, mergeFields(fields...))
}

func (l *Logger) Info(message string, fields ...map[string]interface{}) {
    l.log(InfoLevel, message, mergeFields(fields...))
}

func (l *Logger) Warn(message string, fields ...map[string]interface{}) {
    l.log(WarnLevel, message, mergeFields(fields...))
}

func (l *Logger) Error(message string, fields ...map[string]interface{}) {
    l.log(ErrorLevel, message, mergeFields(fields...))
}

func (l *Logger) Fatal(message string, fields ...map[string]interface{}) {
    l.log(FatalLevel, message, mergeFields(fields...))
    os.Exit(1)
}

func mergeFields(fields ...map[string]interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    for _, field := range fields {
        for k, v := range field {
            result[k] = v
        }
    }
    return result
}

func (l LogLevel) String() string {
    switch l {
    case DebugLevel:
        return "DEBUG"
    case InfoLevel:
        return "INFO"
    case WarnLevel:
        return "WARN"
    case ErrorLevel:
        return "ERROR"
    case FatalLevel:
        return "FATAL"
    default:
        return "UNKNOWN"
    }
}
```

#### 3. æ—¥å¿—èšåˆå’Œè½¬å‘

```go
// æ—¥å¿—èšåˆå™¨
type LogAggregator struct {
    input     chan LogEntry
    outputs   []LogOutput
    batchSize int
    flushInterval time.Duration
    buffer    []LogEntry
    mu        sync.Mutex
    wg        sync.WaitGroup
    done      chan struct{}
}

func NewLogAggregator(bufferSize int, batchSize int, flushInterval time.Duration) *LogAggregator {
    return &LogAggregator{
        input:        make(chan LogEntry, bufferSize),
        outputs:      make([]LogOutput, 0),
        batchSize:    batchSize,
        flushInterval: flushInterval,
        buffer:       make([]LogEntry, 0, batchSize),
        done:         make(chan struct{}),
    }
}

func (la *LogAggregator) AddOutput(output LogOutput) {
    la.mu.Lock()
    defer la.mu.Unlock()
    la.outputs = append(la.outputs, output)
}

func (la *LogAggregator) Start() {
    la.wg.Add(1)
    go la.process()
}

func (la *LogAggregator) Stop() {
    close(la.done)
    la.wg.Wait()

    // åˆ·æ–°å‰©ä½™æ—¥å¿—
    la.flush()

    // å…³é—­æ‰€æœ‰è¾“å‡º
    for _, output := range la.outputs {
        output.Close()
    }
}

func (la *LogAggregator) Send(entry LogEntry) {
    select {
    case la.input <- entry:
    default:
        // ç¼“å†²åŒºæ»¡ï¼Œä¸¢å¼ƒæ—¥å¿—
        fmt.Printf("Log aggregator buffer full, dropping log entry\n")
    }
}

func (la *LogAggregator) process() {
    defer la.wg.Done()

    ticker := time.NewTicker(la.flushInterval)
    defer ticker.Stop()

    for {
        select {
        case entry := <-la.input:
            la.mu.Lock()
            la.buffer = append(la.buffer, entry)
            if len(la.buffer) >= la.batchSize {
                la.flush()
            }
            la.mu.Unlock()

        case <-ticker.C:
            la.mu.Lock()
            la.flush()
            la.mu.Unlock()

        case <-la.done:
            return
        }
    }
}

func (la *LogAggregator) flush() {
    if len(la.buffer) == 0 {
        return
    }

    // å¤åˆ¶ç¼“å†²åŒº
    entries := make([]LogEntry, len(la.buffer))
    copy(entries, la.buffer)
    la.buffer = la.buffer[:0]

    // å¼‚æ­¥å†™å…¥è¾“å‡º
    la.wg.Add(1)
    go func() {
        defer la.wg.Done()

        for _, output := range la.outputs {
            for _, entry := range entries {
                if err := output.Write(entry); err != nil {
                    fmt.Printf("Failed to write log entry: %v\n", err)
                }
            }
        }
    }()
}

// HTTPæ—¥å¿—è½¬å‘å™¨
type HTTPLogForwarder struct {
    endpoint string
    client   *http.Client
    batchSize int
    buffer   []LogEntry
    mu       sync.Mutex
}

func NewHTTPLogForwarder(endpoint string, batchSize int) *HTTPLogForwarder {
    return &HTTPLogForwarder{
        endpoint: endpoint,
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
        batchSize: batchSize,
        buffer:   make([]LogEntry, 0, batchSize),
    }
}

func (hf *HTTPLogForwarder) Write(entry LogEntry) error {
    hf.mu.Lock()
    defer hf.mu.Unlock()

    hf.buffer = append(hf.buffer, entry)

    if len(hf.buffer) >= hf.batchSize {
        return hf.flush()
    }

    return nil
}

func (hf *HTTPLogForwarder) flush() error {
    if len(hf.buffer) == 0 {
        return nil
    }

    data, err := json.Marshal(hf.buffer)
    if err != nil {
        return err
    }

    req, err := http.NewRequest("POST", hf.endpoint, bytes.NewBuffer(data))
    if err != nil {
        return err
    }
    req.Header.Set("Content-Type", "application/json")

    resp, err := hf.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode >= 400 {
        return fmt.Errorf("HTTP log forwarder returned status: %d", resp.StatusCode)
    }

    hf.buffer = hf.buffer[:0]
    return nil
}

func (hf *HTTPLogForwarder) Close() error {
    hf.mu.Lock()
    defer hf.mu.Unlock()
    return hf.flush()
}
```

### åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ

#### 1. è¿½è¸ªåŸºç¡€ç»“æ„

```go
// è¿½è¸ªä¸Šä¸‹æ–‡
type TraceContext struct {
    TraceID   string
    SpanID    string
    ParentID  string
    Sampled   bool
    Baggage   map[string]string
}

// Spanç±»å‹
type Span struct {
    TraceID    string
    SpanID     string
    ParentID   string
    Operation  string
    Start      time.Time
    Finish     time.Time
    Duration   time.Duration
    Tags       map[string]string
    Logs       []SpanLog
    References []SpanReference
}

type SpanLog struct {
    Timestamp time.Time
    Fields    map[string]interface{}
}

type SpanReference struct {
    RefType string
    TraceID string
    SpanID  string
}

// è¿½è¸ªå™¨æ¥å£
type Tracer interface {
    StartSpan(operation string, opts ...SpanOption) *Span
    Inject(context context.Context, carrier interface{}) error
    Extract(context context.Context, carrier interface{}) (TraceContext, error)
}

// Spané€‰é¡¹
type SpanOption func(*Span)

func WithParent(parent *Span) SpanOption {
    return func(s *Span) {
        s.ParentID = parent.SpanID
        s.TraceID = parent.TraceID
    }
}

func WithStartTime(start time.Time) SpanOption {
    return func(s *Span) {
        s.Start = start
    }
}

func WithTags(tags map[string]string) SpanOption {
    return func(s *Span) {
        if s.Tags == nil {
            s.Tags = make(map[string]string)
        }
        for k, v := range tags {
            s.Tags[k] = v
        }
    }
}

// Jaegerè¿½è¸ªå™¨å®ç°
type JaegerTracer struct {
    serviceName string
    endpoint    string
    buffer      chan *Span
    batchSize   int
    flushInterval time.Duration
    client      *http.Client
}

func NewJaegerTracer(serviceName, endpoint string) *JaegerTracer {
    return &JaegerTracer{
        serviceName: serviceName,
        endpoint:    endpoint,
        buffer:      make(chan *Span, 10000),
        batchSize:   100,
        flushInterval: 5 * time.Second,
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (jt *JaegerTracer) StartSpan(operation string, opts ...SpanOption) *Span {
    span := &Span{
        SpanID:    generateID(),
        Operation: operation,
        Start:     time.Now(),
        Tags:      make(map[string]string),
        Logs:      make([]SpanLog, 0),
    }

    // å¦‚æœæ²¡æœ‰çˆ¶Spanï¼Œç”Ÿæˆæ–°çš„TraceID
    span.TraceID = generateID()

    // åº”ç”¨é€‰é¡¹
    for _, opt := range opts {
        opt(span)
    }

    // è®¾ç½®é»˜è®¤æ ‡ç­¾
    span.Tags["component"] = jt.serviceName
    span.Tags["span.kind"] = "server"

    return span
}

func (jt *JaegerTracer) Inject(ctx context.Context, carrier interface{}) error {
    switch c := carrier.(type) {
    case http.Header:
        span := SpanFromContext(ctx)
        if span != nil {
            c.Set("X-Trace-Id", span.TraceID)
            c.Set("X-Span-Id", span.SpanID)
            if span.ParentID != "" {
                c.Set("X-Parent-Span-Id", span.ParentID)
            }
        }
    default:
        return fmt.Errorf("unsupported carrier type: %T", carrier)
    }
    return nil
}

func (jt *JaegerTracer) Extract(ctx context.Context, carrier interface{}) (TraceContext, error) {
    switch c := carrier.(type) {
    case http.Header:
        traceID := c.Get("X-Trace-Id")
        spanID := c.Get("X-Span-Id")
        parentID := c.Get("X-Parent-Span-Id")

        if traceID == "" || spanID == "" {
            return TraceContext{}, fmt.Errorf("missing tracing headers")
        }

        return TraceContext{
            TraceID:  traceID[0],
            SpanID:   spanID[0],
            ParentID: parentID[0],
        }, nil
    default:
        return TraceContext{}, fmt.Errorf("unsupported carrier type: %T", carrier)
    }
}

// ä¸Šä¸‹æ–‡ç®¡ç†
type contextKey struct{}

func ContextWithSpan(ctx context.Context, span *Span) context.Context {
    return context.WithValue(ctx, contextKey{}, span)
}

func SpanFromContext(ctx context.Context) *Span {
    span, _ := ctx.Value(contextKey{}).(*Span)
    return span
}

// ç”ŸæˆéšæœºID
func generateID() string {
    b := make([]byte, 16)
    if _, err := rand.Read(b); err != nil {
        return fmt.Sprintf("%016x", time.Now().UnixNano())
    }
    return hex.EncodeToString(b)
}
```

#### 2. é“¾è·¯è¿½è¸ªä¸­é—´ä»¶

```go
// HTTPè¿½è¸ªä¸­é—´ä»¶
func TraceMiddleware(tracer Tracer) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // å°è¯•æå–è¿½è¸ªä¸Šä¸‹æ–‡
            ctx, err := tracer.Extract(r.Context(), r.Header)
            if err != nil {
                // æ²¡æœ‰è¿½è¸ªä¸Šä¸‹æ–‡ï¼Œåˆ›å»ºæ–°çš„
                ctx = TraceContext{
                    TraceID: generateID(),
                    SpanID:  generateID(),
                    Sampled: true,
                }
            }

            // åˆ›å»ºSpan
            span := tracer.StartSpan(r.URL.Path,
                WithTags(map[string]string{
                    "http.method": r.Method,
                    "http.url":    r.URL.String(),
                    "component":   "http",
                }),
            )

            // æ³¨å…¥ä¸Šä¸‹æ–‡åˆ°å“åº”Writer
            wrappedWriter := &responseWriter{ResponseWriter: w, span: span}

            // å°†Spanæ”¾å…¥ä¸Šä¸‹æ–‡
            r = r.WithContext(ContextWithSpan(r.Context(), span))

            defer func() {
                span.Finish = time.Now()
                span.Duration = span.Finish.Sub(span.Start)

                // æ·»åŠ çŠ¶æ€ç æ ‡ç­¾
                if wrappedWriter.statusCode > 0 {
                    span.Tags["http.status_code"] = fmt.Sprintf("%d", wrappedWriter.statusCode)
                }

                // å‘é€Spanåˆ°è¿½è¸ªç³»ç»Ÿ
                if jt, ok := tracer.(*JaegerTracer); ok {
                    jt.buffer <- span
                }
            }()

            next.ServeHTTP(wrappedWriter, r)
        })
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
    span       *Span
}

func (rw *responseWriter) WriteHeader(statusCode int) {
    rw.statusCode = statusCode
    rw.ResponseWriter.WriteHeader(statusCode)
}

// æ•°æ®åº“è¿½è¸ªåŒ…è£…å™¨
type TracedDB struct {
    db    *sql.DB
    tracer Tracer
}

func NewTracedDB(db *sql.DB, tracer Tracer) *TracedDB {
    return &TracedDB{
        db:     db,
        tracer: tracer,
    }
}

func (tdb *TracedDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    span := tdb.tracer.StartSpan("db.query",
        WithTags(map[string]string{
            "db.type":     "sql",
            "db.statement": query,
            "db.user":     "user",
        }),
    )

    ctx = ContextWithSpan(ctx, span)
    defer func() {
        span.Finish = time.Now()
        span.Duration = span.Finish.Sub(span.Start)
    }()

    rows, err := tdb.db.QueryContext(ctx, query, args...)
    if err != nil {
        span.Tags["error"] = "true"
        span.Logs = append(span.Logs, SpanLog{
            Timestamp: time.Now(),
            Fields: map[string]interface{}{
                "event":   "error",
                "message": err.Error(),
            },
        })
    }

    return rows, err
}

func (tdb *TracedDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    span := tdb.tracer.StartSpan("db.exec",
        WithTags(map[string]string{
            "db.type":     "sql",
            "db.statement": query,
            "db.user":     "user",
        }),
    )

    ctx = ContextWithSpan(ctx, span)
    defer func() {
        span.Finish = time.Now()
        span.Duration = span.Finish.Sub(span.Start)
    }()

    result, err := tdb.db.ExecContext(ctx, query, args...)
    if err != nil {
        span.Tags["error"] = "true"
        span.Logs = append(span.Logs, SpanLog{
            Timestamp: time.Now(),
            Fields: map[string]interface{}{
                "event":   "error",
                "message": err.Error(),
            },
        })
    }

    return result, err
}
```

### å‘Šè­¦ç³»ç»Ÿ

#### 1. å‘Šè­¦è§„åˆ™å¼•æ“

```go
// å‘Šè­¦çº§åˆ«
type AlertLevel int

const (
    InfoAlert AlertLevel = iota
    WarningAlert
    CriticalAlert
    EmergencyAlert
)

// å‘Šè­¦çŠ¶æ€
type AlertStatus int

const (
    AlertFiring AlertStatus = iota
    AlertResolved
    AlertSuppressed
)

// å‘Šè­¦è§„åˆ™
type AlertRule struct {
    ID          string
    Name        string
    Expression  string
    Duration    time.Duration
    Labels      map[string]string
    Annotations map[string]string
    Level       AlertLevel
    Enabled     bool
}

// å‘Šè­¦äº‹ä»¶
type AlertEvent struct {
    RuleID      string
    RuleName    string
    Level       AlertLevel
    Status      AlertStatus
    Value       float64
    Labels      map[string]string
    Annotations map[string]string
    Timestamp   time.Time
}

// å‘Šè­¦è¯„ä¼°å™¨
type AlertEvaluator struct {
    rules      map[string]*AlertRule
    metricsDB  TimeSeriesDB
    alerts     map[string]*AlertState
    dispatcher *AlertDispatcher
    mu         sync.RWMutex
}

type AlertState struct {
    Rule        *AlertRule
    LastValue   float64
    LastCheck   time.Time
    Status      AlertStatus
    FiredAt     time.Time
    ResolvedAt  time.Time
    ActiveSince time.Time
}

func NewAlertEvaluator(metricsDB TimeSeriesDB, dispatcher *AlertDispatcher) *AlertEvaluator {
    return &AlertEvaluator{
        rules:      make(map[string]*AlertRule),
        metricsDB:  metricsDB,
        alerts:     make(map[string]*AlertState),
        dispatcher: dispatcher,
    }
}

func (ae *AlertEvaluator) AddRule(rule *AlertRule) {
    ae.mu.Lock()
    defer ae.mu.Unlock()
    ae.rules[rule.ID] = rule
}

func (ae *AlertEvaluator) RemoveRule(ruleID string) {
    ae.mu.Lock()
    defer ae.mu.Unlock()
    delete(ae.rules, ruleID)
}

func (ae *AlertEvaluator) EvaluateAll() {
    ae.mu.RLock()
    rules := make([]*AlertRule, 0, len(ae.rules))
    for _, rule := range ae.rules {
        if rule.Enabled {
            rules = append(rules, rule)
        }
    }
    ae.mu.RUnlock()

    for _, rule := range rules {
        ae.evaluateRule(rule)
    }
}

func (ae *AlertEvaluator) evaluateRule(rule *AlertRule) {
    // è§£æå’Œè¯„ä¼°è¡¨è¾¾å¼
    value, err := ae.evaluateExpression(rule.Expression)
    if err != nil {
        return
    }

    // è·å–æˆ–åˆ›å»ºå‘Šè­¦çŠ¶æ€
    ae.mu.Lock()
    state, exists := ae.alerts[rule.ID]
    if !exists {
        state = &AlertState{
            Rule:      rule,
            Status:    AlertResolved,
            LastCheck: time.Now(),
        }
        ae.alerts[rule.ID] = state
    }
    ae.mu.Unlock()

    // æ›´æ–°çŠ¶æ€
    state.LastValue = value
    state.LastCheck = time.Now()

    // åˆ¤æ–­å‘Šè­¦æ¡ä»¶
    shouldFire := ae.shouldFire(rule, value)
    shouldResolve := !shouldFire && state.Status == AlertFiring

    if shouldFire && state.Status != AlertFiring {
        // è§¦å‘å‘Šè­¦
        state.Status = AlertFiring
        state.FiredAt = time.Now()
        state.ActiveSince = time.Now()

        event := &AlertEvent{
            RuleID:      rule.ID,
            RuleName:    rule.Name,
            Level:       rule.Level,
            Status:      AlertFiring,
            Value:       value,
            Labels:      rule.Labels,
            Annotations: rule.Annotations,
            Timestamp:   time.Now(),
        }

        ae.dispatcher.Dispatch(event)

    } else if shouldResolve && state.Status == AlertFiring {
        // è§£å†³å‘Šè­¦
        state.Status = AlertResolved
        state.ResolvedAt = time.Now()

        event := &AlertEvent{
            RuleID:      rule.ID,
            RuleName:    rule.Name,
            Level:       rule.Level,
            Status:      AlertResolved,
            Value:       value,
            Labels:      rule.Labels,
            Annotations: rule.Annotations,
            Timestamp:   time.Now(),
        }

        ae.dispatcher.Dispatch(event)
    }
}

func (ae *AlertEvaluator) evaluateExpression(expression string) (float64, error) {
    // ç®€åŒ–çš„è¡¨è¾¾å¼è§£æ
    // å®é™…å®ç°å¯ä»¥ä½¿ç”¨å®Œæ•´çš„è¡¨è¾¾å¼è§£æå™¨
    if strings.Contains(expression, ">") {
        parts := strings.Split(expression, ">")
        if len(parts) == 2 {
            metricName := strings.TrimSpace(parts[0])
            threshold, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
            if err != nil {
                return 0, err
            }

            value, err := ae.metricsDB.QueryInstant(metricName, time.Now())
            if err != nil {
                return 0, err
            }
            return value, nil
        }
    }

    return 0, fmt.Errorf("unsupported expression: %s", expression)
}

func (ae *AlertEvaluator) shouldFire(rule *AlertRule, value float64) bool {
    // ç®€åŒ–çš„æ¡ä»¶åˆ¤æ–­
    if strings.Contains(rule.Expression, ">") {
        parts := strings.Split(rule.Expression, ">")
        if len(parts) == 2 {
            threshold, _ := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
            return value > threshold
        }
    }
    return false
}
```

#### 2. å‘Šè­¦åˆ†å‘å™¨

```go
// å‘Šè­¦é€šçŸ¥å™¨æ¥å£
type AlertNotifier interface {
    Send(event *AlertEvent) error
    Name() string
}

// é‚®ä»¶é€šçŸ¥å™¨
type EmailNotifier struct {
    smtpHost     string
    smtpPort     int
    username     string
    password     string
    fromAddress  string
    toAddresses  []string
    client       *smtp.Client
}

func NewEmailNotifier(smtpHost string, smtpPort int, username, password, from string, to []string) *EmailNotifier {
    return &EmailNotifier{
        smtpHost:    smtpHost,
        smtpPort:    smtpPort,
        username:    username,
        password:    password,
        fromAddress: from,
        toAddresses: to,
    }
}

func (en *EmailNotifier) Send(event *AlertEvent) error {
    if en.client == nil {
        conn, err := smtp.Dial(fmt.Sprintf("%s:%d", en.smtpHost, en.smtpPort))
        if err != nil {
            return err
        }
        en.client = conn
    }

    subject := fmt.Sprintf("[ALERT] %s - %s", event.Level, event.RuleName)
    body := en.formatEmailBody(event)

    // è®¾ç½®é‚®ä»¶å¤´
    en.client.Mail(en.fromAddress)
    for _, to := range en.toAddresses {
        en.client.Rcpt(to)
    }

    // å‘é€é‚®ä»¶å†…å®¹
    wc, err := en.client.Data()
    if err != nil {
        return err
    }
    defer wc.Close()

    // å†™å…¥é‚®ä»¶å¤´
    fmt.Fprintf(wc, "From: %s\r\n", en.fromAddress)
    fmt.Fprintf(wc, "To: %s\r\n", strings.Join(en.toAddresses, ","))
    fmt.Fprintf(wc, "Subject: %s\r\n", subject)
    fmt.Fprintf(wc, "MIME-Version: 1.0\r\n")
    fmt.Fprintf(wc, "Content-Type: text/html; charset=UTF-8\r\n")
    fmt.Fprintf(wc, "\r\n")

    // å†™å…¥é‚®ä»¶æ­£æ–‡
    _, err = fmt.Fprint(wc, body)
    return err
}

func (en *EmailNotifier) formatEmailBody(event *AlertEvent) string {
    status := "FIRED"
    if event.Status == AlertResolved {
        status = "RESOLVED"
    }

    color := "#dc3545" // çº¢è‰²
    if event.Status == AlertResolved {
        color = "#28a745" // ç»¿è‰²
    }

    return fmt.Sprintf(`
    <html>
    <body>
        <h2 style="color: %s;">Alert %s</h2>
        <table border="1" style="border-collapse: collapse;">
            <tr><td><strong>Rule:</strong></td><td>%s</td></tr>
            <tr><td><strong>Status:</strong></td><td>%s</td></tr>
            <tr><td><strong>Level:</strong></td><td>%s</td></tr>
            <tr><td><strong>Value:</strong></td><td>%.2f</td></tr>
            <tr><td><strong>Time:</strong></td><td>%s</td></tr>
        </table>
        %s
    </body>
    </html>
    `, color, status, event.RuleName, status, event.Level, event.Value,
        event.Timestamp.Format(time.RFC3339), en.formatAnnotations(event.Annotations))
}

func (en *EmailNotifier) formatAnnotations(annotations map[string]string) string {
    if len(annotations) == 0 {
        return ""
    }

    var result string
    result += "<h3>Annotations:</h3>"
    result += "<ul>"
    for k, v := range annotations {
        result += fmt.Sprintf("<li><strong>%s:</strong> %s</li>", k, v)
    }
    result += "</ul>"
    return result
}

func (en *EmailNotifier) Name() string {
    return "email"
}

// Slacké€šçŸ¥å™¨
type SlackNotifier struct {
    webhookURL string
    client     *http.Client
}

func NewSlackNotifier(webhookURL string) *SlackNotifier {
    return &SlackNotifier{
        webhookURL: webhookURL,
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (sn *SlackNotifier) Send(event *AlertEvent) error {
    message := sn.formatSlackMessage(event)

    payload := map[string]interface{}{
        "text":        message,
        "attachments": []map[string]interface{}{sn.formatAttachment(event)},
    }

    data, err := json.Marshal(payload)
    if err != nil {
        return err
    }

    resp, err := sn.client.Post(sn.webhookURL, "application/json", bytes.NewBuffer(data))
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("slack webhook returned status: %d", resp.StatusCode)
    }

    return nil
}

func (sn *SlackNotifier) formatSlackMessage(event *AlertEvent) string {
    status := "ğŸ”¥ FIRED"
    if event.Status == AlertResolved {
        status = "âœ… RESOLVED"
    }

    emoji := "ğŸš¨"
    if event.Status == AlertResolved {
        emoji = "âœ…"
    }

    return fmt.Sprintf("%s *%s* - %s", emoji, status, event.RuleName)
}

func (sn *SlackNotifier) formatAttachment(event *AlertEvent) map[string]interface{} {
    color := "#dc3545" // çº¢è‰²
    if event.Status == AlertResolved {
        color = "#28a745" // ç»¿è‰²
    }

    fields := []map[string]interface{}{
        {"title": "Level", "value": event.Level.String(), "short": true},
        {"title": "Value", "value": fmt.Sprintf("%.2f", event.Value), "short": true},
        {"title": "Time", "value": event.Timestamp.Format(time.RFC3339), "short": false},
    }

    // æ·»åŠ æ ‡ç­¾
    if len(event.Labels) > 0 {
        labels := ""
        for k, v := range event.Labels {
            labels += fmt.Sprintf("%s: %s\n", k, v)
        }
        fields = append(fields, map[string]interface{}{
            "title": "Labels", "value": labels, "short": false,
        })
    }

    // æ·»åŠ æ³¨é‡Š
    if len(event.Annotations) > 0 {
        annotations := ""
        for k, v := range event.Annotations {
            annotations += fmt.Sprintf("%s: %s\n", k, v)
        }
        fields = append(fields, map[string]interface{}{
            "title": "Annotations", "value": annotations, "short": false,
        })
    }

    return map[string]interface{}{
        "color":  color,
        "fields": fields,
    }
}

func (sn *SlackNotifier) Name() string {
    return "slack"
}

// å‘Šè­¦åˆ†å‘å™¨
type AlertDispatcher struct {
    notifiers []AlertNotifier
    mu        sync.RWMutex
}

func NewAlertDispatcher() *AlertDispatcher {
    return &AlertDispatcher{
        notifiers: make([]AlertNotifier, 0),
    }
}

func (ad *AlertDispatcher) AddNotifier(notifier AlertNotifier) {
    ad.mu.Lock()
    defer ad.mu.Unlock()
    ad.notifiers = append(ad.notifiers, notifier)
}

func (ad *AlertDispatcher) RemoveNotifier(name string) {
    ad.mu.Lock()
    defer ad.mu.Unlock()

    for i, notifier := range ad.notifiers {
        if notifier.Name() == name {
            ad.notifiers = append(ad.notifiers[:i], ad.notifiers[i+1:]...)
            break
        }
    }
}

func (ad *AlertDispatcher) Dispatch(event *AlertEvent) {
    ad.mu.RLock()
    notifiers := make([]AlertNotifier, len(ad.notifiers))
    copy(notifiers, ad.notifiers)
    ad.mu.RUnlock()

    // å¼‚æ­¥å‘é€é€šçŸ¥
    for _, notifier := range notifiers {
        go func(n AlertNotifier) {
            if err := n.Send(event); err != nil {
                fmt.Printf("Failed to send alert via %s: %v\n", n.Name(), err)
            }
        }(notifier)
    }
}
```

### å®Œæ•´çš„å¯è§‚æµ‹æ€§å¹³å°

```go
// å¯è§‚æµ‹æ€§å¹³å°
type ObservabilityPlatform struct {
    metricsCollector *MetricsCollector
    logger          *Logger
    tracer          *JaegerTracer
    alertEvaluator  *AlertEvaluator
    alertDispatcher *AlertDispatcher
    config          *ObservabilityConfig
}

type ObservabilityConfig struct {
    Metrics struct {
        Enabled    bool
        Port       int
        Exporters  []string
    }
    Logging struct {
        Level      string
        Outputs    []LogOutput
    }
    Tracing struct {
        Enabled    bool
        Service    string
        Endpoint   string
    }
    Alerting struct {
        Enabled    bool
        Rules      []*AlertRule
    }
}

func NewObservabilityPlatform(config *ObservabilityConfig) *ObservabilityPlatform {
    // åˆå§‹åŒ–æŒ‡æ ‡æ”¶é›†å™¨
    metricsCollector := NewMetricsCollector()

    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    logger := NewLogger("observability", InfoLevel)
    for _, output := range config.Logging.Outputs {
        logger.AddOutput(output)
    }

    // åˆå§‹åŒ–è¿½è¸ªç³»ç»Ÿ
    var tracer *JaegerTracer
    if config.Tracing.Enabled {
        tracer = NewJaegerTracer(config.Tracing.Service, config.Tracing.Endpoint)
    }

    // åˆå§‹åŒ–å‘Šè­¦ç³»ç»Ÿ
    var alertEvaluator *AlertEvaluator
    var alertDispatcher *AlertDispatcher
    if config.Alerting.Enabled {
        alertDispatcher = NewAlertDispatcher()
        alertEvaluator = NewAlertEvaluator(metricsCollector.db, alertDispatcher)

        // æ·»åŠ å‘Šè­¦è§„åˆ™
        for _, rule := range config.Alerting.Rules {
            alertEvaluator.AddRule(rule)
        }
    }

    return &ObservabilityPlatform{
        metricsCollector: metricsCollector,
        logger:          logger,
        tracer:          tracer,
        alertEvaluator:  alertEvaluator,
        alertDispatcher: alertDispatcher,
        config:          config,
    }
}

func (op *ObservabilityPlatform) Start() {
    // å¯åŠ¨æŒ‡æ ‡å¯¼å‡º
    if op.config.Metrics.Enabled {
        go op.startMetricsServer()
    }

    // å¯åŠ¨å‘Šè­¦è¯„ä¼°
    if op.config.Alerting.Enabled {
        go op.startAlertEvaluation()
    }

    op.logger.Info("Observability platform started", map[string]interface{}{
        "metrics_enabled": op.config.Metrics.Enabled,
        "tracing_enabled": op.config.Tracing.Enabled,
        "alerting_enabled": op.config.Alerting.Enabled,
    })
}

func (op *ObservabilityPlatform) startMetricsServer() {
    mux := http.NewServeMux()
    mux.HandleFunc("/metrics", op.handleMetricsRequest)
    mux.HandleFunc("/health", op.handleHealthRequest)

    server := &http.Server{
        Addr:    fmt.Sprintf(":%d", op.config.Metrics.Port),
        Handler: mux,
    }

    op.logger.Info("Starting metrics server", map[string]interface{}{
        "port": op.config.Metrics.Port,
    })

    if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        op.logger.Error("Metrics server failed", map[string]interface{}{
            "error": err.Error(),
        })
    }
}

func (op *ObservabilityPlatform) startAlertEvaluation() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        op.alertEvaluator.EvaluateAll()
    }
}

func (op *ObservabilityPlatform) handleMetricsRequest(w http.ResponseWriter, r *http.Request) {
    metrics := op.metricsCollector.CollectAll()

    var lines []string
    for _, metric := range metrics {
        line := op.formatMetric(metric)
        lines = append(lines, line)
    }

    w.Header().Set("Content-Type", "text/plain; version=0.0.4")
    fmt.Fprintln(w, strings.Join(lines, "\n"))
}

func (op *ObservabilityPlatform) formatMetric(metric Metric) string {
    var labels []string
    for k, v := range metric.Labels {
        labels = append(labels, fmt.Sprintf("%s=\"%s\"", k, v))
    }

    labelStr := ""
    if len(labels) > 0 {
        labelStr = fmt.Sprintf("{%s}", strings.Join(labels, ","))
    }

    return fmt.Sprintf("%s%s %f %d", metric.Name, labelStr, metric.Value, metric.Timestamp.Unix())
}

func (op *ObservabilityPlatform) handleHealthRequest(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
}

// HTTPä¸­é—´ä»¶é›†æˆ
func (op *ObservabilityPlatform) Middleware() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // æ·»åŠ è¿½è¸ª
            if op.config.Tracing.Enabled {
                span := op.tracer.StartSpan(r.URL.Path,
                    WithTags(map[string]string{
                        "http.method": r.Method,
                        "http.url":    r.URL.String(),
                    }),
                )
                defer func() {
                    span.Finish = time.Now()
                    span.Duration = span.Finish.Sub(span.Start)
                }()

                r = r.WithContext(ContextWithSpan(r.Context(), span))
            }

            // åŒ…è£…ResponseWriterä»¥è®°å½•çŠ¶æ€ç 
            wrappedWriter := &responseWriter{ResponseWriter: w}
            start := time.Now()

            defer func() {
                duration := time.Since(start)

                // è®°å½•æŒ‡æ ‡
                op.metricsCollector.RecordHTTPRequest(r.Method, r.URL.Path, wrappedWriter.statusCode, duration)

                // è®°å½•æ—¥å¿—
                op.logger.Info("HTTP request", map[string]interface{}{
                    "method":     r.Method,
                    "path":       r.URL.Path,
                    "status":     wrappedWriter.statusCode,
                    "duration":   duration.String(),
                    "user_agent": r.UserAgent(),
                })
            }()

            next.ServeHTTP(wrappedWriter, r)
        })
    }
}
```

### å®è·µé¡¹ç›®ï¼šæ„å»ºåˆ†å¸ƒå¼ç›‘æ§ç³»ç»Ÿ

#### 1. é¡¹ç›®ç»“æ„

```
monitoring-platform/
â”œâ”€â”€ main.go
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.go
â”œâ”€â”€ metrics/
â”‚   â”œâ”€â”€ collector.go
â”‚   â”œâ”€â”€ storage.go
â”‚   â””â”€â”€ exporter.go
â”œâ”€â”€ logging/
â”‚   â”œâ”€â”€ logger.go
â”‚   â”œâ”€â”€ formatters.go
â”‚   â””â”€â”€ outputs.go
â”œâ”€â”€ tracing/
â”‚   â”œâ”€â”€ tracer.go
â”‚   â””â”€â”€ middleware.go
â”œâ”€â”€ alerting/
â”‚   â”œâ”€â”€ rules.go
â”‚   â”œâ”€â”€ evaluator.go
â”‚   â””â”€â”€ notifiers.go
â”œâ”€â”€ dashboard/
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ static/
â””â”€â”€ api/
    â””â”€â”€ api.go
```

#### 2. é…ç½®ç®¡ç†

```go
// config/config.go
package config

import (
    "encoding/json"
    "os"
    "time"
)

type Config struct {
    Server struct {
        Port     int    `json:"port"`
        LogLevel string `json:"log_level"`
    } `json:"server"`

    Metrics struct {
        Enabled  bool     `json:"enabled"`
        Port     int      `json:"port"`
        Interval Duration `json:"interval"`
        Storage  struct {
            Type     string `json:"type"`
            Endpoint string `json:"endpoint"`
        } `json:"storage"`
    } `json:"metrics"`

    Logging struct {
        Level   string `json:"level"`
        Outputs []struct {
            Type   string `json:"type"`
            Params map[string]interface{} `json:"params"`
        } `json:"outputs"`
    } `json:"logging"`

    Tracing struct {
        Enabled  bool   `json:"enabled"`
        Service  string `json:"service"`
        Endpoint string `json:"endpoint"`
    } `json:"tracing"`

    Alerting struct {
        Enabled bool          `json:"enabled"`
        Rules   []*AlertRule  `json:"rules"`
        Notifiers []struct {
            Type   string                 `json:"type"`
            Params map[string]interface{} `json:"params"`
        } `json:"notifiers"`
    } `json:"alerting"`
}

type AlertRule struct {
    ID          string            `json:"id"`
    Name        string            `json:"name"`
    Expression  string            `json:"expression"`
    Duration    Duration          `json:"duration"`
    Labels      map[string]string `json:"labels"`
    Annotations map[string]string `json:"annotations"`
    Level       string            `json:"level"`
    Enabled     bool              `json:"enabled"`
}

type Duration struct {
    time.Duration
}

func (d *Duration) UnmarshalJSON(data []byte) error {
    var s string
    if err := json.Unmarshal(data, &s); err != nil {
        return err
    }

    duration, err := time.ParseDuration(s)
    if err != nil {
        return err
    }

    d.Duration = duration
    return nil
}

func LoadConfig(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }

    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, err
    }

    // è®¾ç½®é»˜è®¤å€¼
    if config.Server.Port == 0 {
        config.Server.Port = 8080
    }
    if config.Server.LogLevel == "" {
        config.Server.LogLevel = "info"
    }
    if config.Metrics.Interval.Duration == 0 {
        config.Metrics.Interval.Duration = 15 * time.Second
    }

    return &config, nil
}
```

#### 3. ä¸»ç¨‹åº

```go
// main.go
package main

import (
    "flag"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"

    "github.com/prometheus/client_golang/prometheus/promhttp"
    "monitoring-platform/config"
    "monitoring-platform/metrics"
    "monitoring-platform/logging"
    "monitoring-platform/tracing"
    "monitoring-platform/alerting"
)

func main() {
    configPath := flag.String("config", "config.json", "Configuration file path")
    flag.Parse()

    // åŠ è½½é…ç½®
    cfg, err := config.LoadConfig(*configPath)
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    logger := logging.NewLogger("monitoring", logging.InfoLevel)

    // åˆå§‹åŒ–æ—¥å¿—è¾“å‡º
    for _, outputCfg := range cfg.Logging.Outputs {
        switch outputCfg.Type {
        case "file":
            filename := outputCfg.Params["filename"].(string)
            output, err := logging.NewFileOutput(filename)
            if err != nil {
                log.Fatalf("Failed to create file output: %v", err)
            }
            logger.AddOutput(output)
        case "console":
            formatter := &logging.JSONFormatter{}
            output := logging.NewConsoleOutput(formatter)
            logger.AddOutput(output)
        }
    }

    // åˆå§‹åŒ–æŒ‡æ ‡ç³»ç»Ÿ
    metricsCollector := metrics.NewCollector()

    // åˆå§‹åŒ–è¿½è¸ªç³»ç»Ÿ
    var tracer *tracing.JaegerTracer
    if cfg.Tracing.Enabled {
        tracer = tracing.NewJaegerTracer(cfg.Tracing.Service, cfg.Tracing.Endpoint)
    }

    // åˆå§‹åŒ–å‘Šè­¦ç³»ç»Ÿ
    var alertManager *alerting.Manager
    if cfg.Alerting.Enabled {
        alertManager = alerting.NewManager()

        // æ·»åŠ å‘Šè­¦è§„åˆ™
        for _, ruleCfg := range cfg.Alerting.Rules {
            rule := &alerting.Rule{
                ID:          ruleCfg.ID,
                Name:        ruleCfg.Name,
                Expression:  ruleCfg.Expression,
                Duration:    ruleCfg.Duration.Duration,
                Labels:      ruleCfg.Labels,
                Annotations: ruleCfg.Annotations,
                Level:       alerting.LevelFromString(ruleCfg.Level),
                Enabled:     ruleCfg.Enabled,
            }
            alertManager.AddRule(rule)
        }

        // æ·»åŠ é€šçŸ¥å™¨
        for _, notifierCfg := range cfg.Alerting.Notifiers {
            switch notifierCfg.Type {
            case "email":
                emailParams := notifierCfg.Params
                notifier := alerting.NewEmailNotifier(
                    emailParams["smtp_host"].(string),
                    int(emailParams["smtp_port"].(float64)),
                    emailParams["username"].(string),
                    emailParams["password"].(string),
                    emailParams["from"].(string),
                    emailParams["to"].([]string),
                )
                alertManager.AddNotifier(notifier)
            case "slack":
                slackParams := notifierCfg.Params
                notifier := alerting.NewSlackNotifier(slackParams["webhook_url"].(string))
                alertManager.AddNotifier(notifier)
            }
        }

        alertManager.Start()
    }

    // è®¾ç½®HTTPè·¯ç”±
    mux := http.NewServeMux()

    // æŒ‡æ ‡ç«¯ç‚¹
    mux.Handle("/metrics", promhttp.Handler())

    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        fmt.Fprintln(w, `{"status": "healthy"}`)
    })

    // æŒ‡æ ‡æŸ¥è¯¢API
    mux.HandleFunc("/api/v1/query", func(w http.ResponseWriter, r *http.Request) {
        query := r.URL.Query().Get("query")
        if query == "" {
            http.Error(w, "Missing query parameter", http.StatusBadRequest)
            return
        }

        result, err := metricsCollector.Query(query)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result)
    })

    // å‘Šè­¦çŠ¶æ€API
    mux.HandleFunc("/api/v1/alerts", func(w http.ResponseWriter, r *http.Request) {
        if alertManager == nil {
            http.Error(w, "Alerting not enabled", http.StatusNotFound)
            return
        }

        alerts := alertManager.GetAlerts()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(alerts)
    })

    // å¯åŠ¨HTTPæœåŠ¡å™¨
    server := &http.Server{
        Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
        Handler: mux,
    }

    go func() {
        logger.Info("Starting monitoring platform", map[string]interface{}{
            "port": cfg.Server.Port,
        })
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            logger.Error("Server failed", map[string]interface{}{
                "error": err.Error(),
            })
            os.Exit(1)
        }
    }()

    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    logger.Info("Shutting down monitoring platform...")

    // ä¼˜é›…å…³é—­
    if alertManager != nil {
        alertManager.Stop()
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := server.Shutdown(ctx); err != nil {
        logger.Error("Server shutdown failed", map[string]interface{}{
            "error": err.Error(),
        })
    }

    logger.Info("Monitoring platform stopped")
}
```

## ç»ƒä¹ é¢˜

### æ¦‚å¿µé¢˜

1. **å¯è§‚æµ‹æ€§**ï¼šè§£é‡Šå¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±ï¼ˆæŒ‡æ ‡ã€æ—¥å¿—ã€è¿½è¸ªï¼‰çš„å…³ç³»å’ŒåŒºåˆ«ã€‚

2. **ç›‘æ§æŒ‡æ ‡**ï¼šæ¯”è¾ƒREDã€USEã€é»„é‡‘ä¿¡å·ç­‰ä¸åŒçš„ç›‘æ§æŒ‡æ ‡ä½“ç³»ã€‚

3. **åˆ†å¸ƒå¼è¿½è¸ª**ï¼šè§£é‡ŠOpenTelemetryå¦‚ä½•ç»Ÿä¸€è¿½è¸ªæ ‡å‡†ã€‚

4. **å‘Šè­¦ç­–ç•¥**ï¼šå¦‚ä½•è®¾è®¡æœ‰æ•ˆçš„å‘Šè­¦è§„åˆ™å’Œé€šçŸ¥ç­–ç•¥ï¼Ÿ

### ç¼–ç¨‹é¢˜

1. **è‡ªå®šä¹‰æŒ‡æ ‡**ï¼šå®ç°ä¸€ä¸ªè‡ªå®šä¹‰çš„æŒ‡æ ‡æ”¶é›†å™¨ï¼Œç›‘æ§ç‰¹å®šçš„ä¸šåŠ¡æŒ‡æ ‡ã€‚

2. **æ—¥å¿—åˆ†æ**ï¼šå®ç°ä¸€ä¸ªæ—¥å¿—åˆ†æå™¨ï¼Œæå–å…³é”®ä¿¡æ¯å¹¶ç”ŸæˆæŠ¥å‘Šã€‚

3. **é“¾è·¯è¿½è¸ª**ï¼šä¸ºç°æœ‰åº”ç”¨æ·»åŠ å®Œæ•´çš„åˆ†å¸ƒå¼è¿½è¸ªæ”¯æŒã€‚

4. **æ™ºèƒ½å‘Šè­¦**ï¼šå®ç°åŸºäºæœºå™¨å­¦ä¹ çš„å¼‚å¸¸æ£€æµ‹å‘Šè­¦ç³»ç»Ÿã€‚

### è®¾è®¡é¢˜

1. **å¤§è§„æ¨¡ç›‘æ§**ï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒå¤§è§„æ¨¡é›†ç¾¤çš„ç›‘æ§æ¶æ„ã€‚

2. **å¤šç§Ÿæˆ·ç›‘æ§**ï¼šè®¾è®¡æ”¯æŒå¤šç§Ÿæˆ·çš„ç›‘æ§ç³»ç»Ÿã€‚

3. **å®æ—¶ç›‘æ§**ï¼šè®¾è®¡å®æ—¶ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿã€‚

4. **æˆæœ¬ä¼˜åŒ–**ï¼šä¼˜åŒ–ç›‘æ§ç³»ç»Ÿçš„å­˜å‚¨å’Œè®¡ç®—æˆæœ¬ã€‚

## å¸¸è§é—®é¢˜

### Q: å¦‚ä½•å¹³è¡¡ç›‘æ§ç²¾åº¦å’Œæ€§èƒ½å¼€é”€ï¼Ÿ

A: é‡‡ç”¨åˆ†çº§ç›‘æ§ç­–ç•¥ï¼š
- **å…³é”®æŒ‡æ ‡**ï¼šé«˜é¢‘é‡‡é›†ï¼Œä½å»¶è¿Ÿ
- **ä¸€èˆ¬æŒ‡æ ‡**ï¼šä¸­é¢‘é‡‡é›†ï¼Œé€‚åº¦å»¶è¿Ÿ
- **è°ƒè¯•æŒ‡æ ‡**ï¼šä½é¢‘é‡‡é›†ï¼Œé«˜å»¶è¿Ÿ
- **é‡‡æ ·ç­–ç•¥**ï¼šå¯¹é«˜æµé‡è¿›è¡Œé‡‡æ ·

### Q: å¦‚ä½•å¤„ç†ç›‘æ§æ•°æ®çš„æµ·é‡å­˜å‚¨ï¼Ÿ

A: é‡‡ç”¨æ•°æ®åˆ†å±‚å’Œå‹ç¼©ç­–ç•¥ï¼š
- **çƒ­æ•°æ®**ï¼šé«˜å¯ç”¨ï¼Œå¿«é€ŸæŸ¥è¯¢
- **æ¸©æ•°æ®**ï¼šå‹ç¼©å­˜å‚¨ï¼Œæˆæœ¬ä¼˜åŒ–
- **å†·æ•°æ®**ï¼šå½’æ¡£å­˜å‚¨ï¼Œä½æˆæœ¬
- **æ•°æ®èšåˆ**ï¼šå®šæœŸèšåˆï¼Œå‡å°‘å­˜å‚¨

### Q: å¦‚ä½•é¿å…å‘Šè­¦ç–²åŠ³ï¼Ÿ

A: å®æ–½å‘Šè­¦ä¼˜åŒ–ç­–ç•¥ï¼š
- **å‘Šè­¦åˆ†çº§**ï¼šåŒºåˆ†ä¸¥é‡ç¨‹åº¦
- **å‘Šè­¦æ”¶æ•›**ï¼šåˆå¹¶ç›¸å…³å‘Šè­¦
- **é™é»˜è§„åˆ™**ï¼šè®¾ç½®ç»´æŠ¤çª—å£
- **æ™ºèƒ½è¿‡æ»¤**ï¼šåŸºäºä¸Šä¸‹æ–‡è¿‡æ»¤

## æ‰©å±•èµ„æº

### å¿…è¯»è®ºæ–‡

1. **[Dapper, a Large-Scale Distributed Systems Tracing Infrastructure](https://research.google/pubs/pub36356/)** - Googleåˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ
2. **[The Log-Structured Merge-Tree](https://www.cs.umb.edu/~poneil/lsmtree.pdf)** - LSMæ ‘å­˜å‚¨å¼•æ“
3. **[Prometheus: A Next-Generation Monitoring System](https://scholar.google.com/scholar?cluster=12035751645957450735)** - Prometheusç›‘æ§ç³»ç»Ÿ

### å®è·µé¡¹ç›®

1. **[Prometheus](https://prometheus.io/)** - å¼€æºç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ
2. **[Grafana](https://grafana.com/)** - å¼€æºå¯è§†åŒ–å¹³å°
3. **[Jaeger](https://www.jaegertracing.io/)** - å¼€æºåˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ
4. **[Fluentd](https://www.fluentd.org/)** - å¼€æºæ—¥å¿—æ”¶é›†å™¨

### åœ¨çº¿è¯¾ç¨‹

1. **[Monitoring Distributed Systems](https://www.coursera.org/learn/monitoring-distributed-systems)** - åˆ†å¸ƒå¼ç³»ç»Ÿç›‘æ§è¯¾ç¨‹
2. **[Observability in Cloud Native](https://www.linuxfoundation.org/resources/blog/observability-cloud-native/)** - äº‘åŸç”Ÿå¯è§‚æµ‹æ€§
3. **[SRE Fundamentals](https://sre.google/sre-book/table-of-contents/)** - SREåŸºç¡€ä¹¦ç±

## ä¸‹ä¸€æ­¥å­¦ä¹ 

åœ¨æŒæ¡å¯è§‚æµ‹æ€§æŠ€æœ¯åï¼Œä½ å¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1. **AIOps**ï¼šäººå·¥æ™ºèƒ½è¿ç»´å’Œè‡ªåŠ¨åŒ–
2. **æ··æ²Œå·¥ç¨‹**ï¼šç³»ç»Ÿå¼¹æ€§å’Œæ•…éšœæ³¨å…¥
3. **Service Mesh**ï¼šæœåŠ¡ç½‘æ ¼å’Œæµé‡ç®¡ç†
4. **äº‘åŸç”Ÿç›‘æ§**ï¼šKuberneteså’Œå®¹å™¨åŒ–ç›‘æ§

---

*å¯è§‚æµ‹æ€§æ˜¯ç°ä»£åˆ†å¸ƒå¼ç³»ç»Ÿçš„å‘½è„‰ï¼Œé€šè¿‡å®Œå–„çš„ç›‘æ§ã€æ—¥å¿—å’Œè¿½è¸ªä½“ç³»ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ·±å…¥ç†è§£ç³»ç»Ÿè¡Œä¸ºï¼Œå¿«é€Ÿå®šä½é—®é¢˜ï¼Œä¿éšœç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯é æ€§ã€‚*