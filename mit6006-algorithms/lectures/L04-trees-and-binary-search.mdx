---
title: "L04 - æ ‘ä¸äºŒå‰æœç´¢"
description: "æ·±å…¥ç†è§£äºŒå‰æœç´¢æ ‘ã€å¹³è¡¡æ ‘å’ŒBæ ‘çš„å®ç°ä¸åº”ç”¨"
---

import { useState, useEffect } from 'react';
import { CodeBlock } from '@/src/components/algorithm';
import { AlgorithmVisualizer } from '@/src/components/algorithm';
import { TreeVisualizer } from '@/src/components/algorithm';
import { ArrayVisualizer } from '@/src/components/algorithm';
import { ComplexityAnalyzer } from '@/src/components/algorithm';
import { ExerciseBlock } from '@/src/components/algorithm';

# L04 - æ ‘ä¸äºŒå‰æœç´¢

## ğŸ“š å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è®²ä¹‰åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ğŸŒ³ **æŒæ¡æ ‘ç»“æ„åŸºç¡€**ï¼šç†è§£æ ‘çš„æœ¯è¯­ã€æ€§è´¨å’Œè¡¨ç¤ºæ–¹æ³•
- ğŸ” **ç²¾é€šBSTæ“ä½œ**ï¼šå®ç°æœç´¢ã€æ’å…¥ã€åˆ é™¤å’Œéå†
- âš–ï¸ **ç†è§£å¹³è¡¡ç­–ç•¥**ï¼šæŒæ¡AVLå’Œçº¢é»‘æ ‘çš„å¹³è¡¡æœºåˆ¶
- ğŸ“Š **åº”ç”¨Bæ ‘å®¶æ—**ï¼šäº†è§£Bæ ‘ã€B+æ ‘åœ¨æ•°æ®åº“ä¸­çš„åº”ç”¨

## ğŸ¯ æ ‘çš„åŸºç¡€æ¦‚å¿µ

### æ ‘çš„åŸºæœ¬æœ¯è¯­

| æœ¯è¯­ | å®šä¹‰ | ç¤ºä¾‹ | é‡è¦æ€§ |
|------|------|------|--------|
| **èŠ‚ç‚¹(Node)** | æ ‘çš„åŸºæœ¬å•ä½ | æ ¹èŠ‚ç‚¹ã€å¶å­èŠ‚ç‚¹ | æ•°æ®å­˜å‚¨ |
| **è¾¹(Edge)** | èŠ‚ç‚¹é—´çš„è¿æ¥å…³ç³» | çˆ¶å­å…³ç³» | ç»“æ„è¿æ¥ |
| **æ·±åº¦(Depth)** | æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ | æ ¹æ·±åº¦ä¸º0 | è·¯å¾„è®¡ç®— |
| **é«˜åº¦(Height)** | å½“å‰èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ | å¶å­é«˜åº¦ä¸º0 | å¹³è¡¡è®¡ç®— |
| **åº¦(Degree)** | èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ | äºŒå‰èŠ‚ç‚¹åº¦â‰¤2 | åˆ†æ”¯é™åˆ¶ |
| **å­æ ‘(Subtree)** | ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ | å·¦å­æ ‘ã€å³å­æ ‘ | é€’å½’ç»“æ„ |

### æ ‘çš„æ•°å­¦æ€§è´¨

```python
def tree_properties_analysis():
    """
    äºŒå‰æ ‘çš„æ•°å­¦æ€§è´¨åˆ†æ
    """
    properties = {
        "æœ€å¤§èŠ‚ç‚¹æ•°": "é«˜åº¦ä¸ºhçš„äºŒå‰æ ‘æœ€å¤šæœ‰2^(h+1) - 1ä¸ªèŠ‚ç‚¹",
        "å®Œç¾äºŒå‰æ ‘": "æ‰€æœ‰å±‚éƒ½å¡«æ»¡ï¼ŒèŠ‚ç‚¹æ•° = 2^(h+1) - 1",
        "å®Œå…¨äºŒå‰æ ‘": "é™¤æœ€åä¸€å±‚å¤–ï¼Œå…¶ä»–å±‚éƒ½å¡«æ»¡",
        "å¹³è¡¡äºŒå‰æ ‘": "ä»»æ„èŠ‚ç‚¹å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡1",
        "æ»¡äºŒå‰æ ‘": "æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰0æˆ–2ä¸ªå­èŠ‚ç‚¹"
    }

    for prop, desc in properties.items():
        print(f"{prop}: {desc}")

# è®¡ç®—æ ‘çš„å„ç§å±æ€§
def calculate_tree_stats(root):
    """è®¡ç®—æ ‘çš„ç»Ÿè®¡ä¿¡æ¯"""
    if not root:
        return {"nodes": 0, "height": -1, "leaves": 0}

    left_stats = calculate_tree_stats(root.left)
    right_stats = calculate_tree_stats(root.right)

    nodes = left_stats["nodes"] + right_stats["nodes"] + 1
    height = max(left_stats["height"], right_stats["height"]) + 1
    leaves = left_stats["leaves"] + right_stats["leaves"] if (root.left or root.right) else 1

    return {"nodes": nodes, "height": height, "leaves": leaves}
```

## ğŸ” äºŒå‰æœç´¢æ ‘ (BST)

### BSTæ ¸å¿ƒå®šä¹‰

**äºŒå‰æœç´¢æ ‘æ€§è´¨**ï¼š
- å¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå…¶å·¦å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å°äºè¯¥èŠ‚ç‚¹çš„å€¼
- å¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå…¶å³å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å¤§äºè¯¥èŠ‚ç‚¹çš„å€¼
- å·¦å³å­æ ‘ä¹Ÿéƒ½æ˜¯äºŒå‰æœç´¢æ ‘

```python
class TreeNode:
    """äºŒå‰æ ‘èŠ‚ç‚¹"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    """
    äºŒå‰æœç´¢æ ‘å®ç°
    æ—¶é—´å¤æ‚åº¦:
    - å¹³å‡æƒ…å†µ: O(log n)
    - æœ€åæƒ…å†µ: O(n) (é€€åŒ–ä¸ºé“¾è¡¨)
    """
    def __init__(self):
        self.root = None

    def search(self, val: int) -> bool:
        """
        æœç´¢æ“ä½œ
        æ—¶é—´å¤æ‚åº¦: O(h)ï¼Œhä¸ºæ ‘çš„é«˜åº¦
        """
        return self._search_recursive(self.root, val)

    def _search_recursive(self, node: TreeNode, val: int) -> bool:
        if not node:
            return False
        if node.val == val:
            return True
        elif val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)

    def insert(self, val: int) -> None:
        """æ’å…¥æ“ä½œ"""
        self.root = self._insert_recursive(self.root, val)

    def _insert_recursive(self, node: TreeNode, val: int) -> TreeNode:
        if not node:
            return TreeNode(val)

        if val < node.val:
            node.left = self._insert_recursive(node.left, val)
        elif val > node.val:
            node.right = self._insert_recursive(node.right, val)

        return node

    def delete(self, val: int) -> None:
        """åˆ é™¤æ“ä½œ"""
        self.root = self._delete_recursive(self.root, val)

    def _delete_recursive(self, node: TreeNode, val: int) -> TreeNode:
        if not node:
            return None

        if val < node.val:
            node.left = self._delete_recursive(node.left, val)
        elif val > node.val:
            node.right = self._delete_recursive(node.right, val)
        else:
            # æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
            if not node.left:
                return node.right
            elif not node.right:
                return node.left
            else:
                # æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæ‰¾åˆ°å³å­æ ‘çš„æœ€å°å€¼
                min_node = self._find_min(node.right)
                node.val = min_node.val
                node.right = self._delete_recursive(node.right, min_node.val)

        return node

    def _find_min(self, node: TreeNode) -> TreeNode:
        """æ‰¾åˆ°å­æ ‘çš„æœ€å°å€¼èŠ‚ç‚¹"""
        while node.left:
            node = node.left
        return node

    def inorder_traversal(self) -> list:
        """ä¸­åºéå†ï¼ˆæœ‰åºè¾“å‡ºï¼‰"""
        result = []
        self._inorder_recursive(self.root, result)
        return result

    def _inorder_recursive(self, node: TreeNode, result: list) -> None:
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.val)
            self._inorder_recursive(node.right, result)
```

### BSTçš„å¯è§†åŒ–æ¼”ç¤º

```python
# åˆ›å»ºç¤ºä¾‹BSTç”¨äºæ¼”ç¤º
def create_demo_bst():
    """åˆ›å»ºä¸€ä¸ªç¤ºä¾‹BST"""
    bst = BinarySearchTree()
    values = [50, 30, 70, 20, 40, 60, 80]
    for val in values:
        bst.insert(val)
    return bst

# ç”Ÿæˆæ ‘çš„å¯è§†åŒ–æ•°æ®
def generate_tree_visualization_data():
    """
    ç”Ÿæˆæ ‘å¯è§†åŒ–æ‰€éœ€çš„æ•°æ®ç»“æ„
    """
    tree_data = {
        "value": 50,
        "left": {
            "value": 30,
            "left": {"value": 20, "left": None, "right": None},
            "right": {"value": 40, "left": None, "right": None}
        },
        "right": {
            "value": 70,
            "left": {"value": 60, "left": None, "right": None},
            "right": {"value": 80, "left": None, "right": None}
        }
    }
    return tree_data
```

<TreeVisualizer
  tree={generate_tree_visualization_data()}
  title="äºŒå‰æœç´¢æ ‘ç¤ºä¾‹"
  width={600}
  height={400}
/>

<ExerciseBlock
  title="BSTæœç´¢åˆ†æ"
  question:"åœ¨BSTä¸­æœç´¢å€¼ä¸º45çš„å…ƒç´ ï¼Œéœ€è¦æ¯”è¾ƒå“ªäº›èŠ‚ç‚¹çš„å€¼ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "50, 30, 40",
      correct: true,
      explanation: "æ­£ç¡®ï¼è·¯å¾„ä¸ºï¼š50â†’30â†’40ï¼Œ45å¤§äº40æ‰€ä»¥åœ¨40çš„å³å­æ ‘ä¸­æŸ¥æ‰¾"
    },
    {
      id: "b",
      text: "50, 70, 60",
      correct: false,
      explanation: "è¿™æ˜¯æœç´¢å¤§äº50çš„å€¼çš„è·¯å¾„"
    },
    {
      id: "c",
      text: "50, 30, 20",
      correct: false,
      explanation: "è¿™æ˜¯æœç´¢å°äº30çš„å€¼çš„è·¯å¾„"
    },
    {
      id: "d",
      text: "æ‰€æœ‰èŠ‚ç‚¹",
      correct: false,
      explanation: "BSTæœç´¢ä¸éœ€è¦éå†æ‰€æœ‰èŠ‚ç‚¹"
    }
  ]}
  hint="æ²¿ç€æœç´¢è·¯å¾„ï¼Œæ ¹æ®å¤§å°å…³ç³»å†³å®šå‘å·¦è¿˜æ˜¯å‘å³"
/>

## âš–ï¸ å¹³è¡¡äºŒå‰æœç´¢æ ‘

### AVLæ ‘

AVLæ ‘æ˜¯ç¬¬ä¸€ä¸ªè‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œé€šè¿‡æ—‹è½¬æ“ä½œä¿æŒå¹³è¡¡ã€‚

```python
class AVLNode:
    """AVLæ ‘èŠ‚ç‚¹"""
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1  # èŠ‚ç‚¹é«˜åº¦

class AVLTree:
    """
    AVLæ ‘å®ç°
    ç‰¹æ€§ï¼šä»»æ„èŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡1
    æ—¶é—´å¤æ‚åº¦ï¼šO(log n) æ‰€æœ‰æ“ä½œ
    """
    def __init__(self):
        self.root = None

    def _get_height(self, node):
        """è·å–èŠ‚ç‚¹é«˜åº¦"""
        if not node:
            return 0
        return node.height

    def _get_balance(self, node):
        """è·å–å¹³è¡¡å› å­"""
        if not node:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)

    def _update_height(self, node):
        """æ›´æ–°èŠ‚ç‚¹é«˜åº¦"""
        node.height = max(self._get_height(node.left), self._get_height(node.right)) + 1

    def _right_rotate(self, y):
        """å³æ—‹è½¬"""
        x = y.left
        T2 = x.right

        # æ‰§è¡Œæ—‹è½¬
        x.right = y
        y.left = T2

        # æ›´æ–°é«˜åº¦
        self._update_height(y)
        self._update_height(x)

        return x

    def _left_rotate(self, x):
        """å·¦æ—‹è½¬"""
        y = x.right
        T2 = y.left

        # æ‰§è¡Œæ—‹è½¬
        y.left = x
        x.right = T2

        # æ›´æ–°é«˜åº¦
        self._update_height(x)
        self._update_height(y)

        return y

    def insert(self, val: int) -> None:
        """æ’å…¥æ“ä½œ"""
        self.root = self._insert_recursive(self.root, val)

    def _insert_recursive(self, node: AVLNode, val: int) -> AVLNode:
        # æ ‡å‡†BSTæ’å…¥
        if not node:
            return AVLNode(val)

        if val < node.val:
            node.left = self._insert_recursive(node.left, val)
        elif val > node.val:
            node.right = self._insert_recursive(node.right, val)
        else:
            return node  # ä¸å…è®¸é‡å¤å€¼

        # æ›´æ–°é«˜åº¦
        self._update_height(node)

        # è·å–å¹³è¡¡å› å­
        balance = self._get_balance(node)

        # å¹³è¡¡å¤„ç†

        # å·¦å·¦æƒ…å†µ (LL)
        if balance > 1 and val < node.left.val:
            return self._right_rotate(node)

        # å³å³æƒ…å†µ (RR)
        if balance < -1 and val > node.right.val:
            return self._left_rotate(node)

        # å·¦å³æƒ…å†µ (LR)
        if balance > 1 and val > node.left.val:
            node.left = self._left_rotate(node.left)
            return self._right_rotate(node)

        # å³å·¦æƒ…å†µ (RL)
        if balance < -1 and val < node.right.val:
            node.right = self._right_rotate(node.right)
            return self._left_rotate(node)

        return node

    def delete(self, val: int) -> None:
        """åˆ é™¤æ“ä½œ"""
        self.root = self._delete_recursive(self.root, val)

    def _delete_recursive(self, node: AVLNode, val: int) -> AVLNode:
        # æ ‡å‡†BSTåˆ é™¤
        if not node:
            return node

        if val < node.val:
            node.left = self._delete_recursive(node.left, val)
        elif val > node.val:
            node.right = self._delete_recursive(node.right, val)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                # æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
                temp = self._get_min_value_node(node.right)
                node.val = temp.val
                node.right = self._delete_recursive(node.right, temp.val)

        # å¦‚æœæ ‘åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        if node is None:
            return node

        # æ›´æ–°é«˜åº¦
        self._update_height(node)

        # è·å–å¹³è¡¡å› å­
        balance = self._get_balance(node)

        # å¹³è¡¡å¤„ç†ï¼ˆä¸æ’å…¥ç±»ä¼¼ï¼‰

        # å·¦å·¦æƒ…å†µ
        if balance > 1 and self._get_balance(node.left) >= 0:
            return self._right_rotate(node)

        # å·¦å³æƒ…å†µ
        if balance > 1 and self._get_balance(node.left) < 0:
            node.left = self._left_rotate(node.left)
            return self._right_rotate(node)

        # å³å³æƒ…å†µ
        if balance < -1 and self._get_balance(node.right) <= 0:
            return self._left_rotate(node)

        # å³å·¦æƒ…å†µ
        if balance < -1 and self._get_balance(node.right) > 0:
            node.right = self._right_rotate(node.right)
            return self._left_rotate(node)

        return node

    def _get_min_value_node(self, node: AVLNode) -> AVLNode:
        """è·å–æœ€å°å€¼èŠ‚ç‚¹"""
        current = node
        while current.left:
            current = current.left
        return current
```

### çº¢é»‘æ ‘

çº¢é»‘æ ‘æ˜¯å¦ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œé€šè¿‡é¢œè‰²å’Œè§„åˆ™ä¿æŒå¹³è¡¡ã€‚

```python
class RBNode:
    """çº¢é»‘æ ‘èŠ‚ç‚¹"""
    def __init__(self, val=0, color='RED'):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
        self.color = color  # RED æˆ– BLACK

class RedBlackTree:
    """
    çº¢é»‘æ ‘å®ç°
    æ€§è´¨ï¼š
    1. æ¯ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²
    2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²
    3. æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²
    4. çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²
    5. ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­çš„è·¯å¾„åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹
    """
    def __init__(self):
        self.NIL = RBNode(0, 'BLACK')  # å“¨å…µèŠ‚ç‚¹
        self.root = self.NIL

    def insert(self, val: int) -> None:
        """æ’å…¥æ“ä½œ"""
        node = RBNode(val)
        node.left = self.NIL
        node.right = self.NIL
        node.parent = None

        # æ ‡å‡†BSTæ’å…¥
        parent = None
        current = self.root

        while current != self.NIL:
            parent = current
            if node.val < current.val:
                current = current.left
            else:
                current = current.right

        node.parent = parent
        if parent is None:
            self.root = node
        elif node.val < parent.val:
            parent.left = node
        else:
            parent.right = node

        # å¦‚æœæ–°èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè®¾ä¸ºé»‘è‰²
        if node.parent is None:
            node.color = 'BLACK'
            return

        # å¦‚æœæ–°èŠ‚ç‚¹çš„ç¥–çˆ¶èŠ‚ç‚¹æ˜¯Noneï¼Œä¸éœ€è¦ä¿®å¤
        if node.parent.parent is None:
            return

        # ä¿®å¤çº¢é»‘æ ‘æ€§è´¨
        self._fix_insert(node)

    def _fix_insert(self, node: RBNode):
        """ä¿®å¤æ’å…¥åçš„çº¢é»‘æ ‘æ€§è´¨"""
        while node != self.root and node.parent.color == 'RED':
            if node.parent == node.parent.parent.right:
                uncle = node.parent.parent.left
                if uncle.color == 'RED':
                    # æƒ…å†µ1ï¼šå”å”æ˜¯çº¢è‰²
                    uncle.color = 'BLACK'
                    node.parent.color = 'BLACK'
                    node.parent.parent.color = 'RED'
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        # æƒ…å†µ2ï¼šå”å”æ˜¯é»‘è‰²ä¸”èŠ‚ç‚¹æ˜¯å·¦å­©å­
                        node = node.parent
                        self._right_rotate(node)
                    # æƒ…å†µ3ï¼šå”å”æ˜¯é»‘è‰²ä¸”èŠ‚ç‚¹æ˜¯å³å­©å­
                    node.parent.color = 'BLACK'
                    node.parent.parent.color = 'RED'
                    self._left_rotate(node.parent.parent)
            else:
                # å¯¹ç§°æƒ…å†µ
                uncle = node.parent.parent.right
                if uncle.color == 'RED':
                    uncle.color = 'BLACK'
                    node.parent.color = 'BLACK'
                    node.parent.parent.color = 'RED'
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        node = node.parent
                        self._left_rotate(node)
                    node.parent.color = 'BLACK'
                    node.parent.parent.color = 'RED'
                    self._right_rotate(node.parent.parent)

        self.root.color = 'BLACK'

    def _left_rotate(self, x: RBNode):
        """å·¦æ—‹è½¬"""
        y = x.right
        x.right = y.left
        if y.left != self.NIL:
            y.left.parent = x
        y.parent = x.parent
        if x.parent is None:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    def _right_rotate(self, y: RBNode):
        """å³æ—‹è½¬"""
        x = y.left
        y.left = x.right
        if x.right != self.NIL:
            x.right.parent = y
        x.parent = y.parent
        if y.parent is None:
            self.root = x
        elif y == y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x
```

<ExerciseBlock
  title="å¹³è¡¡æ ‘æ¯”è¾ƒ"
  question:"AVLæ ‘å’Œçº¢é»‘æ ‘çš„ä¸»è¦åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "AVLæ ‘æ¯”çº¢é»‘æ ‘æ›´å¹³è¡¡ï¼Œä½†æ’å…¥åˆ é™¤æ“ä½œæ›´æ…¢",
      correct: true,
      explanation: "æ­£ç¡®ï¼AVLæ ‘ä¸¥æ ¼ä¿æŒå¹³è¡¡ï¼ˆé«˜åº¦å·®â‰¤1ï¼‰ï¼Œä½†éœ€è¦æ›´å¤šæ—‹è½¬æ“ä½œ"
    },
    {
      id: "b",
      text: "çº¢é»‘æ ‘æ¯”AVLæ ‘æ›´å¹³è¡¡ï¼Œä½†æŸ¥è¯¢æ“ä½œæ›´æ…¢",
      correct: false,
      explanation: "AVLæ ‘æ¯”çº¢é»‘æ ‘æ›´å¹³è¡¡ï¼ŒæŸ¥è¯¢æ›´å¿«"
    },
    {
      id: "c",
      text: "ä¸¤è€…åœ¨æ‰€æœ‰æ“ä½œä¸Šæ€§èƒ½å®Œå…¨ç›¸åŒ",
      correct: false,
      explanation: "ä¸¤è€…åœ¨å¹³è¡¡ç­–ç•¥å’Œæ“ä½œå¼€é”€ä¸Šæœ‰æ˜æ˜¾å·®å¼‚"
    },
    {
      id: "d",
      text: "AVLæ ‘åªæ”¯æŒæŸ¥è¯¢ï¼Œçº¢é»‘æ ‘æ”¯æŒæ‰€æœ‰æ“ä½œ",
      correct: false,
      explanation: "ä¸¤ç§æ ‘éƒ½æ”¯æŒå®Œæ•´çš„CRUDæ“ä½œ"
    }
  ]}
  hint="è€ƒè™‘å¹³è¡¡ä¸¥æ ¼åº¦å’Œæ“ä½œå¼€é”€çš„æƒè¡¡"
/>

## ğŸŒ³ Bæ ‘å’ŒB+æ ‘

### Bæ ‘

Bæ ‘æ˜¯ä¸ºç£ç›˜å­˜å‚¨ç­‰å¤–éƒ¨å­˜å‚¨å™¨è®¾è®¡çš„è‡ªå¹³è¡¡æœç´¢æ ‘ã€‚

```python
class BTreeNode:
    """Bæ ‘èŠ‚ç‚¹"""
    def __init__(self, leaf=False):
        self.leaf = leaf          # æ˜¯å¦ä¸ºå¶å­èŠ‚ç‚¹
        self.keys = []            # é”®å€¼åˆ—è¡¨
        self.children = []        # å­èŠ‚ç‚¹åˆ—è¡¨

class BTree:
    """
    Bæ ‘å®ç°
    ç‰¹æ€§ï¼š
    1. æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰mä¸ªå­èŠ‚ç‚¹
    2. é™¤æ ¹èŠ‚ç‚¹å¤–ï¼Œæ¯ä¸ªèŠ‚ç‚¹è‡³å°‘æœ‰âŒˆm/2âŒ‰ä¸ªå­èŠ‚ç‚¹
    3. æ ¹èŠ‚ç‚¹è‡³å°‘æœ‰2ä¸ªå­èŠ‚ç‚¹ï¼ˆé™¤éæ˜¯å¶å­èŠ‚ç‚¹ï¼‰
    4. æ‰€æœ‰å¶å­èŠ‚ç‚¹åœ¨åŒä¸€å±‚
    """
    def __init__(self, t):
        self.root = BTreeNode(leaf=True)
        self.t = t  # Bæ ‘çš„æœ€å°åº¦æ•°

    def search(self, key):
        """æœç´¢æ“ä½œ"""
        return self._search_recursive(self.root, key)

    def _search_recursive(self, node, key):
        """é€’å½’æœç´¢"""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and key == node.keys[i]:
            return True  # æ‰¾åˆ°é”®

        if node.leaf:
            return False  # æœªæ‰¾åˆ°é”®

        return self._search_recursive(node.children[i], key)

    def insert(self, key):
        """æ’å…¥æ“ä½œ"""
        root = self.root
        if len(root.keys) == (2 * self.t - 1):
            # æ ¹èŠ‚ç‚¹å·²æ»¡ï¼Œåˆ†è£‚
            new_root = BTreeNode()
            new_root.children.append(self.root)
            self.root = new_root
            self._split_child(new_root, 0)

        self._insert_nonfull(self.root, key)

    def _insert_nonfull(self, node, key):
        """å‘éæ»¡èŠ‚ç‚¹æ’å…¥"""
        i = len(node.keys) - 1

        if node.leaf:
            # å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥æ’å…¥
            node.keys.append(0)
            while i >= 0 and key < node.keys[i]:
                node.keys[i + 1] = node.keys[i]
                i -= 1
            node.keys[i + 1] = key
        else:
            # å†…éƒ¨èŠ‚ç‚¹ï¼Œæ‰¾åˆ°åˆé€‚çš„å­èŠ‚ç‚¹
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1

            if len(node.children[i].keys) == (2 * self.t - 1):
                # å­èŠ‚ç‚¹å·²æ»¡ï¼Œåˆ†è£‚
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1

            self._insert_nonfull(node.children[i], key)

    def _split_child(self, parent, index):
        """åˆ†è£‚å­èŠ‚ç‚¹"""
        t = self.t
        y = parent.children[index]
        z = BTreeNode(leaf=y.leaf)

        # å°†yçš„é”®æå‡åˆ°çˆ¶èŠ‚ç‚¹
        parent.keys.insert(index, y.keys[t - 1])
        parent.children.insert(index + 1, z)

        # å¤åˆ¶é”®åˆ°zèŠ‚ç‚¹
        z.keys = y.keys[t:]
        y.keys = y.keys[:t - 1]

        # å¦‚æœä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå¤åˆ¶å­èŠ‚ç‚¹
        if not y.leaf:
            z.children = y.children[t:]
            y.children = y.children[:t]

    def delete(self, key):
        """åˆ é™¤æ“ä½œ"""
        self._delete_recursive(self.root, key)

    def _delete_recursive(self, node, key):
        """é€’å½’åˆ é™¤"""
        # å®ç°è¾ƒä¸ºå¤æ‚ï¼Œéœ€è¦å¤„ç†å¤šç§æƒ…å†µ
        # è¿™é‡Œç®€åŒ–å®ç°
        pass
```

### B+æ ‘

B+æ ‘æ˜¯Bæ ‘çš„å˜ä½“ï¼Œç‰¹åˆ«é€‚åˆæ•°æ®åº“ç´¢å¼•ã€‚

```python
class BPlusTreeNode:
    """B+æ ‘èŠ‚ç‚¹"""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []  # å†…éƒ¨èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        self.next = None    # å¶å­èŠ‚ç‚¹çš„é“¾è¡¨æŒ‡é’ˆ

class BPlusTree:
    """
    B+æ ‘å®ç°
    ç‰¹æ€§ï¼š
    1. æ‰€æœ‰æ•°æ®è®°å½•éƒ½å­˜å‚¨åœ¨å¶å­èŠ‚ç‚¹
    2. å†…éƒ¨èŠ‚ç‚¹åªå­˜å‚¨é”®å€¼ï¼Œç”¨äºç´¢å¼•
    3. å¶å­èŠ‚ç‚¹é€šè¿‡æŒ‡é’ˆè¿æ¥ï¼Œä¾¿äºèŒƒå›´æŸ¥è¯¢
    """
    def __init__(self, order):
        self.root = BPlusTreeNode(leaf=True)
        self.order = order

    def search(self, key):
        """æœç´¢æ“ä½œ"""
        leaf = self._find_leaf(key)
        for i, k in enumerate(leaf.keys):
            if k == key:
                return leaf.data[i] if hasattr(leaf, 'data') else True
        return None

    def _find_leaf(self, key):
        """æ‰¾åˆ°åŒ…å«keyçš„å¶å­èŠ‚ç‚¹"""
        node = self.root
        while not node.leaf:
            i = 0
            while i < len(node.keys) and key >= node.keys[i]:
                i += 1
            node = node.children[i]
        return node

    def insert(self, key, value=None):
        """æ’å…¥æ“ä½œ"""
        leaf = self._find_leaf(key)
        # åœ¨å¶å­èŠ‚ç‚¹ä¸­æ’å…¥é”®å€¼å¯¹
        # å®ç°çœç•¥...

    def range_query(self, start_key, end_key):
        """èŒƒå›´æŸ¥è¯¢"""
        results = []
        leaf = self._find_leaf(start_key)

        while leaf:
            for key, value in zip(leaf.keys, leaf.data):
                if start_key <= key <= end_key:
                    results.append((key, value))
                elif key > end_key:
                    return results
            leaf = leaf.next

        return results
```

## ğŸ¯ æ ‘çš„åº”ç”¨åœºæ™¯

### 1. æ•°æ®åº“ç´¢å¼•

```python
class DatabaseIndex:
    """
    ä½¿ç”¨B+æ ‘å®ç°æ•°æ®åº“ç´¢å¼•
    """
    def __init__(self):
        self.primary_index = BPlusTree(order=100)  # ä¸»é”®ç´¢å¼•
        self.secondary_indexes = {}                # äºŒçº§ç´¢å¼•

    def create_index(self, table_name, column_name):
        """åˆ›å»ºç´¢å¼•"""
        index_key = f"{table_name}_{column_name}"
        self.secondary_indexes[index_key] = BPlusTree(order=50)

    def insert_record(self, table_name, record):
        """æ’å…¥è®°å½•å¹¶æ›´æ–°ç´¢å¼•"""
        # å‡è®¾recordæ˜¯ä¸€ä¸ªå­—å…¸
        primary_key = record['id']
        self.primary_index.insert(primary_key, record)

        # æ›´æ–°äºŒçº§ç´¢å¼•
        for index_key, index in self.secondary_indexes.items():
            table, column = index_key.split('_', 1)
            if table == table_name and column in record:
                index.insert(record[column], primary_key)

    def query_by_primary(self, primary_key):
        """é€šè¿‡ä¸»é”®æŸ¥è¯¢"""
        return self.primary_index.search(primary_key)

    def query_by_secondary(self, table_name, column_name, value):
        """é€šè¿‡äºŒçº§ç´¢å¼•æŸ¥è¯¢"""
        index_key = f"{table_name}_{column_name}"
        if index_key in self.secondary_indexes:
            primary_keys = self.secondary_indexes[index_key].search(value)
            return [self.primary_index.search(pk) for pk in primary_keys]
        return []

    def range_query(self, table_name, column_name, start_val, end_val):
        """èŒƒå›´æŸ¥è¯¢"""
        index_key = f"{table_name}_{column_name}"
        if index_key in self.secondary_indexes:
            return self.secondary_indexes[index_key].range_query(start_val, end_val)
        return []
```

### 2. æ–‡ä»¶ç³»ç»Ÿ

```python
class FileSystem:
    """
    ä½¿ç”¨æ ‘ç»“æ„å®ç°æ–‡ä»¶ç³»ç»Ÿ
    """
    def __init__(self):
        self.root = DirectoryNode("/")
        self.current_directory = self.root

    def mkdir(self, path):
        """åˆ›å»ºç›®å½•"""
        dirs = path.split('/')
        current = self.current_directory

        for dir_name in dirs:
            if dir_name:  # è·³è¿‡ç©ºå­—ç¬¦ä¸²
                found = False
                for child in current.children:
                    if isinstance(child, DirectoryNode) and child.name == dir_name:
                        current = child
                        found = True
                        break
                if not found:
                    new_dir = DirectoryNode(dir_name)
                    current.add_child(new_dir)
                    current = new_dir

    def touch(self, filename, content=""):
        """åˆ›å»ºæ–‡ä»¶"""
        new_file = FileNode(filename, content)
        self.current_directory.add_child(new_file)

    def cd(self, path):
        """åˆ‡æ¢ç›®å½•"""
        if path == "/":
            self.current_directory = self.root
        elif path == "..":
            if self.current_directory.parent:
                self.current_directory = self.current_directory.parent
        else:
            dirs = path.split('/')
            current = self.current_directory if path.startswith('/') else self.root

            for dir_name in dirs:
                if dir_name:
                    found = False
                    for child in current.children:
                        if isinstance(child, DirectoryNode) and child.name == dir_name:
                            current = child
                            found = True
                            break
                    if not found:
                        raise FileNotFoundError(f"Directory {dir_name} not found")

            self.current_directory = current

    def ls(self):
        """åˆ—å‡ºå½“å‰ç›®å½•å†…å®¹"""
        return [child.name for child in self.current_directory.children]

class DirectoryNode:
    """ç›®å½•èŠ‚ç‚¹"""
    def __init__(self, name):
        self.name = name
        self.children = []
        self.parent = None

    def add_child(self, child):
        child.parent = self
        self.children.append(child)

class FileNode:
    """æ–‡ä»¶èŠ‚ç‚¹"""
    def __init__(self, name, content=""):
        self.name = name
        self.content = content
        self.parent = None
```

### 3. è¡¨è¾¾å¼æ ‘

```python
class ExpressionNode:
    """è¡¨è¾¾å¼æ ‘èŠ‚ç‚¹"""
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

class ExpressionTree:
    """è¡¨è¾¾å¼æ ‘"""
    def __init__(self):
        self.root = None

    def build_from_postfix(self, postfix):
        """ä»åç¼€è¡¨è¾¾å¼æ„å»ºè¡¨è¾¾å¼æ ‘"""
        stack = []
        operators = {'+', '-', '*', '/', '^'}

        for token in postfix:
            if token in operators:
                # è¿ç®—ç¬¦ï¼Œå¼¹å‡ºä¸¤ä¸ªæ“ä½œæ•°
                right = stack.pop()
                left = stack.pop()
                node = ExpressionNode(token, left, right)
                stack.append(node)
            else:
                # æ“ä½œæ•°
                node = ExpressionNode(token)
                stack.append(node)

        self.root = stack.pop()

    def evaluate(self):
        """è®¡ç®—è¡¨è¾¾å¼å€¼"""
        return self._evaluate_recursive(self.root)

    def _evaluate_recursive(self, node):
        if not node.left and not node.right:
            # å¶å­èŠ‚ç‚¹ï¼Œè¿”å›æ•°å€¼
            return float(node.value)

        left_val = self._evaluate_recursive(node.left)
        right_val = self._evaluate_recursive(node.right)

        if node.value == '+':
            return left_val + right_val
        elif node.value == '-':
            return left_val - right_val
        elif node.value == '*':
            return left_val * right_val
        elif node.value == '/':
            return left_val / right_val
        elif node.value == '^':
            return left_val ** right_val

    def inorder_traversal(self):
        """ä¸­åºéå†ï¼ˆä¸­ç¼€è¡¨è¾¾å¼ï¼‰"""
        result = []
        self._inorder_recursive(self.root, result)
        return ' '.join(result)

    def _inorder_recursive(self, node, result):
        if node:
            if node.left or node.right:
                result.append('(')
            self._inorder_recursive(node.left, result)
            result.append(str(node.value))
            self._inorder_recursive(node.right, result)
            if node.left or node.right:
                result.append(')')
```

<ExerciseBlock
  title="æ ‘çš„åº”ç”¨"
  question:"ä¸ºä»€ä¹ˆæ•°æ®åº“ç´¢å¼•é€šå¸¸ä½¿ç”¨B+æ ‘è€Œä¸æ˜¯Bæ ‘ï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "B+æ ‘çš„æŸ¥è¯¢é€Ÿåº¦æ¯”Bæ ‘å¿«",
      correct: false,
      explanation: "ä¸¤è€…æŸ¥è¯¢å¤æ‚åº¦ç›¸åŒï¼Œéƒ½æ˜¯O(log n)"
    },
    {
      id: "b",
      text: "B+æ ‘æ”¯æŒæ›´é«˜æ•ˆçš„èŒƒå›´æŸ¥è¯¢å’Œé¡ºåºè®¿é—®",
      correct: true,
      explanation: "æ­£ç¡®ï¼B+æ ‘çš„å¶å­èŠ‚ç‚¹é€šè¿‡æŒ‡é’ˆè¿æ¥ï¼Œéå¸¸é€‚åˆèŒƒå›´æŸ¥è¯¢"
    },
    {
      id: "c",
      text: "B+æ ‘å ç”¨æ›´å°‘çš„å­˜å‚¨ç©ºé—´",
      correct: false,
      explanation: "B+æ ‘é€šå¸¸éœ€è¦æ›´å¤šç©ºé—´ï¼Œå› ä¸ºæ•°æ®åœ¨å¶å­èŠ‚ç‚¹æœ‰å†—ä½™"
    },
    {
      id: "d",
      text: "B+æ ‘çš„å®ç°æ¯”Bæ ‘ç®€å•",
      correct: false,
      explanation: "B+æ ‘çš„å®ç°é€šå¸¸æ›´å¤æ‚"
    }
  ]}
  hint="è€ƒè™‘æ•°æ®åº“æ“ä½œçš„ç‰¹ç‚¹ï¼Œç‰¹åˆ«æ˜¯èŒƒå›´æŸ¥è¯¢çš„éœ€æ±‚"
/>

## ğŸ“Š æ€§èƒ½åˆ†æä¸æ¯”è¾ƒ

### æ ‘ç»“æ„æ€§èƒ½å¯¹æ¯”

| æ ‘ç±»å‹ | æŸ¥æ‰¾ | æ’å…¥ | åˆ é™¤ | èŒƒå›´æŸ¥è¯¢ | å¹³è¡¡æ€§ | åº”ç”¨åœºæ™¯ |
|--------|------|------|------|----------|--------|----------|
| **BST** | O(h) | O(h) | O(h) | O(n) | ä¸ä¿è¯ | å°è§„æ¨¡æ•°æ® |
| **AVL** | O(log n) | O(log n) | O(log n) | O(n) | ä¸¥æ ¼å¹³è¡¡ | æŸ¥è¯¢å¯†é›†å‹ |
| **çº¢é»‘** | O(log n) | O(log n) | O(log n) | O(n) | è¿‘ä¼¼å¹³è¡¡ | é€šç”¨åœºæ™¯ |
| **Bæ ‘** | O(log n) | O(log n) | O(log n) | O(log n) | å¹³è¡¡ | å¤–éƒ¨å­˜å‚¨ |
| **B+æ ‘** | O(log n) | O(log n) | O(log n) | O(k) | å¹³è¡¡ | æ•°æ®åº“ç´¢å¼• |

### å®é™…æ€§èƒ½æµ‹è¯•

```python
def performance_comparison():
    """
    ä¸åŒæ ‘ç»“æ„çš„æ€§èƒ½å¯¹æ¯”æµ‹è¯•
    """
    import time
    import random

    # ç”Ÿæˆæµ‹è¯•æ•°æ®
    data_sizes = [1000, 10000, 100000]
    results = {}

    for size in data_sizes:
        test_data = random.sample(range(size * 10), size)

        # æµ‹è¯•ä¸åŒæ ‘ç»“æ„
        trees = {
            "BST": BinarySearchTree(),
            "AVL": AVLTree(),
            # "BTree": BTree(t=50)  # éœ€è¦å®ç°
        }

        results[size] = {}

        for name, tree in trees.items():
            # æ’å…¥æµ‹è¯•
            start_time = time.time()
            for val in test_data:
                tree.insert(val)
            insert_time = time.time() - start_time

            # æŸ¥æ‰¾æµ‹è¯•
            search_times = []
            search_values = random.sample(test_data, min(100, len(test_data)))
            for val in search_values:
                start_time = time.time()
                tree.search(val)
                search_times.append(time.time() - start_time)

            avg_search_time = sum(search_times) / len(search_times)

            results[size][name] = {
                "insert_time": insert_time,
                "avg_search_time": avg_search_time,
                "tree_height": get_tree_height(tree.root)
            }

    return results

def get_tree_height(node):
    """è·å–æ ‘çš„é«˜åº¦"""
    if not node:
        return -1
    return 1 + max(get_tree_height(node.left), get_tree_height(node.right))
```

<ComplexityAnalyzer
  title="æ ‘ç»“æ„æŸ¥è¯¢æ€§èƒ½å¯¹æ¯”"
  algorithm="AVLæ ‘æŸ¥è¯¢"
  theoreticalComplexity="O(log n)"
  data={[
    {"n": 1000, "time": 0.001},
    {"n": 10000, "time": 0.003},
    {"n": 100000, "time": 0.005},
    {"n": 1000000, "time": 0.007}
  ]}
  color="rgb(34, 197, 94)"
/>

## ğŸ¯ é«˜çº§ä¸»é¢˜

### 1. æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–

```python
class TreeSerializer:
    """
    æ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
    """
    def serialize(self, root):
        """å°†æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²"""
        if not root:
            return "null"

        queue = [root]
        result = []

        while queue:
            node = queue.pop(0)
            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append("null")

        # ç§»é™¤æœ«å°¾çš„null
        while result and result[-1] == "null":
            result.pop()

        return "[" + ",".join(result) + "]"

    def deserialize(self, data):
        """ä»å­—ç¬¦ä¸²ååºåˆ—åŒ–æ ‘"""
        if data == "[]":
            return None

        values = data[1:-1].split(",")
        root = TreeNode(int(values[0]))
        queue = [root]
        index = 1

        while queue and index < len(values):
            node = queue.pop(0)

            if index < len(values) and values[index] != "null":
                node.left = TreeNode(int(values[index]))
                queue.append(node.left)
            index += 1

            if index < len(values) and values[index] != "null":
                node.right = TreeNode(int(values[index]))
                queue.append(node.right)
            index += 1

        return root
```

### 2. æ ‘çš„è¿­ä»£éå†

```python
class TreeIterator:
    """
    æ ‘çš„è¿­ä»£éå†å™¨
    """
    def __init__(self, root):
        self.root = root

    def inorder_iterative(self):
        """ä¸­åºéå†çš„è¿­ä»£å®ç°"""
        stack = []
        current = self.root
        result = []

        while current or stack:
            while current:
                stack.append(current)
                current = current.left

            current = stack.pop()
            result.append(current.val)
            current = current.right

        return result

    def preorder_iterative(self):
        """å‰åºéå†çš„è¿­ä»£å®ç°"""
        if not self.root:
            return []

        stack = [self.root]
        result = []

        while stack:
            node = stack.pop()
            result.append(node.val)

            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)

        return result

    def postorder_iterative(self):
        """ååºéå†çš„è¿­ä»£å®ç°"""
        if not self.root:
            return []

        stack1 = [self.root]
        stack2 = []
        result = []

        while stack1:
            node = stack1.pop()
            stack2.append(node)

            if node.left:
                stack1.append(node.left)
            if node.right:
                stack1.append(node.right)

        while stack2:
            node = stack2.pop()
            result.append(node.val)

        return result
```

### 3. æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```python
def lowest_common_ancestor(root, p, q):
    """
    æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(h)
    """
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root

    return left if left else right

def lowest_common_ancestor_bst(root, p, q):
    """
    åœ¨BSTä¸­æŸ¥æ‰¾LCAï¼Œåˆ©ç”¨BSTæ€§è´¨
    æ—¶é—´å¤æ‚åº¦: O(h)
    """
    if not root:
        return None

    # å¦‚æœpå’Œqéƒ½å°äºå½“å‰èŠ‚ç‚¹ï¼Œåœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾
    if p.val < root.val and q.val < root.val:
        return lowest_common_ancestor_bst(root.left, p, q)

    # å¦‚æœpå’Œqéƒ½å¤§äºå½“å‰èŠ‚ç‚¹ï¼Œåœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾
    if p.val > root.val and q.val > root.val:
        return lowest_common_ancestor_bst(root.right, p, q)

    # å¦åˆ™å½“å‰èŠ‚ç‚¹å°±æ˜¯LCA
    return root
```

<ExerciseBlock
  title="ç»¼åˆåº”ç”¨"
  question:"è®¾è®¡ä¸€ä¸ªç³»ç»Ÿæ¥ç»´æŠ¤ä¸€ä¸ªåŠ¨æ€å˜åŒ–çš„æ•´æ•°é›†åˆï¼Œæ”¯æŒæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ç¬¬kå°çš„å…ƒç´ ã€æŸ¥æ‰¾æŸä¸ªå…ƒç´ çš„æ’åã€‚å“ªç§æ ‘ç»“æ„æœ€é€‚åˆï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "æ™®é€šäºŒå‰æœç´¢æ ‘",
      correct: false,
      explanation: "æ™®é€šBSTå¯èƒ½é€€åŒ–ï¼Œæ— æ³•ä¿è¯O(log n)çš„æ€§èƒ½"
    },
    {
      id: "b",
      text: "AVLæ ‘æˆ–çº¢é»‘æ ‘",
      correct: true,
      explanation: "æ­£ç¡®ï¼å¹³è¡¡æ ‘èƒ½ä¿è¯O(log n)çš„æ‰€æœ‰æ“ä½œæ€§èƒ½"
    },
    {
      id: "c",
      text: "Bæ ‘",
      correct: false,
      explanation: "Bæ ‘æ›´é€‚åˆå¤–éƒ¨å­˜å‚¨ï¼Œä¸æ˜¯æœ€ä½³é€‰æ‹©"
    },
    {
      id: "d",
      text: " Trieæ ‘",
      correct: false,
      explanation: "Trieæ ‘é€‚åˆå­—ç¬¦ä¸²ï¼Œä¸æ˜¯æ•´æ•°æ“ä½œ"
    }
  ]}
  hint="è€ƒè™‘éœ€è¦æ”¯æŒçš„æŸ¥è¯¢ç±»å‹å’Œæ€§èƒ½è¦æ±‚"
/>

## ğŸ“ æ€»ç»“ä¸æœ€ä½³å®è·µ

### å…³é”®è¦ç‚¹

1. **æ ‘ç»“æ„é€‰æ‹©åŸåˆ™**ï¼š
   - å°è§„æ¨¡æ•°æ®ï¼šæ™®é€šBSTè¶³å¤Ÿ
   - éœ€è¦ä¿è¯æ€§èƒ½ï¼šAVLæ ‘æˆ–çº¢é»‘æ ‘
   - å¤–éƒ¨å­˜å‚¨ï¼šBæ ‘æˆ–B+æ ‘
   - æ•°æ®åº“ç´¢å¼•ï¼šB+æ ‘

2. **å¹³è¡¡ç­–ç•¥é€‰æ‹©**ï¼š
   - æŸ¥è¯¢å¯†é›†å‹ï¼šAVLæ ‘ï¼ˆæ›´ä¸¥æ ¼å¹³è¡¡ï¼‰
   - æ’å…¥åˆ é™¤é¢‘ç¹ï¼šçº¢é»‘æ ‘ï¼ˆè¾ƒå°‘æ—‹è½¬ï¼‰
   - èŒƒå›´æŸ¥è¯¢ï¼šB+æ ‘ï¼ˆå¶å­èŠ‚ç‚¹é“¾è¡¨ï¼‰

3. **å®ç°ä¼˜åŒ–æŠ€å·§**ï¼š
   - ä½¿ç”¨è¿­ä»£è€Œéé€’å½’é¿å…æ ˆæº¢å‡º
   - å®ç°æ ‘çš„åºåˆ—åŒ–ä¾¿äºå­˜å‚¨å’Œä¼ è¾“
   - æ·»åŠ ç¼“å­˜æœºåˆ¶æé«˜çƒ­ç‚¹æŸ¥è¯¢æ€§èƒ½

### å®é™…åº”ç”¨å»ºè®®

```python
def tree_structure_recommendation(use_case: str) -> str:
    """
    æ ¹æ®åº”ç”¨åœºæ™¯æ¨èæ ‘ç»“æ„
    """
    recommendations = {
        "memory_database": "çº¢é»‘æ ‘æˆ–è·³è·ƒè¡¨",
        "disk_database": "B+æ ‘",
        "filesystem": "Bæ ‘",
        "autocomplete": "Trieæ ‘",
        "network_routing": "å‰ç¼€æ ‘",
        "compression": "å“ˆå¤«æ›¼æ ‘",
        "machine_learning": "å†³ç­–æ ‘",
        "caching_system": "LRU + å“ˆå¸Œè¡¨"
    }

    return recommendations.get(use_case, "æ ¹æ®å…·ä½“éœ€æ±‚åˆ†æ")
```

<ExerciseBlock
  title="ç« èŠ‚æµ‹éªŒ"
  question:"åœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥é€‰æ‹©Bæ ‘è€Œä¸æ˜¯äºŒå‰æœç´¢æ ‘ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "å½“æ•°æ®é‡å¾ˆå°ä¸”å®Œå…¨åœ¨å†…å­˜ä¸­æ—¶",
      correct: false,
      explanation: "å°æ•°æ®é‡åœ¨å†…å­˜ä¸­æ—¶ï¼ŒäºŒå‰æœç´¢æ ‘æ›´ç®€å•é«˜æ•ˆ"
    },
    {
      id: "b",
      text: "å½“æ•°æ®å­˜å‚¨åœ¨ç£ç›˜ç­‰å¤–éƒ¨å­˜å‚¨å™¨ä¸Šæ—¶",
      correct: true,
      explanation: "æ­£ç¡®ï¼Bæ ‘å‡å°‘äº†ç£ç›˜I/Oæ¬¡æ•°ï¼Œé€‚åˆå¤–éƒ¨å­˜å‚¨"
    },
    {
      id: "c",
      text: "å½“éœ€è¦é¢‘ç¹è¿›è¡ŒèŒƒå›´æŸ¥è¯¢æ—¶",
      correct: false,
      explanation: "èŒƒå›´æŸ¥è¯¢æ›´é€‚åˆB+æ ‘ï¼Œè€Œä¸æ˜¯Bæ ‘"
    },
    {
      id: "d",
      text: "å½“æ‰€æœ‰æ“ä½œéƒ½æ˜¯é¡ºåºè®¿é—®æ—¶",
      correct: false,
      explanation: "é¡ºåºè®¿é—®ä¸éœ€è¦å¤æ‚çš„æ ‘ç»“æ„"
    }
  ]}
  hint="è€ƒè™‘å­˜å‚¨ä»‹è´¨çš„ç‰¹ç‚¹å’ŒI/Oå¼€é”€"
/>

---

## ğŸš€ è¯¾åç»ƒä¹ 

1. **åŸºç¡€ç»ƒä¹ **ï¼šå®ç°BSTã€AVLæ ‘çš„æ‰€æœ‰åŸºæœ¬æ“ä½œ
2. **è¿›é˜¶ç»ƒä¹ **ï¼šå®ç°çº¢é»‘æ ‘å’ŒBæ ‘çš„æ’å…¥åˆ é™¤æ“ä½œ
3. **å®æˆ˜ç»ƒä¹ **ï¼šä½¿ç”¨B+æ ‘å®ç°ç®€å•çš„æ•°æ®åº“ç´¢å¼•ç³»ç»Ÿ
4. **é¡¹ç›®ç»ƒä¹ **ï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒå¤šç§æŸ¥è¯¢çš„æ ‘ç»“æ„é›†åˆç±»

**è®°ä½**ï¼šæ ‘ç»“æ„æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€é‡è¦çš„æ•°æ®ç»“æ„ä¹‹ä¸€ï¼ŒæŒæ¡å®ƒä»¬æ˜¯æˆä¸ºä¼˜ç§€è½¯ä»¶å·¥ç¨‹å¸ˆçš„å…³é”®ï¼ğŸŒ³