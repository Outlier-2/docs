---
title: "L06 - å›¾ç®—æ³•åŸºç¡€"
description: "æ·±å…¥ç†è§£å›¾è¡¨ç¤ºã€éå†ç®—æ³•å’Œè¿é€šæ€§åˆ†æ"
---

import { useState, useEffect } from 'react';
import { CodeBlock } from '@/src/components/algorithm';
import { AlgorithmVisualizer } from '@/src/components/algorithm';
import { ArrayVisualizer } from '@/src/components/algorithm';
import { ComplexityAnalyzer } from '@/src/components/algorithm';
import { ExerciseBlock } from '@/src/components/algorithm';

# L06 - å›¾ç®—æ³•åŸºç¡€

## ğŸ“š å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è®²ä¹‰åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ğŸŒ **æŒæ¡å›¾çš„åŸºç¡€**ï¼šç†è§£å›¾çš„æœ¯è¯­ã€æ€§è´¨å’Œè¡¨ç¤ºæ–¹æ³•
- ğŸ” **ç²¾é€šéå†ç®—æ³•**ï¼šå®ç°BFSã€DFSåŠå…¶å˜ä½“
- ğŸ¯ **åˆ†æè¿é€šæ€§**ï¼šåˆ¤æ–­å›¾çš„è¿é€šåˆ†é‡å’Œå¼ºè¿é€šæ€§
- ğŸ› ï¸ **åº”ç”¨å›¾ç®—æ³•**ï¼šè§£å†³å®é™…ç½‘ç»œå’Œè·¯å¾„é—®é¢˜

## ğŸ¯ å›¾çš„åŸºç¡€æ¦‚å¿µ

### å›¾çš„æ•°å­¦å®šä¹‰

**å›¾G = (V, E)** ç”±é¡¶ç‚¹é›†åˆVå’Œè¾¹é›†åˆEç»„æˆã€‚

| æœ¯è¯­ | å®šä¹‰ | é‡è¦æ€§ | åº”ç”¨åœºæ™¯ |
|------|------|--------|----------|
| **é¡¶ç‚¹(Vertex)** | å›¾ä¸­çš„åŸºæœ¬å•å…ƒ | æ•°æ®å­˜å‚¨ | èŠ‚ç‚¹ã€å¯¹è±¡ |
| **è¾¹(Edge)** | é¡¶ç‚¹ä¹‹é—´çš„è¿æ¥ | å…³ç³»è¡¨ç¤º | è¿æ¥ã€å…³è” |
| **åº¦(Degree)** | ä¸é¡¶ç‚¹ç›¸è¿çš„è¾¹æ•° | ä¸­å¿ƒæ€§ | ç¤¾äº¤ç½‘ç»œ |
| **è·¯å¾„(Path)** | é¡¶ç‚¹åºåˆ— | å¯è¾¾æ€§ | è·¯ç”±è§„åˆ’ |
| **ç¯(Cycle)** | èµ·ç‚¹å’Œç»ˆç‚¹ç›¸åŒçš„è·¯å¾„ | æ£€æµ‹å¾ªç¯ | ä¾èµ–åˆ†æ |

### å›¾çš„åˆ†ç±»

```python
def graph_classification():
    """
    å›¾çš„ä¸»è¦åˆ†ç±»
    """
    classifications = {
        "æœ‰å‘å›¾ vs æ— å‘å›¾": "è¾¹æ˜¯å¦æœ‰æ–¹å‘",
        "æœ‰æƒå›¾ vs æ— æƒå›¾": "è¾¹æ˜¯å¦æœ‰æƒé‡",
        "ç®€å•å›¾ vs å¤šé‡å›¾": "æ˜¯å¦æœ‰é‡è¾¹å’Œè‡ªç¯",
        "è¿é€šå›¾ vs éè¿é€šå›¾": "æ˜¯å¦æ‰€æœ‰é¡¶ç‚¹å¯è¾¾",
        "ç¨€ç–å›¾ vs ç¨ å¯†å›¾": "è¾¹æ•°ä¸é¡¶ç‚¹æ•°çš„å…³ç³»",
        "æœ‰ç¯å›¾ vs æ— ç¯å›¾": "æ˜¯å¦åŒ…å«ç¯",
        "äºŒåˆ†å›¾": "é¡¶ç‚¹å¯åˆ†ä¸ºä¸¤ä¸ªç‹¬ç«‹é›†åˆ"
    }

    print("å›¾åˆ†ç±»ï¼š")
    for category, description in classifications.items():
        print(f"â€¢ {category}: {description}")
```

## ğŸ”§ å›¾çš„è¡¨ç¤ºæ–¹æ³•

### 1. é‚»æ¥çŸ©é˜µ

```python
class AdjacencyMatrix:
    """
    é‚»æ¥çŸ©é˜µè¡¨ç¤ºå›¾
    ç©ºé—´å¤æ‚åº¦: O(VÂ²)
    æ—¶é—´å¤æ‚åº¦:
    - æ£€æŸ¥è¾¹å­˜åœ¨: O(1)
    - è·å–é‚»å±…: O(V)
    - æ·»åŠ /åˆ é™¤è¾¹: O(1)
    """
    def __init__(self, num_vertices, directed=False):
        self.num_vertices = num_vertices
        self.directed = directed
        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]

    def add_edge(self, v1, v2, weight=1):
        """æ·»åŠ è¾¹"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            self.matrix[v1][v2] = weight
            if not self.directed:
                self.matrix[v2][v1] = weight

    def remove_edge(self, v1, v2):
        """åˆ é™¤è¾¹"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            self.matrix[v1][v2] = 0
            if not self.directed:
                self.matrix[v2][v1] = 0

    def has_edge(self, v1, v2):
        """æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            return self.matrix[v1][v2] != 0
        return False

    def get_neighbors(self, vertex):
        """è·å–é¡¶ç‚¹çš„é‚»å±…"""
        if 0 <= vertex < self.num_vertices:
            neighbors = []
            for i, weight in enumerate(self.matrix[vertex]):
                if weight != 0:
                    neighbors.append((i, weight))
            return neighbors
        return []

    def get_degree(self, vertex):
        """è·å–é¡¶ç‚¹çš„åº¦"""
        if 0 <= vertex < self.num_vertices:
            if self.directed:
                # æœ‰å‘å›¾ï¼šè®¡ç®—å…¥åº¦å’Œå‡ºåº¦
                in_degree = sum(1 for row in self.matrix if row[vertex] != 0)
                out_degree = sum(1 for weight in self.matrix[vertex] if weight != 0)
                return in_degree, out_degree
            else:
                # æ— å‘å›¾
                return sum(1 for weight in self.matrix[vertex] if weight != 0)
        return 0

    def __str__(self):
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        result = "  " + " ".join(f"{i:2}" for i in range(self.num_vertices)) + "\n"
        for i, row in enumerate(self.matrix):
            result += f"{i:2} " + " ".join(f"{w:2}" for w in row) + "\n"
        return result

# ä¼˜ç‚¹ï¼šè¾¹å­˜åœ¨æ€§æ£€æŸ¥O(1)ï¼Œé€‚åˆç¨ å¯†å›¾
# ç¼ºç‚¹ï¼šç©ºé—´å¤æ‚åº¦é«˜ï¼Œè·å–é‚»å±…æ•ˆç‡ä½
```

### 2. é‚»æ¥è¡¨

```python
class AdjacencyList:
    """
    é‚»æ¥è¡¨è¡¨ç¤ºå›¾
    ç©ºé—´å¤æ‚åº¦: O(V + E)
    æ—¶é—´å¤æ‚åº¦:
    - æ£€æŸ¥è¾¹å­˜åœ¨: O(degree)
    - è·å–é‚»å±…: O(degree)
    - æ·»åŠ è¾¹: O(1)
    """
    def __init__(self, num_vertices, directed=False):
        self.num_vertices = num_vertices
        self.directed = directed
        self.adj_list = [[] for _ in range(num_vertices)]

    def add_edge(self, v1, v2, weight=1):
        """æ·»åŠ è¾¹"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            self.adj_list[v1].append((v2, weight))
            if not self.directed:
                self.adj_list[v2].append((v1, weight))

    def remove_edge(self, v1, v2):
        """åˆ é™¤è¾¹"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            self.adj_list[v1] = [(v, w) for v, w in self.adj_list[v1] if v != v2]
            if not self.directed:
                self.adj_list[v2] = [(v, w) for v, w in self.adj_list[v2] if v != v1]

    def has_edge(self, v1, v2):
        """æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            return any(v == v2 for v, _ in self.adj_list[v1])
        return False

    def get_neighbors(self, vertex):
        """è·å–é¡¶ç‚¹çš„é‚»å±…"""
        if 0 <= vertex < self.num_vertices:
            return self.adj_list[vertex].copy()
        return []

    def get_degree(self, vertex):
        """è·å–é¡¶ç‚¹çš„åº¦"""
        if 0 <= vertex < self.num_vertices:
            return len(self.adj_list[vertex])
        return 0

    def __str__(self):
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        result = ""
        for i, neighbors in enumerate(self.adj_list):
            result += f"{i}: {neighbors}\n"
        return result

# ä¼˜ç‚¹ï¼šç©ºé—´æ•ˆç‡é«˜ï¼Œé€‚åˆç¨€ç–å›¾
# ç¼ºç‚¹ï¼šè¾¹å­˜åœ¨æ€§æ£€æŸ¥è¾ƒæ…¢
```

### 3. è¾¹åˆ—è¡¨

```python
class EdgeList:
    """
    è¾¹åˆ—è¡¨è¡¨ç¤ºå›¾
    é€‚åˆéœ€è¦éå†æ‰€æœ‰è¾¹çš„ç®—æ³•
    """
    def __init__(self, num_vertices, directed=False):
        self.num_vertices = num_vertices
        self.directed = directed
        self.edges = []

    def add_edge(self, v1, v2, weight=1):
        """æ·»åŠ è¾¹"""
        if 0 <= v1 < self.num_vertices and 0 <= v2 < self.num_vertices:
            self.edges.append((v1, v2, weight))
            if not self.directed and v1 != v2:
                self.edges.append((v2, v1, weight))

    def remove_edge(self, v1, v2):
        """åˆ é™¤è¾¹"""
        self.edges = [(e1, e2, w) for e1, e2, w in self.edges
                     if not (e1 == v1 and e2 == v2)]
        if not self.directed:
            self.edges = [(e1, e2, w) for e1, e2, w in self.edges
                         if not (e1 == v2 and e2 == v1)]

    def get_all_edges(self):
        """è·å–æ‰€æœ‰è¾¹"""
        return self.edges.copy()

    def get_neighbors(self, vertex):
        """è·å–é¡¶ç‚¹çš„é‚»å±…"""
        neighbors = []
        for v1, v2, weight in self.edges:
            if v1 == vertex:
                neighbors.append((v2, weight))
        return neighbors

# ä¼˜ç‚¹ï¼šèŠ‚çœç©ºé—´ï¼Œé€‚åˆéœ€è¦éå†æ‰€æœ‰è¾¹çš„ç®—æ³•
# ç¼ºç‚¹ï¼šé‚»æ¥æŸ¥è¯¢æ•ˆç‡ä½
```

<ExerciseBlock
  title="å›¾è¡¨ç¤ºé€‰æ‹©"
  question:"å¯¹äºåŒ…å«1000ä¸ªé¡¶ç‚¹å’Œ10ä¸‡æ¡è¾¹çš„ç¤¾äº¤ç½‘ç»œå›¾ï¼Œåº”è¯¥é€‰æ‹©å“ªç§è¡¨ç¤ºæ–¹æ³•ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "é‚»æ¥çŸ©é˜µ",
      correct: false,
      explanation: "1000ä¸ªé¡¶ç‚¹çš„é‚»æ¥çŸ©é˜µéœ€è¦100ä¸‡ç©ºé—´ï¼Œè€Œåªæœ‰10ä¸‡æ¡è¾¹ï¼Œæµªè´¹ç©ºé—´"
    },
    {
      id: "b",
      text: "é‚»æ¥è¡¨",
      correct: true,
      explanation: "æ­£ç¡®ï¼é‚»æ¥è¡¨çš„ç©ºé—´å¤æ‚åº¦æ˜¯O(V+E)ï¼Œé€‚åˆç¨€ç–å›¾"
    },
    {
      id: "c",
      text: "è¾¹åˆ—è¡¨",
      correct: false,
      explanation: "è¾¹åˆ—è¡¨çš„é‚»æ¥æŸ¥è¯¢æ•ˆç‡ä½ï¼Œä¸é€‚åˆéœ€è¦é¢‘ç¹æŸ¥è¯¢é‚»å±…çš„åœºæ™¯"
    },
    {
      id: "d",
      text: "ä¸‰ç§æ–¹æ³•æ•ˆæœç›¸åŒ",
      correct: false,
      explanation: "ä¸åŒè¡¨ç¤ºæ–¹æ³•åœ¨ä¸åŒæ“ä½œä¸Šæœ‰æ˜æ˜¾å·®å¼‚"
    }
  ]}
  hint="è€ƒè™‘å›¾çš„ç¨€ç–ç¨‹åº¦å’Œä¸»è¦æ“ä½œç±»å‹"
/>

## ğŸ” å›¾çš„éå†ç®—æ³•

### 1. å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)

```python
from collections import deque
from typing import List, Set, Dict, Tuple

class BFSTraversal:
    """
    å¹¿åº¦ä¼˜å…ˆæœç´¢
    æ—¶é—´å¤æ‚åº¦: O(V + E)
    ç©ºé—´å¤æ‚åº¦: O(V)
    """
    def __init__(self, graph):
        self.graph = graph

    def bfs(self, start_vertex):
        """æ ‡å‡†BFSéå†"""
        if start_vertex >= self.graph.num_vertices:
            return []

        visited = [False] * self.graph.num_vertices
        queue = deque([start_vertex])
        visited[start_vertex] = True
        traversal_order = []

        while queue:
            current = queue.popleft()
            traversal_order.append(current)

            for neighbor, _ in self.graph.get_neighbors(current):
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)

        return traversal_order

    def bfs_shortest_path(self, start, end):
        """BFSæ±‚æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰"""
        if start >= self.graph.num_vertices or end >= self.graph.num_vertices:
            return []

        visited = [False] * self.graph.num_vertices
        queue = deque([(start, [start])])
        visited[start] = True

        while queue:
            current, path = queue.popleft()

            if current == end:
                return path

            for neighbor, _ in self.graph.get_neighbors(current):
                if not visited[neighbor]:
                    visited[neighbor] = True
                    new_path = path + [neighbor]
                    queue.append((neighbor, new_path))

        return []  # æ²¡æœ‰è·¯å¾„

    def bfs_levels(self, start):
        """BFSæŒ‰å±‚éå†"""
        if start >= self.graph.num_vertices:
            return []

        visited = [False] * self.graph.num_vertices
        queue = deque([(start, 0)])  # (vertex, level)
        visited[start] = True
        levels = []

        while queue:
            current, level = queue.popleft()

            if level >= len(levels):
                levels.append([])

            levels[level].append(current)

            for neighbor, _ in self.graph.get_neighbors(current):
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append((neighbor, level + 1))

        return levels

    def bfs_connected_components(self):
        """ä½¿ç”¨BFSæ‰¾è¿é€šåˆ†é‡"""
        visited = [False] * self.graph.num_vertices
        components = []

        for vertex in range(self.graph.num_vertices):
            if not visited[vertex]:
                component = []
                queue = deque([vertex])
                visited[vertex] = True

                while queue:
                    current = queue.popleft()
                    component.append(current)

                    for neighbor, _ in self.graph.get_neighbors(current):
                        if not visited[neighbor]:
                            visited[neighbor] = True
                            queue.append(neighbor)

                components.append(component)

        return components
```

### 2. æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)

```python
class DFSTraversal:
    """
    æ·±åº¦ä¼˜å…ˆæœç´¢
    æ—¶é—´å¤æ‚åº¦: O(V + E)
    ç©ºé—´å¤æ‚åº¦: O(V)
    """
    def __init__(self, graph):
        self.graph = graph

    def dfs_recursive(self, start_vertex):
        """é€’å½’DFS"""
        if start_vertex >= self.graph.num_vertices:
            return []

        visited = [False] * self.graph.num_vertices
        traversal_order = []

        def dfs_helper(vertex):
            visited[vertex] = True
            traversal_order.append(vertex)

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if not visited[neighbor]:
                    dfs_helper(neighbor)

        dfs_helper(start_vertex)
        return traversal_order

    def dfs_iterative(self, start_vertex):
        """è¿­ä»£DFS"""
        if start_vertex >= self.graph.num_vertices:
            return []

        visited = [False] * self.graph.num_vertices
        stack = [start_vertex]
        traversal_order = []

        while stack:
            current = stack.pop()

            if not visited[current]:
                visited[current] = True
                traversal_order.append(current)

                # å°†é‚»å±…æŒ‰ç›¸åé¡ºåºå‹æ ˆï¼ˆä¿æŒé€’å½’é¡ºåºï¼‰
                for neighbor, _ in reversed(self.graph.get_neighbors(current)):
                    if not visited[neighbor]:
                        stack.append(neighbor)

        return traversal_order

    def dfs_find_path(self, start, end):
        """DFSæŸ¥æ‰¾è·¯å¾„"""
        if start >= self.graph.num_vertices or end >= self.graph.num_vertices:
            return []

        visited = [False] * self.graph.num_vertices
        path = []

        def dfs_helper(current):
            visited[current] = True
            path.append(current)

            if current == end:
                return True

            for neighbor, _ in self.graph.get_neighbors(current):
                if not visited[neighbor]:
                    if dfs_helper(neighbor):
                        return True

            path.pop()
            return False

        if dfs_helper(start):
            return path
        return []

    def dfs_connected_components(self):
        """ä½¿ç”¨DFSæ‰¾è¿é€šåˆ†é‡"""
        visited = [False] * self.graph.num_vertices
        components = []

        for vertex in range(self.graph.num_vertices):
            if not visited[vertex]:
                component = []
                stack = [vertex]
                visited[vertex] = True

                while stack:
                    current = stack.pop()
                    component.append(current)

                    for neighbor, _ in self.graph.get_neighbors(current):
                        if not visited[neighbor]:
                            visited[neighbor] = True
                            stack.append(neighbor)

                components.append(component)

        return components

    def dfs_topological_sort(self):
        """DFSæ‹“æ‰‘æ’åºï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰"""
        visited = [False] * self.graph.num_vertices
        temp_visited = [False] * self.graph.num_vertices  # æ£€æµ‹ç¯
        result = []

        def dfs_helper(vertex):
            temp_visited[vertex] = True

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if temp_visited[neighbor]:
                    raise ValueError("å›¾ä¸­å­˜åœ¨ç¯ï¼Œæ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº")
                if not visited[neighbor]:
                    dfs_helper(neighbor)

            temp_visited[vertex] = False
            visited[vertex] = True
            result.append(vertex)

        for vertex in range(self.graph.num_vertices):
            if not visited[vertex]:
                dfs_helper(vertex)

        return result[::-1]  # åè½¬å¾—åˆ°æ‹“æ‰‘æ’åº
```

### 3. BFS vs DFS å¯¹æ¯”

```python
def bfs_vs_dfs_comparison():
    """
    BFSå’ŒDFSçš„æ¯”è¾ƒ
    """
    comparison = {
        "BFS": {
            "æ•°æ®ç»“æ„": "é˜Ÿåˆ—",
            "å†…å­˜ä½¿ç”¨": "O(w)ï¼Œwæ˜¯æœ€å¤§å®½åº¦",
            "æ‰¾åˆ°çš„è·¯å¾„": "æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰",
            "é€‚ç”¨åœºæ™¯": "æœ€çŸ­è·¯å¾„ã€å±‚æ¬¡éå†",
            "å®ç°å¤æ‚åº¦": "ç®€å•"
        },
        "DFS": {
            "æ•°æ®ç»“æ„": "æ ˆ",
            "å†…å­˜ä½¿ç”¨": "O(h)ï¼Œhæ˜¯æœ€å¤§æ·±åº¦",
            "æ‰¾åˆ°çš„è·¯å¾„": "ä»»æ„è·¯å¾„ï¼Œä¸ä¸€å®šæœ€çŸ­",
            "é€‚ç”¨åœºæ™¯": "æ‹“æ‰‘æ’åºã€è¿é€šæ€§ã€å›æº¯",
            "å®ç°å¤æ‚åº¦": "é€’å½’ç®€å•ï¼Œè¿­ä»£ç¨å¤æ‚"
        }
    }

    print("BFS vs DFS æ¯”è¾ƒï¼š")
    for algorithm, properties in comparison.items():
        print(f"\n{algorithm}:")
        for prop, value in properties.items():
            print(f"  {prop}: {value}")

# åº”ç”¨åœºæ™¯ç¤ºä¾‹
class GraphApplications:
    """å›¾ç®—æ³•åº”ç”¨"""
    def __init__(self, graph):
        self.graph = graph

    def social_network_analysis(self):
        """ç¤¾äº¤ç½‘ç»œåˆ†æ"""
        # ä½¿ç”¨BFSè®¡ç®—æœ€çŸ­è·¯å¾„è·ç¦»
        # ä½¿ç”¨DFSæ‰¾ç¤¾äº¤åœˆ

    def web_crawler(self, start_url):
        """ç½‘ç»œçˆ¬è™«"""
        # ä½¿ç”¨BFSå¹¿åº¦ä¼˜å…ˆçˆ¬å–ç½‘é¡µ
        # ä½¿ç”¨DFSæ·±åº¦ä¼˜å…ˆæ¢ç´¢é“¾æ¥

    def maze_solver(self, maze, start, end):
        """è¿·å®«æ±‚è§£"""
        # ä½¿ç”¨BFSæ‰¾æœ€çŸ­è·¯å¾„
        # ä½¿ç”¨DFSæ‰¾æ‰€æœ‰å¯èƒ½è·¯å¾„

    def dependency_resolution(self):
        """ä¾èµ–è§£æ"""
        # ä½¿ç”¨DFSæ‹“æ‰‘æ’åº
        # æ£€æµ‹å¾ªç¯ä¾èµ–
```

<ExerciseBlock
  title="éå†ç®—æ³•é€‰æ‹©"
  question:"åœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥é€‰æ‹©BFSè€Œä¸æ˜¯DFSï¼Ÿ"
  type="multiple-choice"
  difficulty="easy"
  options={[
    {
      id: "a",
      text: "å½“éœ€è¦æ‰¾æœ€çŸ­è·¯å¾„æ—¶",
      correct: true,
      explanation: "æ­£ç¡®ï¼BFSåœ¨æ— æƒå›¾ä¸­ä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„"
    },
    {
      id: "b",
      text: "å½“éœ€è¦æ‹“æ‰‘æ’åºæ—¶",
      correct: false,
      explanation: "æ‹“æ‰‘æ’åºé€šå¸¸ä½¿ç”¨DFS"
    },
    {
      id: "c",
      text: "å½“å›¾å¾ˆæ·±ä½†å¾ˆçª„æ—¶",
      correct: false,
      explanation: "DFSåœ¨è¿™ç§æƒ…å†µå†…å­˜æ•ˆç‡æ›´é«˜"
    },
    {
      id: "d",
      text: "å½“éœ€è¦æ£€æµ‹ç¯æ—¶",
      correct: false,
      explanation: "BFSå’ŒDFSéƒ½å¯ä»¥æ£€æµ‹ç¯"
    }
  ]}
  hint="è€ƒè™‘BFSçš„ç‰¹æ€§ï¼šå±‚æ¬¡éå†å’Œæœ€çŸ­è·¯å¾„"
/>

## ğŸ¯ è¿é€šæ€§åˆ†æ

### 1. æ— å‘å›¾çš„è¿é€šæ€§

```python
class ConnectivityAnalyzer:
    """
    è¿é€šæ€§åˆ†æå™¨
    """
    def __init__(self, graph):
        self.graph = graph

    def is_connected(self):
        """æ£€æŸ¥å›¾æ˜¯å¦è¿é€š"""
        if self.graph.num_vertices == 0:
            return True

        # ä½¿ç”¨BFSæˆ–DFSä»ä¸€ä¸ªé¡¶ç‚¹å¼€å§‹éå†
        visited = set()
        stack = [0]
        visited.add(0)

        while stack:
            current = stack.pop()
            for neighbor, _ in self.graph.get_neighbors(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    stack.append(neighbor)

        return len(visited) == self.graph.num_vertices

    def get_connected_components(self):
        """è·å–æ‰€æœ‰è¿é€šåˆ†é‡"""
        visited = [False] * self.graph.num_vertices
        components = []

        for vertex in range(self.graph.num_vertices):
            if not visited[vertex]:
                component = self._dfs_component(vertex, visited)
                components.append(component)

        return components

    def _dfs_component(self, start, visited):
        """DFSè·å–è¿é€šåˆ†é‡"""
        component = []
        stack = [start]
        visited[start] = True

        while stack:
            current = stack.pop()
            component.append(current)

            for neighbor, _ in self.graph.get_neighbors(current):
                if not visited[neighbor]:
                    visited[neighbor] = True
                    stack.append(neighbor)

        return component

    def find_bridges(self):
        """æ‰¾åˆ°æ‰€æœ‰çš„æ¡¥ï¼ˆå‰²è¾¹ï¼‰"""
        if self.graph.directed:
            raise ValueError("æ¡¥çš„å®šä¹‰ä»…é€‚ç”¨äºæ— å‘å›¾")

        discovery_time = [-1] * self.graph.num_vertices
        low = [-1] * self.graph.num_vertices
        parent = [-1] * self.graph.num_vertices
        bridges = []
        time = [0]

        def dfs_bridges(vertex):
            discovery_time[vertex] = time[0]
            low[vertex] = time[0]
            time[0] += 1

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if discovery_time[neighbor] == -1:  # æœªè®¿é—®
                    parent[neighbor] = vertex
                    dfs_bridges(neighbor)

                    low[vertex] = min(low[vertex], low[neighbor])

                    # æ£€æŸ¥æ˜¯å¦æ˜¯æ¡¥
                    if low[neighbor] > discovery_time[vertex]:
                        bridges.append((vertex, neighbor))

                elif neighbor != parent[vertex]:  # å·²è®¿é—®ä¸”ä¸æ˜¯çˆ¶èŠ‚ç‚¹
                    low[vertex] = min(low[vertex], discovery_time[neighbor])

        for vertex in range(self.graph.num_vertices):
            if discovery_time[vertex] == -1:
                dfs_bridges(vertex)

        return bridges

    def find_articulation_points(self):
        """æ‰¾åˆ°æ‰€æœ‰çš„å‰²ç‚¹"""
        if self.graph.directed:
            raise ValueError("å‰²ç‚¹çš„å®šä¹‰ä»…é€‚ç”¨äºæ— å‘å›¾")

        discovery_time = [-1] * self.graph.num_vertices
        low = [-1] * self.graph.num_vertices
        parent = [-1] * self.graph.num_vertices
        articulation_points = set()
        time = [0]

        def dfs_articulation_points(vertex):
            discovery_time[vertex] = time[0]
            low[vertex] = time[0]
            time[0] += 1
            children = 0

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if discovery_time[neighbor] == -1:  # æœªè®¿é—®
                    parent[neighbor] = vertex
                    children += 1
                    dfs_articulation_points(neighbor)

                    low[vertex] = min(low[vertex], low[neighbor])

                    # æ£€æŸ¥æ˜¯å¦æ˜¯å‰²ç‚¹
                    # æ¡ä»¶1ï¼šæ ¹èŠ‚ç‚¹ä¸”æœ‰å¤šä¸ªå­æ ‘
                    if parent[vertex] == -1 and children > 1:
                        articulation_points.add(vertex)

                    # æ¡ä»¶2ï¼šéæ ¹èŠ‚ç‚¹ä¸”low[neighbor] >= discovery_time[vertex]
                    if parent[vertex] != -1 and low[neighbor] >= discovery_time[vertex]:
                        articulation_points.add(vertex)

                elif neighbor != parent[vertex]:  # å·²è®¿é—®ä¸”ä¸æ˜¯çˆ¶èŠ‚ç‚¹
                    low[vertex] = min(low[vertex], discovery_time[neighbor])

        for vertex in range(self.graph.num_vertices):
            if discovery_time[vertex] == -1:
                dfs_articulation_points(vertex)

        return list(articulation_points)
```

### 2. æœ‰å‘å›¾çš„å¼ºè¿é€šæ€§

```python
class StrongConnectivityAnalyzer:
    """
    å¼ºè¿é€šæ€§åˆ†æ
    """
    def __init__(self, graph):
        self.graph = graph
        if not graph.directed:
            raise ValueError("å¼ºè¿é€šæ€§ä»…é€‚ç”¨äºæœ‰å‘å›¾")

    def kosaraju_scc(self):
        """
        Kosarajuç®—æ³•æ‰¾å¼ºè¿é€šåˆ†é‡
        æ—¶é—´å¤æ‚åº¦: O(V + E)
        """
        # ç¬¬ä¸€æ¬¡DFSï¼šè®¡ç®—å®Œæˆæ—¶é—´
        visited = [False] * self.graph.num_vertices
        finish_order = []

        def first_dfs(vertex):
            visited[vertex] = True
            for neighbor, _ in self.graph.get_neighbors(vertex):
                if not visited[neighbor]:
                    first_dfs(neighbor)
            finish_order.append(vertex)

        for vertex in range(self.graph.num_vertices):
            if not visited[vertex]:
                first_dfs(vertex)

        # è½¬ç½®å›¾
        reversed_graph = self._transpose_graph()

        # ç¬¬äºŒæ¬¡DFSï¼šæŒ‰å®Œæˆæ—¶é—´é€†åºéå†
        visited = [False] * self.graph.num_vertices
        sccs = []

        finish_order.reverse()  # æŒ‰å®Œæˆæ—¶é—´é™åº

        for vertex in finish_order:
            if not visited[vertex]:
                scc = []
                stack = [vertex]
                visited[vertex] = True

                while stack:
                    current = stack.pop()
                    scc.append(current)

                    # åœ¨è½¬ç½®å›¾ä¸­éå†
                    for neighbor, _ in reversed_graph.get_neighbors(current):
                        if not visited[neighbor]:
                            visited[neighbor] = True
                            stack.append(neighbor)

                sccs.append(scc)

        return sccs

    def _transpose_graph(self):
        """æ„å»ºè½¬ç½®å›¾"""
        transposed = AdjacencyList(self.graph.num_vertices, directed=True)

        for vertex in range(self.graph.num_vertices):
            for neighbor, weight in self.graph.get_neighbors(vertex):
                transposed.add_edge(neighbor, vertex, weight)

        return transposed

    def tarjan_scc(self):
        """
        Tarjanç®—æ³•æ‰¾å¼ºè¿é€šåˆ†é‡
        å•æ¬¡DFSå®ç°
        """
        index = [0]  # å½“å‰DFSç´¢å¼•
        indices = [-1] * self.graph.num_vertices  # é¡¶ç‚¹ç´¢å¼•
        low_link = [-1] * self.graph.num_vertices  # ä½é“¾æ¥å€¼
        on_stack = [False] * self.graph.num_vertices  # æ˜¯å¦åœ¨æ ˆä¸­
        stack = []
        sccs = []

        def strongconnect(vertex):
            indices[vertex] = index[0]
            low_link[vertex] = index[0]
            index[0] += 1
            stack.append(vertex)
            on_stack[vertex] = True

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if indices[neighbor] == -1:  # æœªè®¿é—®
                    strongconnect(neighbor)
                    low_link[vertex] = min(low_link[vertex], low_link[neighbor])
                elif on_stack[neighbor]:  # å·²è®¿é—®ä¸”åœ¨æ ˆä¸­
                    low_link[vertex] = min(low_link[vertex], indices[neighbor])

            # å¦‚æœæ˜¯å¼ºè¿é€šåˆ†é‡çš„æ ¹
            if low_link[vertex] == indices[vertex]:
                scc = []
                while True:
                    w = stack.pop()
                    on_stack[w] = False
                    scc.append(w)
                    if w == vertex:
                        break
                sccs.append(scc)

        for vertex in range(self.graph.num_vertices):
            if indices[vertex] == -1:
                strongconnect(vertex)

        return sccs

    def is_strongly_connected(self):
        """æ£€æŸ¥å›¾æ˜¯å¦å¼ºè¿é€š"""
        if self.graph.num_vertices == 0:
            return True

        # ä½¿ç”¨Kosarajuç®—æ³•
        sccs = self.kosaraju_scc()
        return len(sccs) == 1
```

## ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

### 1. ç¤¾äº¤ç½‘ç»œåˆ†æ

```python
class SocialNetworkAnalyzer:
    """
    ç¤¾äº¤ç½‘ç»œåˆ†æå·¥å…·
    """
    def __init__(self):
        self.graph = AdjacencyList(directed=False)  # æ— å‘å›¾

    def add_friendship(self, user1, user2):
        """æ·»åŠ å¥½å‹å…³ç³»"""
        self.graph.add_edge(user1, user2)

    def find_mutual_friends(self, user1, user2):
        """æ‰¾åˆ°å…±åŒå¥½å‹"""
        friends1 = set(n for n, _ in self.graph.get_neighbors(user1))
        friends2 = set(n for n, _ in self.graph.get_neighbors(user2))
        return friends1 & friends2

    def find_friend_suggestions(self, user, max_suggestions=5):
        """å¥½å‹æ¨è"""
        # åŸºäºå…±åŒå¥½å‹æ•°é‡æ¨è
        suggestions = {}
        friends = set(n for n, _ in self.graph.get_neighbors(user))

        for friend in friends:
            for friend_of_friend, _ in self.graph.get_neighbors(friend):
                if friend_of_friend != user and friend_of_friend not in friends:
                    suggestions[friend_of_friend] = suggestions.get(friend_of_friend, 0) + 1

        # æ’åºå¹¶è¿”å›å‰Nä¸ªå»ºè®®
        sorted_suggestions = sorted(suggestions.items(), key=lambda x: x[1], reverse=True)
        return [user for user, count in sorted_suggestions[:max_suggestions]]

    def find_shortest_friend_chain(self, user1, user2):
        """æ‰¾åˆ°æœ€çŸ­å¥½å‹é“¾"""
        bfs = BFSTraversal(self.graph)
        return bfs.bfs_shortest_path(user1, user2)

    def analyze_social_circles(self):
        """åˆ†æç¤¾äº¤åœˆï¼ˆè¿é€šåˆ†é‡ï¼‰"""
        analyzer = ConnectivityAnalyzer(self.graph)
        return analyzer.get_connected_components()

    def find_influential_users(self):
        """æ‰¾åˆ°æœ‰å½±å“åŠ›çš„ç”¨æˆ·ï¼ˆé«˜ä¸­å¿ƒæ€§ï¼‰"""
        degrees = []
        for vertex in range(self.graph.num_vertices):
            degree = self.graph.get_degree(vertex)
            degrees.append((vertex, degree))

        # æŒ‰åº¦æ•°æ’åº
        return sorted(degrees, key=lambda x: x[1], reverse=True)
```

### 2. ç½‘ç»œè·¯ç”±åˆ†æ

```python
class NetworkRouter:
    """
    ç½‘ç»œè·¯ç”±åˆ†æ
    """
    def __init__(self):
        self.graph = AdjacencyList(directed=True)  # æœ‰å‘å›¾
        self.routers = {}  # è·¯ç”±å™¨ä¿¡æ¯

    def add_router(self, router_id, location):
        """æ·»åŠ è·¯ç”±å™¨"""
        self.routers[router_id] = {"location": location}

    def add_connection(self, router1, router2, latency=1):
        """æ·»åŠ è¿æ¥"""
        self.graph.add_edge(router1, router2, latency)

    def find_path_with_min_hops(self, source, destination):
        """æ‰¾åˆ°è·³æ•°æœ€å°‘çš„è·¯å¾„"""
        bfs = BFSTraversal(self.graph)
        return bfs.bfs_shortest_path(source, destination)

    def find_all_paths(self, source, destination, max_hops=10):
        """æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„è·¯å¾„ï¼ˆDFSï¼‰"""
        dfs = DFSTraversal(self.graph)
        paths = []
        visited = [False] * self.graph.num_vertices

        def dfs_find_paths(current, path, hops):
            if hops > max_hops:
                return

            if current == destination:
                paths.append(path.copy())
                return

            visited[current] = True

            for neighbor, _ in self.graph.get_neighbors(current):
                if not visited[neighbor]:
                    path.append(neighbor)
                    dfs_find_paths(neighbor, path, hops + 1)
                    path.pop()

            visited[current] = False

        visited[source] = True
        dfs_find_paths(source, [source], 0)

        return paths

    def detect_cycles(self):
        """æ£€æµ‹ç½‘ç»œä¸­çš„ç¯"""
        visited = [False] * self.graph.num_vertices
        recursion_stack = [False] * self.graph.num_vertices
        cycles = []

        def dfs_cycle(vertex, path):
            visited[vertex] = True
            recursion_stack[vertex] = True
            path.append(vertex)

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if not visited[neighbor]:
                    if dfs_cycle(neighbor, path):
                        return True
                elif recursion_stack[neighbor]:
                    # æ‰¾åˆ°ç¯
                    cycle_start = path.index(neighbor)
                    cycle = path[cycle_start:] + [neighbor]
                    cycles.append(cycle)
                    return True

            path.pop()
            recursion_stack[vertex] = False
            return False

        for vertex in range(self.graph.num_vertices):
            if not visited[vertex]:
                dfs_cycle(vertex, [])

        return cycles

    def find_bottlenecks(self):
        """æ‰¾åˆ°ç½‘ç»œç“¶é¢ˆï¼ˆå‰²ç‚¹ï¼‰"""
        analyzer = ConnectivityAnalyzer(self.graph)
        return analyzer.find_articulation_points()
```

### 3. ä¾èµ–è§£æç³»ç»Ÿ

```python
class DependencyResolver:
    """
    ä¾èµ–è§£æç³»ç»Ÿ
    """
    def __init__(self):
        self.graph = AdjacencyList(directed=True)
        self.components = {}  # ç»„ä»¶ä¿¡æ¯

    def add_component(self, component_id, component_info):
        """æ·»åŠ ç»„ä»¶"""
        self.components[component_id] = component_info

    def add_dependency(self, component_id, depends_on):
        """æ·»åŠ ä¾èµ–å…³ç³»"""
        self.graph.add_edge(depends_on, component_id)

    def resolve_build_order(self):
        """è§£ææ„å»ºé¡ºåºï¼ˆæ‹“æ‰‘æ’åºï¼‰"""
        dfs = DFSTraversal(self.graph)
        try:
            return dfs.dfs_topological_sort()
        except ValueError as e:
            print(f"ä¾èµ–é”™è¯¯: {e}")
            return None

    def detect_circular_dependencies(self):
        """æ£€æµ‹å¾ªç¯ä¾èµ–"""
        try:
            self.resolve_build_order()
            return []
        except ValueError:
            # ä½¿ç”¨DFSæ‰¾åˆ°å…·ä½“ç¯
            visited = [False] * self.graph.num_vertices
            recursion_stack = [False] * self.graph.num_vertices
            cycles = []

            def find_cycle(vertex, path):
                visited[vertex] = True
                recursion_stack[vertex] = True
                path.append(vertex)

                for neighbor, _ in self.graph.get_neighbors(vertex):
                    if not visited[neighbor]:
                        if find_cycle(neighbor, path):
                            return True
                    elif recursion_stack[neighbor]:
                        cycle_start = path.index(neighbor)
                        cycle = path[cycle_start:] + [neighbor]
                        cycles.append(cycle)
                        return True

                path.pop()
                recursion_stack[vertex] = False
                return False

            for vertex in range(self.graph.num_vertices):
                if not visited[vertex]:
                    find_cycle(vertex, [])

            return cycles

    def find_affected_components(self, changed_component):
        """æ‰¾åˆ°å—å½±å“çš„ç»„ä»¶"""
        # ä½¿ç”¨BFSæ‰¾åˆ°æ‰€æœ‰ä¾èµ–è¯¥ç»„ä»¶çš„ç»„ä»¶
        bfs = BFSTraversal(self.graph)
        affected = bfs.bfs(changed_component)
        return affected[1:]  # æ’é™¤ç»„ä»¶æœ¬èº«

    def get_component_info(self, component_id):
        """è·å–ç»„ä»¶è¯¦ç»†ä¿¡æ¯"""
        if component_id in self.components:
            info = self.components[component_id].copy()
            dependencies = [n for n, _ in self.graph.get_neighbors(component_id)]
            dependents = []
            for v in range(self.graph.num_vertices):
                if any(n == component_id for n, _ in self.graph.get_neighbors(v)):
                    dependents.append(v)

            info.update({
                "dependencies": dependencies,
                "dependents": dependents
            })
            return info
        return None
```

<ExerciseBlock
  title="å®é™…åº”ç”¨"
  question:"åœ¨ä¸€ä¸ªå¤§å‹è½¯ä»¶é¡¹ç›®ä¸­ï¼Œéœ€è¦åˆ†ææ¨¡å—é—´çš„ä¾èµ–å…³ç³»æ¥ç¡®å®šç¼–è¯‘é¡ºåºã€‚åº”è¯¥ä½¿ç”¨ä»€ä¹ˆå›¾ç®—æ³•ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "BFSæ±‚æœ€çŸ­è·¯å¾„",
      correct: false,
      explanation: "æˆ‘ä»¬éœ€è¦ç¼–è¯‘é¡ºåºï¼Œä¸æ˜¯æœ€çŸ­è·¯å¾„"
    },
    {
      id: "b",
      text: "DFSæ‹“æ‰‘æ’åº",
      correct: true,
      explanation: "æ­£ç¡®ï¼æ‹“æ‰‘æ’åºå¯ä»¥ç¡®å®šä¾èµ–å…³ç³»å’Œç¼–è¯‘é¡ºåº"
    },
    {
      id: "c",
      text: "å¼ºè¿é€šåˆ†é‡",
      correct: false,
      explanation: "å¼ºè¿é€šåˆ†é‡ç”¨äºåˆ†æç›¸äº’ä¾èµ–çš„æ¨¡å—ç»„"
    },
    {
      id: "d",
      text: "æœ€å°ç”Ÿæˆæ ‘",
      correct: false,
      explanation: "æœ€å°ç”Ÿæˆæ ‘ç”¨äºä¼˜åŒ–è¿æ¥æˆæœ¬"
    }
  ]}
  hint="è€ƒè™‘ä¾èµ–å…³ç³»çš„æœ‰å‘æ€§å’Œç¼–è¯‘é¡ºåºè¦æ±‚"
/>

## ğŸ“Š æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### å›¾ç®—æ³•æ€§èƒ½å¯¹æ¯”

```python
def graph_algorithm_performance():
    """
    å›¾ç®—æ³•æ€§èƒ½åˆ†æ
    """
    performance_data = {
        "BFS": {
            "time_complexity": "O(V + E)",
            "space_complexity": "O(V)",
            "best_for": "æœ€çŸ­è·¯å¾„ã€å±‚æ¬¡éå†",
            "worst_case": "ç¨€ç–å›¾å†…å­˜ä½¿ç”¨è¾ƒå¤š"
        },
        "DFS": {
            "time_complexity": "O(V + E)",
            "space_complexity": "O(V)",
            "best_for": "æ‹“æ‰‘æ’åºã€è¿é€šæ€§æ£€æµ‹",
            "worst_case": "æ·±åº¦å¾ˆå¤§çš„å›¾å¯èƒ½å¯¼è‡´æ ˆæº¢å‡º"
        },
        "Kosaraju": {
            "time_complexity": "O(V + E)",
            "space_complexity": "O(V)",
            "best_for": "å¼ºè¿é€šåˆ†é‡",
            "worst_case": "éœ€è¦ä¸¤æ¬¡DFSå’Œè½¬ç½®å›¾"
        },
        "Tarjan": {
            "time_complexity": "O(V + E)",
            "space_complexity": "O(V)",
            "best_for": "å¼ºè¿é€šåˆ†é‡ï¼ˆå•æ¬¡DFSï¼‰",
            "worst_case": "å®ç°è¾ƒå¤æ‚"
        }
    }

    return performance_data

# æ€§èƒ½æµ‹è¯•ç¤ºä¾‹
performance_data = [
    {"n": 1000, "time": 0.01, "algorithm": "BFS"},
    {"n": 10000, "time": 0.12, "algorithm": "BFS"},
    {"n": 100000, "time": 1.45, "algorithm": "BFS"},
    {"n": 1000000, "time": 15.8, "algorithm": "BFS"}
]
```

<ComplexityAnalyzer
  title="BFSæ€§èƒ½åˆ†æ"
  algorithm="å¹¿åº¦ä¼˜å…ˆæœç´¢"
  theoreticalComplexity="O(V + E)"
  data={performance_data}
  color="rgb(59, 130, 246)"
/>

### ä¼˜åŒ–ç­–ç•¥

```python
class OptimizedGraphAlgorithms:
    """
    ä¼˜åŒ–çš„å›¾ç®—æ³•å®ç°
    """
    def __init__(self, graph):
        self.graph = graph

    def bfs_bidirectional(self, start, end):
        """
        åŒå‘BFS - æ›´å¿«çš„æœ€çŸ­è·¯å¾„æŸ¥æ‰¾
        æ—¶é—´å¤æ‚åº¦: O(b^(d/2))ï¼Œå…¶ä¸­bæ˜¯åˆ†æ”¯å› å­ï¼Œdæ˜¯è·ç¦»
        """
        if start == end:
            return [start]

        # æ­£å‘æœç´¢
        forward_queue = deque([(start, [start])])
        forward_visited = {start: [start]}

        # åå‘æœç´¢
        backward_queue = deque([(end, [end])])
        backward_visited = {end: [end]}

        while forward_queue and backward_queue:
            # æ­£å‘æœç´¢ä¸€æ­¥
            if len(forward_queue) <= len(backward_queue):
                current, path = forward_queue.popleft()

                for neighbor, _ in self.graph.get_neighbors(current):
                    if neighbor not in forward_visited:
                        new_path = path + [neighbor]
                        forward_visited[neighbor] = new_path
                        forward_queue.append((neighbor, new_path))

                        # æ£€æŸ¥æ˜¯å¦åœ¨åå‘æœç´¢ä¸­è®¿é—®è¿‡
                        if neighbor in backward_visited:
                            return new_path[:-1] + backward_visited[neighbor]

            # åå‘æœç´¢ä¸€æ­¥
            else:
                current, path = backward_queue.popleft()

                for neighbor, _ in self.graph.get_neighbors(current):
                    if neighbor not in backward_visited:
                        new_path = [neighbor] + path
                        backward_visited[neighbor] = new_path
                        backward_queue.append((neighbor, new_path))

                        # æ£€æŸ¥æ˜¯å¦åœ¨æ­£å‘æœç´¢ä¸­è®¿é—®è¿‡
                        if neighbor in forward_visited:
                            return forward_visited[neighbor] + new_path[1:]

        return []  # æ²¡æœ‰è·¯å¾„

    def dfs_iterative_deepening(self, start, goal, max_depth):
        """
        è¿­ä»£åŠ æ·±DFS - ç»“åˆBFSå’ŒDFSçš„ä¼˜ç‚¹
        ç©ºé—´å¤æ‚åº¦: O(d)ï¼Œå…¶ä¸­dæ˜¯æ·±åº¦
        """
        def depth_limited_search(vertex, depth, path, visited):
            if depth == 0:
                if vertex == goal:
                    return path
                return None

            visited.add(vertex)

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if neighbor not in visited:
                    result = depth_limited_search(neighbor, depth - 1, path + [neighbor], visited.copy())
                    if result:
                        return result

            return None

        for depth in range(1, max_depth + 1):
            result = depth_limited_search(start, depth, [start], set())
            if result:
                return result

        return None

    def a_star_search(self, start, goal, heuristic):
        """
        A*æœç´¢ç®—æ³• - å¯å‘å¼æœç´¢
        """
        import heapq

        def heuristic_distance(node1, node2):
            """å¯å‘å¼å‡½æ•°"""
            return heuristic(node1, node2)

        open_set = [(0, start)]
        came_from = {}
        g_score = {start: 0}
        f_score = {start: heuristic_distance(start, goal)}

        while open_set:
            current_f, current = heapq.heappop(open_set)

            if current == goal:
                # é‡å»ºè·¯å¾„
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                path.append(start)
                return path[::-1]

            for neighbor, weight in self.graph.get_neighbors(current):
                tentative_g = g_score[current] + weight

                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + heuristic_distance(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return []  # æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
```

<ExerciseBlock
  title="æ€§èƒ½ä¼˜åŒ–"
  question:"åœ¨ä¸€ä¸ªéå¸¸å¤§çš„ç¤¾äº¤ç½‘ç»œä¸­ï¼Œè¦æ‰¾åˆ°ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œå“ªç§ç®—æ³•æœ€åˆé€‚ï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "æ ‡å‡†BFS",
      correct: false,
      explanation: "å¯¹å¤§å›¾æ¥è¯´å†…å­˜æ¶ˆè€—å¤ªå¤§"
    },
    {
      id: "b",
      text: "åŒå‘BFS",
      correct: true,
      explanation: "æ­£ç¡®ï¼åŒå‘BFSå¯ä»¥å¤§å¹…å‡å°‘æœç´¢ç©ºé—´"
    },
    {
      id: "c",
      text: "DFS",
      correct: false,
      explanation: "DFSä¸ä¸€å®šæ‰¾åˆ°æœ€çŸ­è·¯å¾„"
    },
    {
      id: "d",
      text: "A*ç®—æ³•",
      correct: false,
      explanation: "A*éœ€è¦å¥½çš„å¯å‘å¼å‡½æ•°ï¼Œç¤¾äº¤ç½‘ç»œå¾ˆéš¾å®šä¹‰"
    }
  ]}
  hint="è€ƒè™‘æœç´¢ç©ºé—´çš„å‡å°‘å’Œå†…å­˜æ•ˆç‡"
/>

## ğŸ“ æ€»ç»“ä¸æœ€ä½³å®è·µ

### å…³é”®è¦ç‚¹

1. **å›¾è¡¨ç¤ºé€‰æ‹©**ï¼š
   - ç¨ å¯†å›¾ï¼šé‚»æ¥çŸ©é˜µ
   - ç¨€ç–å›¾ï¼šé‚»æ¥è¡¨
   - è¾¹éå†ï¼šè¾¹åˆ—è¡¨

2. **éå†ç®—æ³•é€‰æ‹©**ï¼š
   - æœ€çŸ­è·¯å¾„ï¼šBFS
   - æ‹“æ‰‘æ’åºï¼šDFS
   - è¿é€šæ€§ï¼šBFSæˆ–DFS
   - å¼ºè¿é€šæ€§ï¼šKosarajuæˆ–Tarjan

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - åŒå‘æœç´¢å‡å°‘æœç´¢ç©ºé—´
   - è¿­ä»£åŠ æ·±æ§åˆ¶å†…å­˜ä½¿ç”¨
   - å¯å‘å¼æœç´¢æé«˜æ•ˆç‡

### å®é™…åº”ç”¨å»ºè®®

```python
def graph_algorithm_recommendation(problem_type: str) -> str:
    """
    æ ¹æ®é—®é¢˜ç±»å‹æ¨èå›¾ç®—æ³•
    """
    recommendations = {
        "shortest_path_unweighted": "BFS",
        "shortest_path_weighted": "Dijkstra",
        "negative_weights": "Bellman-Ford",
        "all_pairs_shortest": "Floyd-Warshall",
        "topological_sort": "DFS",
        "connected_components": "BFS/DFS",
        "strongly_connected": "Kosaraju/Tarjan",
        "cycle_detection": "DFS",
        "minimum_spanning_tree": "Kruskal/Prim",
        "network_flow": "Ford-Fulkerson",
        "bipartite_matching": "Hopcroft-Karp",
        "graph_coloring": "å›æº¯ç®—æ³•"
    }

    return recommendations.get(problem_type, "æ ¹æ®å…·ä½“éœ€æ±‚åˆ†æ")
```

### å›¾ç®—æ³•è®¾è®¡æ¨¡å¼

```python
class GraphAlgorithmPatterns:
    """å›¾ç®—æ³•è®¾è®¡æ¨¡å¼"""
    def __init__(self, graph):
        self.graph = graph

    def multi_source_bfs(self, sources):
        """å¤šæºBFS"""
        queue = deque([(source, 0) for source in sources])
        visited = {source: 0 for source in sources}

        while queue:
            vertex, distance = queue.popleft()

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if neighbor not in visited:
                    visited[neighbor] = distance + 1
                    queue.append((neighbor, distance + 1))

        return visited

    def bfs_with_levels(self, start):
        """å¸¦å±‚æ¬¡ä¿¡æ¯çš„BFS"""
        from collections import defaultdict
        levels = defaultdict(list)
        queue = deque([(start, 0)])
        visited = {start}

        while queue:
            vertex, level = queue.popleft()
            levels[level].append(vertex)

            for neighbor, _ in self.graph.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, level + 1))

        return dict(levels)

    def dfs_with_path_tracking(self, start, goal):
        """å¸¦è·¯å¾„è·Ÿè¸ªçš„DFS"""
        def dfs_helper(current, path, visited):
            if current == goal:
                return path.copy()

            visited.add(current)

            for neighbor, _ in self.graph.get_neighbors(current):
                if neighbor not in visited:
                    path.append(neighbor)
                    result = dfs_helper(neighbor, path, visited)
                    if result:
                        return result
                    path.pop()

            return None

        return dfs_helper(start, [start], set())
```

<ExerciseBlock
  title="ç« èŠ‚æµ‹éªŒ"
  question:"åœ¨ä¸€ä¸ªæ— å‘å›¾ä¸­ï¼Œå¦‚ä½•åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä»é¡¶ç‚¹Aåˆ°é¡¶ç‚¹Bçš„è·¯å¾„ï¼Ÿ"
  type="multiple-choice"
  difficulty="easy"
  options={[
    {
      id: "a",
      text: "ä½¿ç”¨BFSæˆ–DFSä»Aå¼€å§‹æœç´¢",
      correct: true,
      explanation: "æ­£ç¡®ï¼BFSæˆ–DFSéƒ½å¯ä»¥åˆ¤æ–­è¿é€šæ€§"
    },
    {
      id: "b",
      text: "è®¡ç®—Aå’ŒBçš„åº¦æ•°",
      correct: false,
      explanation: "åº¦æ•°ä¸èƒ½ç›´æ¥åˆ¤æ–­è¿é€šæ€§"
    },
    {
      id: "c",
      text: "æ£€æŸ¥Aå’ŒBæ˜¯å¦åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ä¸­",
      correct: true,
      explanation: "æ­£ç¡®ï¼è¿™æ˜¯åˆ¤æ–­è¿é€šæ€§çš„æ­£å¼æ–¹æ³•"
    },
    {
      id: "d",
      text: "ä½¿ç”¨æ‹“æ‰‘æ’åº",
      correct: false,
      explanation: "æ‹“æ‰‘æ’åºé€‚ç”¨äºæœ‰å‘æ— ç¯å›¾"
    }
  ]}
  hint="è€ƒè™‘è¿é€šæ€§çš„å®šä¹‰å’Œåˆ¤æ–­æ–¹æ³•"
/>

---

## ğŸš€ è¯¾åç»ƒä¹ 

1. **åŸºç¡€ç»ƒä¹ **ï¼šå®ç°å„ç§å›¾è¡¨ç¤ºæ–¹æ³•å’Œéå†ç®—æ³•
2. **è¿›é˜¶ç»ƒä¹ **ï¼šå®ç°å¼ºè¿é€šåˆ†é‡å’Œå‰²ç‚¹æ£€æµ‹ç®—æ³•
3. **å®æˆ˜ç»ƒä¹ **ï¼šæ„å»ºç¤¾äº¤ç½‘ç»œåˆ†æå·¥å…·
4. **é¡¹ç›®ç»ƒä¹ **ï¼šè®¾è®¡ç½‘ç»œè·¯ç”±åˆ†æç³»ç»Ÿ

**è®°ä½**ï¼šå›¾ç®—æ³•æ˜¯è§£å†³å¤æ‚å…³ç³»é—®é¢˜çš„å¼ºå¤§å·¥å…·ï¼ŒæŒæ¡å®ƒä»¬å°†å¤§å¤§æå‡ä½ çš„é—®é¢˜è§£å†³èƒ½åŠ›ï¼ğŸŒ