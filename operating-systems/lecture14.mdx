---
sidebar_position: 14
title: 第14讲 - 设备驱动程序与I/O系统
description: 设备驱动程序架构、中断处理机制、DMA和I/O优化技术
---

# 第14讲 - 设备驱动程序与I/O系统

## 课程概述

本讲深入探讨操作系统中的设备管理和I/O系统，包括设备驱动程序架构、中断处理机制、DMA技术、I/O优化策略等。通过理解硬件与软件的接口，学习如何设计高效的I/O子系统。

## 学习目标

- 理解设备驱动程序的基本架构和工作原理
- 掌握中断处理机制和中断控制器
- 学习DMA技术和直接内存访问
- 理解块设备和字符设备的区别
- 掌握I/O性能优化技术

## 主要内容

### 1. 设备驱动程序架构

#### 1.1 设备分类和驱动模型

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>

// 设备类型枚举
typedef enum {
    DEVICE_TYPE_CHAR,    // 字符设备
    DEVICE_TYPE_BLOCK,   // 块设备
    DEVICE_TYPE_NETWORK, // 网络设备
    DEVICE_TYPE_MISC     // 杂项设备
} device_type;

// 设备驱动程序结构
typedef struct {
    char* name;              // 驱动程序名称
    device_type type;        // 设备类型
    dev_t dev_num;           // 设备号
    struct cdev cdev;        // 字符设备结构
    struct class* class;     // 设备类
    struct device* device;   // 设备实例
    void* private_data;      // 私有数据

    // 驱动程序操作函数指针
    int (*open)(struct inode*, struct file*);
    int (*release)(struct inode*, struct file*);
    ssize_t (*read)(struct file*, char __user*, size_t, loff_t*);
    ssize_t (*write)(struct file*, const char __user*, size_t, loff_t*);
    int (*ioctl)(struct file*, unsigned int, unsigned long);

    // 设备特定操作
    void (*init_device)(void);
    void (*cleanup_device)(void);
    int (*probe)(struct device*);
    void (*remove)(struct device*);
} device_driver;

// 设备信息结构
typedef struct {
    char* device_name;       // 设备名称
    unsigned int vendor_id;   // 厂商ID
    unsigned int device_id;   // 设备ID
    unsigned int class_id;    // 设备类别
    unsigned int subsystem_id; // 子系统ID
    void* hardware_specific;  // 硬件特定数据
} device_info;

// 注册设备驱动程序
int register_device_driver(device_driver* driver, device_info* info) {
    int ret;

    printk(KERN_INFO "注册设备驱动程序: %s\n", driver->name);

    // 分配设备号
    ret = alloc_chrdev_region(&driver->dev_num, 0, 1, driver->name);
    if (ret < 0) {
        printk(KERN_ERR "无法分配设备号\n");
        return ret;
    }

    // 初始化字符设备
    cdev_init(&driver->cdev, &driver_fops);
    driver->cdev.owner = THIS_MODULE;

    // 添加字符设备
    ret = cdev_add(&driver->cdev, driver->dev_num, 1);
    if (ret < 0) {
        printk(KERN_ERR "无法添加字符设备\n");
        unregister_chrdev_region(driver->dev_num, 1);
        return ret;
    }

    // 创建设备类
    driver->class = class_create(THIS_MODULE, driver->name);
    if (IS_ERR(driver->class)) {
        printk(KERN_ERR "无法创建设备类\n");
        cdev_del(&driver->cdev);
        unregister_chrdev_region(driver->dev_num, 1);
        return PTR_ERR(driver->class);
    }

    // 创建设备文件
    driver->device = device_create(driver->class, NULL, driver->dev_num,
                                  NULL, "%s", driver->name);
    if (IS_ERR(driver->device)) {
        printk(KERN_ERR "无法创建设备文件\n");
        class_destroy(driver->class);
        cdev_del(&driver->cdev);
        unregister_chrdev_region(driver->dev_num, 1);
        return PTR_ERR(driver->device);
    }

    // 初始化设备
    if (driver->init_device) {
        driver->init_device();
    }

    printk(KERN_INFO "设备驱动程序注册成功\n");
    return 0;
}

// 注销设备驱动程序
void unregister_device_driver(device_driver* driver) {
    printk(KERN_INFO "注销设备驱动程序: %s\n", driver->name);

    // 清理设备
    if (driver->cleanup_device) {
        driver->cleanup_device();
    }

    // 销毁设备文件
    device_destroy(driver->class, driver->dev_num);

    // 销毁设备类
    class_destroy(driver->class);

    // 删除字符设备
    cdev_del(&driver->cdev);

    // 释放设备号
    unregister_chrdev_region(driver->dev_num, 1);

    printk(KERN_INFO "设备驱动程序注销成功\n");
}
```

#### 1.2 文件操作接口

```c
#include <linux/fs.h>
#include <linux/uaccess.h>

// 文件操作结构
struct file_operations driver_fops = {
    .owner = THIS_MODULE,
    .open = driver_open,
    .release = driver_release,
    .read = driver_read,
    .write = driver_write,
    .unlocked_ioctl = driver_ioctl,
    .mmap = driver_mmap,
    .poll = driver_poll,
};

// 打开设备
int driver_open(struct inode* inode, struct file* file) {
    device_driver* driver = container_of(inode->i_cdev, device_driver, cdev);
    file->private_data = driver;

    printk(KERN_INFO "设备打开\n");

    if (driver->open) {
        return driver->open(inode, file);
    }

    return 0;
}

// 释放设备
int driver_release(struct inode* inode, struct file* file) {
    device_driver* driver = file->private_data;

    printk(KERN_INFO "设备释放\n");

    if (driver->release) {
        return driver->release(inode, file);
    }

    return 0;
}

// 读取设备
ssize_t driver_read(struct file* file, char __user* buf, size_t count, loff_t* pos) {
    device_driver* driver = file->private_data;
    int ret = 0;

    printk(KERN_INFO "读取设备数据，大小: %zu\n", count);

    if (driver->read) {
        ret = driver->read(file, buf, count, pos);
    } else {
        // 默认读取实现
        char* data = "Hello from device driver!";
        size_t data_len = strlen(data);

        if (*pos >= data_len) {
            return 0;  // 文件结束
        }

        if (*pos + count > data_len) {
            count = data_len - *pos;
        }

        if (copy_to_user(buf, data + *pos, count)) {
            return -EFAULT;
        }

        *pos += count;
        ret = count;
    }

    return ret;
}

// 写入设备
ssize_t driver_write(struct file* file, const char __user* buf, size_t count, loff_t* pos) {
    device_driver* driver = file->private_data;
    int ret = 0;

    printk(KERN_INFO "写入设备数据，大小: %zu\n", count);

    if (driver->write) {
        ret = driver->write(file, buf, count, pos);
    } else {
        // 默认写入实现
        char* kernel_buf = kmalloc(count + 1, GFP_KERNEL);
        if (!kernel_buf) {
            return -ENOMEM;
        }

        if (copy_from_user(kernel_buf, buf, count)) {
            kfree(kernel_buf);
            return -EFAULT;
        }

        kernel_buf[count] = '\0';
        printk(KERN_INFO "收到数据: %s\n", kernel_buf);

        kfree(kernel_buf);
        ret = count;
    }

    return ret;
}

// I/O控制
long driver_ioctl(struct file* file, unsigned int cmd, unsigned long arg) {
    device_driver* driver = file->private_data;
    int ret = 0;

    printk(KERN_INFO "I/O控制命令: %u\n", cmd);

    if (driver->ioctl) {
        ret = driver->ioctl(file, cmd, arg);
    } else {
        // 默认I/O控制实现
        switch (cmd) {
            case 0:  // 获取设备状态
                printk(KERN_INFO "获取设备状态\n");
                break;
            case 1:  // 重置设备
                printk(KERN_INFO "重置设备\n");
                break;
            default:
                ret = -ENOTTY;
        }
    }

    return ret;
}

// 内存映射
int driver_mmap(struct file* file, struct vm_area_struct* vma) {
    device_driver* driver = file->private_data;
    int ret = 0;

    printk(KERN_INFO "内存映射操作\n");

    if (driver->mmap) {
        ret = driver->mmap(file, vma);
    } else {
        // 默认内存映射实现
        unsigned long size = vma->vm_end - vma->vm_start;
        unsigned long pfn;

        // 分配物理内存页
        void* virt_addr = kmalloc(size, GFP_KERNEL);
        if (!virt_addr) {
            return -ENOMEM;
        }

        // 获取物理页号
        pfn = vmalloc_to_pfn(virt_addr);

        // 设置内存映射属性
        vma->vm_page_prot = pgprot_user_exec(vma->vm_page_prot);
        vma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND;

        // 映射到用户空间
        if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot)) {
            kfree(virt_addr);
            return -EAGAIN;
        }
    }

    return ret;
}

// 轮询操作
unsigned int driver_poll(struct file* file, struct poll_table_struct* wait) {
    device_driver* driver = file->private_data;
    unsigned int mask = 0;

    printk(KERN_INFO "轮询操作\n");

    if (driver->poll) {
        mask = driver->poll(file, wait);
    } else {
        // 默认轮询实现
        poll_wait(file, &read_queue, wait);
        poll_wait(file, &write_queue, wait);

        if (data_available) {
            mask |= POLLIN | POLLRDNORM;
        }

        if (space_available) {
            mask |= POLLOUT | POLLWRNORM;
        }
    }

    return mask;
}
```

### 2. 中断处理机制

#### 2.1 中断控制器和中断处理

```c
#include <linux/interrupt.h>
#include <linux/irq.h>

// 中断处理程序类型
typedef irqreturn_t (*irq_handler_t)(int, void*);

// 中断描述符
typedef struct {
    int irq_num;              // 中断号
    irq_handler_t handler;     // 中断处理函数
    void* dev_id;            // 设备标识
    unsigned long flags;      // 中断标志
    char* name;               // 中断名称
    int shared;               // 是否共享中断
    void* private_data;       // 私有数据
} interrupt_descriptor;

// 中断统计信息
typedef struct {
    unsigned long total_interrupts;    // 总中断次数
    unsigned long handled_interrupts;  // 已处理中断
    unsigned long missed_interrupts;   // 错过中断
    unsigned long spurious_interrupts; // 伪中断
    unsigned long last_interrupt_time; // 上次中断时间
} interrupt_stats;

// 中断处理程序示例
irqreturn_t my_interrupt_handler(int irq, void* dev_id) {
    interrupt_descriptor* desc = (interrupt_descriptor*)dev_id;
    interrupt_stats* stats = desc->private_data;

    // 更新统计信息
    stats->total_interrupts++;
    stats->last_interrupt_time = jiffies;

    // 检查中断来源
    if (!check_interrupt_source(irq)) {
        stats->spurious_interrupts++;
        return IRQ_NONE;
    }

    // 处理中断
    if (process_interrupt(irq)) {
        stats->handled_interrupts++;
        return IRQ_HANDLED;
    } else {
        stats->missed_interrupts++;
        return IRQ_NONE;
    }
}

// 注册中断处理程序
int register_interrupt_handler(interrupt_descriptor* desc) {
    int ret;

    printk(KERN_INFO "注册中断处理程序: %s (IRQ: %d)\n", desc->name, desc->irq_num);

    // 分配中断线
    ret = request_irq(desc->irq_num, desc->handler, desc->flags,
                      desc->name, desc->dev_id);
    if (ret) {
        printk(KERN_ERR "无法注册中断处理程序: %d\n", ret);
        return ret;
    }

    // 启用中断
    enable_irq(desc->irq_num);

    printk(KERN_INFO "中断处理程序注册成功\n");
    return 0;
}

// 注销中断处理程序
void unregister_interrupt_handler(interrupt_descriptor* desc) {
    printk(KERN_INFO "注销中断处理程序: %s\n", desc->name);

    // 禁用中断
    disable_irq(desc->irq_num);

    // 释放中断线
    free_irq(desc->irq_num, desc->dev_id);

    printk(KERN_INFO "中断处理程序注销成功\n");
}

// 中断线程化处理
#include <linux/interrupt.h>

// 中断线程数据
typedef struct {
    struct task_struct* thread;    // 中断线程
    wait_queue_head_t wq;          // 等待队列
    spinlock_t lock;               // 自旋锁
    int pending;                   // 待处理标志
    void* data;                    // 线程数据
} threaded_interrupt;

// 中断线程函数
static int interrupt_thread_fn(void* data) {
    threaded_interrupt* ti = (threaded_interrupt*)data;

    printk(KERN_INFO "中断线程启动\n");

    while (!kthread_should_stop()) {
        // 等待中断触发
        wait_event_interruptible(ti->wq, ti->pending || kthread_should_stop());

        if (kthread_should_stop()) {
            break;
        }

        // 处理中断
        spin_lock(&ti->lock);
        ti->pending = 0;
        spin_unlock(&ti->lock);

        // 执行中断处理
        process_threaded_interrupt(ti->data);
    }

    printk(KERN_INFO "中断线程退出\n");
    return 0;
}

// 初始化中断线程
int init_threaded_interrupt(threaded_interrupt* ti, void* data) {
    printk(KERN_INFO "初始化中断线程\n");

    // 初始化等待队列
    init_waitqueue_head(&ti->wq);

    // 初始化自旋锁
    spin_lock_init(&ti->lock);

    // 设置数据
    ti->pending = 0;
    ti->data = data;

    // 创建内核线程
    ti->thread = kthread_run(interrupt_thread_fn, ti, "interrupt_thread");
    if (IS_ERR(ti->thread)) {
        printk(KERN_ERR "无法创建中断线程\n");
        return PTR_ERR(ti->thread);
    }

    printk(KERN_INFO "中断线程初始化成功\n");
    return 0;
}

// 触发中断线程
void trigger_interrupt_thread(threaded_interrupt* ti) {
    spin_lock(&ti->lock);
    ti->pending = 1;
    spin_unlock(&ti->lock);

    wake_up_interruptible(&ti->wq);
}

// 清理中断线程
void cleanup_threaded_interrupt(threaded_interrupt* ti) {
    printk(KERN_INFO "清理中断线程\n");

    if (ti->thread) {
        kthread_stop(ti->thread);
        ti->thread = NULL;
    }
}
```

#### 2.2 软中断和任务队列

```c
#include <linux/interrupt.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>

// 软中断类型
typedef enum {
    SOFTIRQ_TIMER,
    SOFTIRQ_NET_TX,
    SOFTIRQ_NET_RX,
    SOFTIRQ_BLOCK,
    SOFTIRQ_IRQ_POLL,
    SOFTIRQ_TASKLET,
    SOFTIRQ_SCHED,
    SOFTIRQ_HRTIMER,
    SOFTIRQ_RCU,
    SOFTIRQ_MAX
} softirq_type;

// 任务队列
typedef struct tasklet_struct {
    struct tasklet_struct* next;
    unsigned long state;
    atomic_t count;
    void (*func)(unsigned long);
    unsigned long data;
} tasklet_struct;

// 工作队列
typedef struct work_struct {
    atomic_long_t data;
    struct list_head entry;
    work_func_t func;
#ifdef CONFIG_LOCKDEP
    struct lockdep_map lockdep_map;
#endif
} work_struct;

// 自定义任务队列示例
tasklet_struct my_tasklet;

// 任务队列处理函数
void my_tasklet_func(unsigned long data) {
    printk(KERN_INFO "任务队列处理函数被调用，数据: %lu\n", data);

    // 执行具体的任务处理逻辑
    process_tasklet_data(data);
}

// 初始化任务队列
int init_tasklet_example(void) {
    printk(KERN_INFO "初始化任务队列示例\n");

    // 初始化任务队列
    tasklet_init(&my_tasklet, my_tasklet_func, 12345);

    printk(KERN_INFO "任务队列示例初始化成功\n");
    return 0;
}

// 调度任务队列
void schedule_tasklet(void) {
    printk(KERN_INFO "调度任务队列\n");

    // 调度任务队列执行
    tasklet_schedule(&my_tasklet);
}

// 工作队列示例
struct workqueue_struct* my_workqueue;
struct work_struct my_work;

// 工作队列处理函数
void my_work_func(struct work_struct* work) {
    printk(KERN_INFO "工作队列处理函数被调用\n");

    // 执行具体的工作处理逻辑
    process_work_data();
}

// 初始化工作队列
int init_workqueue_example(void) {
    printk(KERN_INFO "初始化工作队列示例\n");

    // 创建工作队列
    my_workqueue = create_singlethread_workqueue("my_workqueue");
    if (!my_workqueue) {
        printk(KERN_ERR "无法创建工作队列\n");
        return -ENOMEM;
    }

    // 初始化工作结构
    INIT_WORK(&my_work, my_work_func);

    printk(KERN_INFO "工作队列示例初始化成功\n");
    return 0;
}

// 调度工作队列
void schedule_workqueue(void) {
    printk(KERN_INFO "调度工作队列\n");

    // 调度工作队列执行
    queue_work(my_workqueue, &my_work);
}

// 延迟工作队列
struct delayed_work my_delayed_work;

// 延迟工作队列处理函数
void my_delayed_work_func(struct work_struct* work) {
    printk(KERN_INFO "延迟工作队列处理函数被调用\n");

    // 执行具体的延迟工作处理逻辑
    process_delayed_work_data();
}

// 调度延迟工作队列
void schedule_delayed_workqueue(unsigned long delay) {
    printk(KERN_INFO "调度延迟工作队列，延迟: %lu jiffies\n", delay);

    // 初始化延迟工作
    INIT_DELAYED_WORK(&my_delayed_work, my_delayed_work_func);

    // 调度延迟工作
    schedule_delayed_work(&my_delayed_work, delay);
}

// 清理工作队列
void cleanup_workqueue_example(void) {
    printk(KERN_INFO "清理工作队列示例\n");

    // 取消延迟工作
    cancel_delayed_work_sync(&my_delayed_work);

    // 取消工作
    cancel_work_sync(&my_work);

    // 销毁工作队列
    destroy_workqueue(my_workqueue);

    printk(KERN_INFO "工作队列示例清理成功\n");
}
```

### 3. DMA技术

#### 3.1 DMA控制器和内存访问

```c
#include <linux/dma-mapping.h>
#include <linux/dmaengine.h>

// DMA传输描述符
typedef struct {
    dma_addr_t dma_addr;        // DMA地址
    void* virt_addr;            // 虚拟地址
    size_t size;               // 传输大小
    enum dma_data_direction direction; // 传输方向
    struct dma_chan* channel;  // DMA通道
    struct dma_async_tx_descriptor* desc; // DMA描述符
    dma_cookie_t cookie;       // DMA cookie
    int completed;             // 完成标志
} dma_transfer;

// DMA配置
typedef struct {
    struct device* dev;        // 设备
    struct dma_chan* channel;  // DMA通道
    dma_addr_t dma_addr;       // DMA地址
    size_t size;               // 缓冲区大小
    enum dma_data_direction direction; // 传输方向
    void (*callback)(void*);   // 完成回调函数
    void* callback_data;       // 回调数据
} dma_config;

// DMA传输完成回调
void dma_transfer_callback(void *data) {
    dma_transfer* transfer = (dma_transfer*)data;

    printk(KERN_INFO "DMA传输完成\n");

    // 标记传输完成
    transfer->completed = 1;

    // 解除DMA映射
    dma_unmap_single(transfer->channel->device->dev, transfer->dma_addr,
                    transfer->size, transfer->direction);

    // 调用用户回调
    if (transfer->callback) {
        transfer->callback(transfer->callback_data);
    }
}

// 初始化DMA传输
int init_dma_transfer(dma_transfer* transfer, dma_config* config) {
    int ret;

    printk(KERN_INFO "初始化DMA传输\n");

    // 分配DMA通道
    config->channel = dma_request_chan(config->dev, "dma_channel");
    if (IS_ERR(config->channel)) {
        printk(KERN_ERR "无法分配DMA通道\n");
        return PTR_ERR(config->channel);
    }

    // 分配DMA缓冲区
    transfer->virt_addr = kmalloc(config->size, GFP_KERNEL);
    if (!transfer->virt_addr) {
        printk(KERN_ERR "无法分配DMA缓冲区\n");
        dma_release_channel(config->channel);
        return -ENOMEM;
    }

    // 映射DMA地址
    transfer->dma_addr = dma_map_single(config->dev, transfer->virt_addr,
                                        config->size, config->direction);
    if (dma_mapping_error(config->dev, transfer->dma_addr)) {
        printk(KERN_ERR "DMA映射失败\n");
        kfree(transfer->virt_addr);
        dma_release_channel(config->channel);
        return -ENOMEM;
    }

    // 配置DMA传输
    transfer->size = config->size;
    transfer->direction = config->direction;
    transfer->channel = config->channel;
    transfer->completed = 0;

    printk(KERN_INFO "DMA传输初始化成功\n");
    return 0;
}

// 启动DMA传输
int start_dma_transfer(dma_transfer* transfer, dma_addr_t dst_addr, size_t size) {
    struct dma_async_tx_descriptor* desc;
    dma_cookie_t cookie;

    printk(KERN_INFO "启动DMA传输\n");

    // 准备DMA描述符
    desc = dmaengine_prep_dma_memcpy(transfer->channel, dst_addr,
                                    transfer->dma_addr, size, 0);
    if (!desc) {
        printk(KERN_ERR "无法准备DMA描述符\n");
        return -ENOMEM;
    }

    // 设置回调函数
    desc->callback = dma_transfer_callback;
    desc->callback_param = transfer;

    // 提交DMA传输
    cookie = dmaengine_submit(desc);
    if (dma_submit_error(cookie)) {
        printk(KERN_ERR "DMA提交失败\n");
        return -EINVAL;
    }

    // 保存cookie
    transfer->cookie = cookie;

    // 启动DMA传输
    dma_async_issue_pending(transfer->channel);

    printk(KERN_INFO "DMA传输启动成功\n");
    return 0;
}

// 等待DMA传输完成
int wait_dma_transfer_complete(dma_transfer* transfer, unsigned long timeout) {
    int ret;

    printk(KERN_INFO "等待DMA传输完成\n");

    // 等待传输完成
    ret = dma_wait_for_async_tx(transfer->cookie);
    if (ret == DMA_COMPLETE) {
        printk(KERN_INFO "DMA传输完成\n");
        return 0;
    } else if (ret == DMA_ERROR) {
        printk(KERN_ERR "DMA传输错误\n");
        return -EIO;
    } else {
        printk(KERN_ERR "DMA传输超时\n");
        return -ETIMEDOUT;
    }
}

// 清理DMA传输
void cleanup_dma_transfer(dma_transfer* transfer) {
    printk(KERN_INFO "清理DMA传输\n");

    if (transfer->channel) {
        // 取消未完成的传输
        dmaengine_terminate_sync(transfer->channel);

        // 释放DMA通道
        dma_release_channel(transfer->channel);
    }

    if (transfer->virt_addr) {
        // 释放缓冲区
        kfree(transfer->virt_addr);
    }

    printk(KERN_INFO "DMA传输清理完成\n");
}
```

#### 3.2 分散/聚集DMA

```c
#include <linux/dma-mapping.h>
#include <linux/scatterlist.h>

// 分散/聚集DMA传输
typedef struct {
    struct scatterlist* sg;     // 分散列表
    int nents;                 // 分散项数量
    dma_addr_t dma_addr;       // DMA地址
    size_t total_size;         // 总大小
    struct dma_chan* channel;  // DMA通道
    int mapped;                // 映射标志
} scatter_gather_dma;

// 分散缓冲区描述
typedef struct {
    void* virt_addr;           // 虚拟地址
    size_t size;               // 缓冲区大小
} scatter_buffer;

// 初始化分散/聚集DMA
int init_scatter_gather_dma(scatter_gather_dma* sg_dma,
                          scatter_buffer* buffers, int nents,
                          struct dma_chan* channel) {
    int ret;
    int i;

    printk(KERN_INFO "初始化分散/聚集DMA\n");

    // 分配分散列表
    sg_dma->sg = kmalloc_array(nents, sizeof(struct scatterlist), GFP_KERNEL);
    if (!sg_dma->sg) {
        printk(KERN_ERR "无法分配分散列表\n");
        return -ENOMEM;
    }

    // 初始化分散列表
    sg_init_table(sg_dma->sg, nents);

    // 填充分散列表
    sg_dma->total_size = 0;
    for (i = 0; i < nents; i++) {
        sg_set_buf(&sg_dma->sg[i], buffers[i].virt_addr, buffers[i].size);
        sg_dma->total_size += buffers[i].size;
    }

    // 映射分散列表到DMA
    sg_dma->nents = dma_map_sg(channel->device->dev, sg_dma->sg, nents,
                               DMA_BIDIRECTIONAL);
    if (sg_dma->nents == 0) {
        printk(KERN_ERR "分散列表DMA映射失败\n");
        kfree(sg_dma->sg);
        return -ENOMEM;
    }

    // 设置DMA通道
    sg_dma->channel = channel;
    sg_dma->mapped = 1;

    printk(KERN_INFO "分散/聚集DMA初始化成功\n");
    return 0;
}

// 启动分散/聚集DMA传输
int start_scatter_gather_dma(scatter_gather_dma* sg_dma,
                            dma_addr_t dst_addr, size_t total_size) {
    struct dma_async_tx_descriptor* desc;
    dma_cookie_t cookie;

    printk(KERN_INFO "启动分散/聚集DMA传输\n");

    // 准备分散/聚集DMA描述符
    desc = dmaengine_prep_dma_sg(sg_dma->channel, sg_dma->sg, sg_dma->nents,
                                dst_addr, total_size, 0);
    if (!desc) {
        printk(KERN_ERR "无法准备分散/聚集DMA描述符\n");
        return -ENOMEM;
    }

    // 设置回调函数
    desc->callback = sg_dma_transfer_callback;
    desc->callback_param = sg_dma;

    // 提交DMA传输
    cookie = dmaengine_submit(desc);
    if (dma_submit_error(cookie)) {
        printk(KERN_ERR "分散/聚集DMA提交失败\n");
        return -EINVAL;
    }

    // 启动DMA传输
    dma_async_issue_pending(sg_dma->channel);

    printk(KERN_INFO "分散/聚集DMA传输启动成功\n");
    return 0;
}

// 分散/聚集DMA传输完成回调
void sg_dma_transfer_callback(void *data) {
    scatter_gather_dma* sg_dma = (scatter_gather_dma*)data;

    printk(KERN_INFO "分散/聚集DMA传输完成\n");

    // 标记传输完成
    sg_dma->mapped = 0;

    // 解除DMA映射
    dma_unmap_sg(sg_dma->channel->device->dev, sg_dma->sg,
                sg_dma->nents, DMA_BIDIRECTIONAL);
}

// 清理分散/聚集DMA
void cleanup_scatter_gather_dma(scatter_gather_dma* sg_dma) {
    printk(KERN_INFO "清理分散/聚集DMA\n");

    if (sg_dma->mapped && sg_dma->channel) {
        // 解除DMA映射
        dma_unmap_sg(sg_dma->channel->device->dev, sg_dma->sg,
                    sg_dma->nents, DMA_BIDIRECTIONAL);
    }

    if (sg_dma->sg) {
        // 释放分散列表
        kfree(sg_dma->sg);
    }

    printk(KERN_INFO "分散/聚集DMA清理完成\n");
}
```

### 4. 块设备和字符设备

#### 4.1 块设备驱动程序

```c
#include <linux/blkdev.h>
#include <linux/hdreg.h>
#include <linux/genhd.h>

// 块设备私有数据
typedef struct {
    struct gendisk* gd;        // 通用磁盘结构
    struct request_queue* queue; // 请求队列
    spinlock_t lock;           // 自旋锁
    void* data;                // 设备数据
    size_t size;               // 设备大小
    int sectors;               // 扇区数
    int sector_size;           // 扇区大小
} block_device_private;

// 块设备请求处理
static void block_device_request(struct request_queue* q) {
    struct request* req;
    block_device_private* bd;

    // 获取设备私有数据
    bd = q->queuedata;

    // 处理请求队列中的所有请求
    while ((req = blk_fetch_request(q)) != NULL) {
        unsigned long start_sector = blk_rq_pos(req);
        unsigned long num_sectors = blk_rq_sectors(req);
        char* buffer;

        // 检查请求是否有效
        if (start_sector + num_sectors > get_capacity(bd->gd)) {
            printk(KERN_ERR "请求超出设备范围\n");
            __blk_end_request_all(req, -EIO);
            continue;
        }

        // 处理读写请求
        if (rq_data_dir(req) == READ) {
            // 读请求
            buffer = bio_data(req->bio);
            if (read_device_sectors(bd, start_sector, num_sectors, buffer)) {
                __blk_end_request_all(req, -EIO);
                continue;
            }
        } else {
            // 写请求
            buffer = bio_data(req->bio);
            if (write_device_sectors(bd, start_sector, num_sectors, buffer)) {
                __blk_end_request_all(req, -EIO);
                continue;
            }
        }

        // 完成请求
        __blk_end_request_all(req, 0);
    }
}

// 获取设备信息
int block_device_getgeo(struct block_device* bdev, struct hd_geometry* geo) {
    block_device_private* bd = bdev->bd_disk->private_data;

    // 设置磁盘几何信息
    geo->heads = 16;
    geo->sectors = 63;
    geo->cylinders = bd->sectors / (geo->heads * geo->sectors);
    geo->start = 0;

    return 0;
}

// 块设备操作
static struct block_device_operations block_device_ops = {
    .owner = THIS_MODULE,
    .getgeo = block_device_getgeo,
};

// 初始化块设备
int init_block_device(block_device_private* bd, int major, int minor,
                     size_t size, int sector_size) {
    int ret;

    printk(KERN_INFO "初始化块设备\n");

    // 初始化自旋锁
    spin_lock_init(&bd->lock);

    // 设置设备参数
    bd->size = size;
    bd->sector_size = sector_size;
    bd->sectors = size / sector_size;

    // 分配通用磁盘结构
    bd->gd = alloc_disk(16);
    if (!bd->gd) {
        printk(KERN_ERR "无法分配磁盘结构\n");
        return -ENOMEM;
    }

    // 设置磁盘参数
    bd->gd->major = major;
    bd->gd->first_minor = minor;
    bd->gd->fops = &block_device_ops;
    bd->gd->private_data = bd;
    bd->gd->queue = bd->queue;
    sprintf(bd->gd->disk_name, "my_block_device");
    set_capacity(bd->gd, bd->sectors);

    // 创建请求队列
    bd->queue = blk_init_queue(block_device_request, &bd->lock);
    if (!bd->queue) {
        printk(KERN_ERR "无法创建请求队列\n");
        del_gendisk(bd->gd);
        put_disk(bd->gd);
        return -ENOMEM;
    }

    // 设置队列参数
    queue_flag_set_unlocked(QUEUE_FLAG_NONROT, bd->queue);
    queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, bd->queue);
    blk_queue_logical_block_size(bd->queue, sector_size);
    bd->queue->queuedata = bd;

    // 注册块设备
    ret = register_blkdev(major, "my_block_device");
    if (ret < 0) {
        printk(KERN_ERR "无法注册块设备\n");
        blk_cleanup_queue(bd->queue);
        del_gendisk(bd->gd);
        put_disk(bd->gd);
        return ret;
    }

    // 添加磁盘
    add_disk(bd->gd);

    printk(KERN_INFO "块设备初始化成功\n");
    return 0;
}

// 清理块设备
void cleanup_block_device(block_device_private* bd) {
    printk(KERN_INFO "清理块设备\n");

    if (bd->gd) {
        // 删除磁盘
        del_gendisk(bd->gd);
        put_disk(bd->gd);
    }

    if (bd->queue) {
        // 清理请求队列
        blk_cleanup_queue(bd->queue);
    }

    // 注销块设备
    unregister_blkdev(bd->gd->major, "my_block_device");

    printk(KERN_INFO "块设备清理完成\n");
}
```

#### 4.2 字符设备驱动程序

```c
#include <linux/cdev.h>
#include <linux/fs.h>

// 字符设备私有数据
typedef struct {
    struct cdev cdev;          // 字符设备结构
    dev_t dev_num;             // 设备号
    struct class* class;       // 设备类
    struct device* device;     // 设备实例
    char* buffer;              // 数据缓冲区
    size_t buffer_size;        // 缓冲区大小
    size_t data_size;          // 数据大小
    struct semaphore sem;       // 信号量
    wait_queue_head_t read_q;  // 读等待队列
    wait_queue_head_t write_q; // 写等待队列
} char_device_private;

// 字符设备文件操作
static struct file_operations char_device_fops = {
    .owner = THIS_MODULE,
    .open = char_device_open,
    .release = char_device_release,
    .read = char_device_read,
    .write = char_device_write,
    .ioctl = char_device_ioctl,
    .llseek = char_device_llseek,
    .poll = char_device_poll,
};

// 打开字符设备
static int char_device_open(struct inode* inode, struct file* file) {
    char_device_private* cd;

    // 获取设备私有数据
    cd = container_of(inode->i_cdev, char_device_private, cdev);
    file->private_data = cd;

    printk(KERN_INFO "打开字符设备\n");

    // 获取信号量
    if (down_interruptible(&cd->sem)) {
        return -ERESTARTSYS;
    }

    return 0;
}

// 释放字符设备
static int char_device_release(struct inode* inode, struct file* file) {
    char_device_private* cd = file->private_data;

    printk(KERN_INFO "释放字符设备\n");

    // 释放信号量
    up(&cd->sem);

    return 0;
}

// 读取字符设备
static ssize_t char_device_read(struct file* file, char __user* buf,
                                size_t count, loff_t* pos) {
    char_device_private* cd = file->private_data;
    ssize_t bytes_read = 0;

    printk(KERN_INFO "读取字符设备数据\n");

    // 检查文件位置
    if (*pos >= cd->data_size) {
        return 0;  // 文件结束
    }

    // 检查读取大小
    if (*pos + count > cd->data_size) {
        count = cd->data_size - *pos;
    }

    // 等待数据可用
    if (wait_event_interruptible(cd->read_q, cd->data_size > 0)) {
        return -ERESTARTSYS;
    }

    // 复制数据到用户空间
    if (copy_to_user(buf, cd->buffer + *pos, count)) {
        return -EFAULT;
    }

    // 更新位置
    *pos += count;
    bytes_read = count;

    printk(KERN_INFO "读取 %zd 字节\n", bytes_read);

    return bytes_read;
}

// 写入字符设备
static ssize_t char_device_write(struct file* file, const char __user* buf,
                                 size_t count, loff_t* pos) {
    char_device_private* cd = file->private_data;
    ssize_t bytes_written = 0;

    printk(KERN_INFO "写入字符设备数据\n");

    // 检查缓冲区空间
    if (*pos + count > cd->buffer_size) {
        count = cd->buffer_size - *pos;
    }

    // 等待缓冲区空间
    if (wait_event_interruptible(cd->write_q, cd->data_size < cd->buffer_size)) {
        return -ERESTARTSYS;
    }

    // 从用户空间复制数据
    if (copy_from_user(cd->buffer + *pos, buf, count)) {
        return -EFAULT;
    }

    // 更新位置和数据大小
    *pos += count;
    if (*pos > cd->data_size) {
        cd->data_size = *pos;
    }

    bytes_written = count;

    // 唤醒读进程
    wake_up_interruptible(&cd->read_q);

    printk(KERN_INFO "写入 %zd 字节\n", bytes_written);

    return bytes_written;
}

// I/O控制
static long char_device_ioctl(struct file* file, unsigned int cmd,
                             unsigned long arg) {
    char_device_private* cd = file->private_data;

    printk(KERN_INFO "字符设备I/O控制命令: %u\n", cmd);

    switch (cmd) {
        case 0:  // 获取缓冲区大小
            return cd->buffer_size;
        case 1:  // 设置缓冲区大小
            if (arg > cd->buffer_size) {
                return -EINVAL;
            }
            cd->data_size = arg;
            return 0;
        case 2:  // 清空缓冲区
            cd->data_size = 0;
            return 0;
        default:
            return -ENOTTY;
    }
}

// 文件定位
static loff_t char_device_llseek(struct file* file, loff_t offset, int whence) {
    char_device_private* cd = file->private_data;
    loff_t new_pos;

    switch (whence) {
        case SEEK_SET:
            new_pos = offset;
            break;
        case SEEK_CUR:
            new_pos = file->f_pos + offset;
            break;
        case SEEK_END:
            new_pos = cd->data_size + offset;
            break;
        default:
            return -EINVAL;
    }

    // 检查位置是否有效
    if (new_pos < 0 || new_pos > cd->buffer_size) {
        return -EINVAL;
    }

    file->f_pos = new_pos;
    return new_pos;
}

// 轮询操作
static unsigned int char_device_poll(struct file* file,
                                    struct poll_table_struct* wait) {
    char_device_private* cd = file->private_data;
    unsigned int mask = 0;

    // 添加到等待队列
    poll_wait(file, &cd->read_q, wait);
    poll_wait(file, &cd->write_q, wait);

    // 检查可读条件
    if (cd->data_size > 0) {
        mask |= POLLIN | POLLRDNORM;
    }

    // 检查可写条件
    if (cd->data_size < cd->buffer_size) {
        mask |= POLLOUT | POLLWRNORM;
    }

    return mask;
}

// 初始化字符设备
int init_char_device(char_device_private* cd, int major, int minor,
                     size_t buffer_size) {
    int ret;

    printk(KERN_INFO "初始化字符设备\n");

    // 分配缓冲区
    cd->buffer = kmalloc(buffer_size, GFP_KERNEL);
    if (!cd->buffer) {
        printk(KERN_ERR "无法分配缓冲区\n");
        return -ENOMEM;
    }

    // 初始化设备参数
    cd->buffer_size = buffer_size;
    cd->data_size = 0;

    // 初始化信号量
    sema_init(&cd->sem, 1);

    // 初始化等待队列
    init_waitqueue_head(&cd->read_q);
    init_waitqueue_head(&cd->write_q);

    // 分配设备号
    ret = alloc_chrdev_region(&cd->dev_num, minor, 1, "my_char_device");
    if (ret < 0) {
        printk(KERN_ERR "无法分配设备号\n");
        kfree(cd->buffer);
        return ret;
    }

    // 初始化字符设备
    cdev_init(&cd->cdev, &char_device_fops);
    cd->cdev.owner = THIS_MODULE;

    // 添加字符设备
    ret = cdev_add(&cd->cdev, cd->dev_num, 1);
    if (ret < 0) {
        printk(KERN_ERR "无法添加字符设备\n");
        unregister_chrdev_region(cd->dev_num, 1);
        kfree(cd->buffer);
        return ret;
    }

    // 创建设备类
    cd->class = class_create(THIS_MODULE, "my_char_device");
    if (IS_ERR(cd->class)) {
        printk(KERN_ERR "无法创建设备类\n");
        cdev_del(&cd->cdev);
        unregister_chrdev_region(cd->dev_num, 1);
        kfree(cd->buffer);
        return PTR_ERR(cd->class);
    }

    // 创建设备文件
    cd->device = device_create(cd->class, NULL, cd->dev_num,
                               NULL, "my_char_device");
    if (IS_ERR(cd->device)) {
        printk(KERN_ERR "无法创建设备文件\n");
        class_destroy(cd->class);
        cdev_del(&cd->cdev);
        unregister_chrdev_region(cd->dev_num, 1);
        kfree(cd->buffer);
        return PTR_ERR(cd->device);
    }

    printk(KERN_INFO "字符设备初始化成功\n");
    return 0;
}

// 清理字符设备
void cleanup_char_device(char_device_private* cd) {
    printk(KERN_INFO "清理字符设备\n");

    if (cd->device) {
        device_destroy(cd->class, cd->dev_num);
    }

    if (cd->class) {
        class_destroy(cd->class);
    }

    if (cd->cdev.dev) {
        cdev_del(&cd->cdev);
    }

    if (cd->dev_num) {
        unregister_chrdev_region(cd->dev_num, 1);
    }

    if (cd->buffer) {
        kfree(cd->buffer);
    }

    printk(KERN_INFO "字符设备清理完成\n");
}
```

### 5. I/O性能优化

#### 5.1 I/O调度算法

```c
#include <linux/blkdev.h>
#include <linux/elevator.h>

// I/O请求结构
typedef struct {
    struct list_head queue;    // 请求队列
    sector_t sector;           // 起始扇区
    unsigned int nr_sectors;   // 扇区数
    int rw;                   // 读写标志
    struct request* req;       // 块层请求
    unsigned long timestamp;   // 时间戳
    unsigned int priority;     // 优先级
} io_request;

// I/O调度器
typedef struct {
    struct list_head queue;    // 请求队列
    spinlock_t lock;           // 自旋锁
    unsigned int queue_depth;  // 队列深度
    unsigned int max_requests; // 最大请求数
    sector_t last_sector;      // 上次访问扇区
    unsigned int algorithm;   // 调度算法
    struct timer_list timer;   // 定时器
} io_scheduler;

// 调度算法类型
typedef enum {
    SCHED_FIFO,       // 先进先出
    SCHED_LIFO,       // 后进先出
    SCHED_SSTF,       // 最短寻道时间优先
    SCHED_SCAN,       // 扫描算法
    SCHED_CLOOK,      // 循环扫描
    SCHED_DEADLINE    // 截止时间调度
} scheduler_algorithm;

// 初始化I/O调度器
int init_io_scheduler(io_scheduler* sched, unsigned int max_requests,
                    scheduler_algorithm algorithm) {
    printk(KERN_INFO "初始化I/O调度器\n");

    // 初始化队列
    INIT_LIST_HEAD(&sched->queue);

    // 初始化自旋锁
    spin_lock_init(&sched->lock);

    // 设置参数
    sched->queue_depth = 0;
    sched->max_requests = max_requests;
    sched->last_sector = 0;
    sched->algorithm = algorithm;

    printk(KERN_INFO "I/O调度器初始化成功\n");
    return 0;
}

// 添加I/O请求
int add_io_request(io_scheduler* sched, io_request* req) {
    unsigned long flags;

    printk(KERN_INFO "添加I/O请求\n");

    // 检查队列是否已满
    if (sched->queue_depth >= sched->max_requests) {
        printk(KERN_ERR "I/O队列已满\n");
        return -ENOSPC;
    }

    // 获取自旋锁
    spin_lock_irqsave(&sched->lock, flags);

    // 根据调度算法插入请求
    switch (sched->algorithm) {
        case SCHED_FIFO:
            list_add_tail(&req->queue, &sched->queue);
            break;
        case SCHED_LIFO:
            list_add(&req->queue, &sched->queue);
            break;
        case SCHED_SSTF:
            // 寻找最佳插入位置
            io_scheduler_insert_sstf(sched, req);
            break;
        case SCHED_SCAN:
            io_scheduler_insert_scan(sched, req);
            break;
        case SCHED_CLOOK:
            io_scheduler_insert_clook(sched, req);
            break;
        case SCHED_DEADLINE:
            io_scheduler_insert_deadline(sched, req);
            break;
        default:
            list_add_tail(&req->queue, &sched->queue);
            break;
    }

    // 更新队列深度
    sched->queue_depth++;

    // 释放自旋锁
    spin_unlock_irqrestore(&sched->lock, flags);

    printk(KERN_INFO "I/O请求添加成功\n");
    return 0;
}

// SSTF算法插入
void io_scheduler_insert_sstf(io_scheduler* sched, io_request* req) {
    io_request* curr;
    struct list_head* pos;
    sector_t curr_distance, min_distance = ULONG_MAX;
    struct list_head* insert_pos = &sched->queue;

    // 计算与上次访问扇区的距离
    sector_t req_distance = abs(req->sector - sched->last_sector);

    // 遍历队列寻找最佳插入位置
    list_for_each(pos, &sched->queue) {
        curr = list_entry(pos, io_request, queue);
        curr_distance = abs(curr->sector - sched->last_sector);

        if (curr_distance > req_distance) {
            insert_pos = pos->prev;
            break;
        }

        if (curr_distance < min_distance) {
            min_distance = curr_distance;
            insert_pos = pos;
        }
    }

    // 插入请求
    list_add(&req->queue, insert_pos);
}

// SCAN算法插入
void io_scheduler_insert_scan(io_scheduler* sched, io_request* req) {
    io_request* curr;
    struct list_head* pos;
    int direction = 1;  // 1表示向上扫描，-1表示向下扫描

    // 根据扫描方向插入请求
    if (direction == 1) {
        // 向上扫描
        list_for_each(pos, &sched->queue) {
            curr = list_entry(pos, io_request, queue);
            if (curr->sector > req->sector) {
                list_add_tail(&req->queue, pos->prev);
                return;
            }
        }
        list_add_tail(&req->queue, &sched->queue);
    } else {
        // 向下扫描
        list_for_each_prev(pos, &sched->queue) {
            curr = list_entry(pos, io_request, queue);
            if (curr->sector < req->sector) {
                list_add(&req->queue, pos);
                return;
            }
        }
        list_add(&req->queue, &sched->queue);
    }
}

// CLOOK算法插入
void io_scheduler_insert_clook(io_scheduler* sched, io_request* req) {
    io_request* curr;
    struct list_head* pos;
    struct list_head* insert_pos = &sched->queue;

    // 寻找插入位置
    list_for_each(pos, &sched->queue) {
        curr = list_entry(pos, io_request, queue);
        if (curr->sector > req->sector) {
            insert_pos = pos->prev;
            break;
        }
    }

    // 插入请求
    list_add(&req->queue, insert_pos);
}

// 截止时间算法插入
void io_scheduler_insert_deadline(io_scheduler* sched, io_request* req) {
    io_request* curr;
    struct list_head* pos;
    struct list_head* insert_pos = &sched->queue;

    // 根据截止时间插入请求
    list_for_each(pos, &sched->queue) {
        curr = list_entry(pos, io_request, queue);
        if (curr->priority < req->priority) {
            insert_pos = pos->prev;
            break;
        }
    }

    // 插入请求
    list_add(&req->queue, insert_pos);
}

// 获取下一个I/O请求
io_request* get_next_io_request(io_scheduler* sched) {
    unsigned long flags;
    io_request* req = NULL;

    // 获取自旋锁
    spin_lock_irqsave(&sched->lock, flags);

    // 检查队列是否为空
    if (!list_empty(&sched->queue)) {
        // 获取队列头部请求
        req = list_first_entry(&sched->queue, io_request, queue);

        // 从队列中移除
        list_del(&req->queue);

        // 更新队列深度
        sched->queue_depth--;

        // 更新上次访问扇区
        sched->last_sector = req->sector;
    }

    // 释放自旋锁
    spin_unlock_irqrestore(&sched->lock, flags);

    return req;
}

// 清理I/O调度器
void cleanup_io_scheduler(io_scheduler* sched) {
    unsigned long flags;
    io_request* req;
    struct list_head* pos, *temp;

    printk(KERN_INFO "清理I/O调度器\n");

    // 获取自旋锁
    spin_lock_irqsave(&sched->lock, flags);

    // 清理队列中的所有请求
    list_for_each_safe(pos, temp, &sched->queue) {
        req = list_entry(pos, io_request, queue);
        list_del(&req->queue);
        kfree(req);
    }

    // 释放自旋锁
    spin_unlock_irqrestore(&sched->lock, flags);

    printk(KERN_INFO "I/O调度器清理完成\n");
}
```

#### 5.2 缓存优化

```c
#include <linux/fs.h>
#include <linux/buffer_head.h>
#include <linux/mpage.h>

// 缓存统计信息
typedef struct {
    unsigned long hits;         // 缓存命中
    unsigned long misses;       // 缓存未命中
    unsigned long read_aheads;  // 预读取次数
    unsigned long writes;       // 写入次数
    unsigned long evictions;    // 缓存淘汰次数
} cache_stats;

// 缓存项
typedef struct cache_entry {
    struct list_head lru_list;  // LRU链表
    struct hlist_node hash_list; // 哈希链表
    sector_t sector;           // 扇区号
    void* data;                // 数据
    size_t size;               // 数据大小
    int dirty;                 // 脏标志
    int ref_count;             // 引用计数
    unsigned long last_access;  // 最后访问时间
} cache_entry;

// 缓存管理器
typedef struct {
    struct list_head lru_list;  // LRU链表
    struct hlist_head* hash_table; // 哈希表
    unsigned int cache_size;    // 缓存大小
    unsigned int max_entries;   // 最大条目数
    unsigned int current_entries; // 当前条目数
    cache_stats stats;         // 统计信息
    spinlock_t lock;           // 自旋锁
    struct work_struct work;   // 工作队列
} cache_manager;

// 初始化缓存管理器
int init_cache_manager(cache_manager* cm, unsigned int cache_size,
                      unsigned int hash_size) {
    int i;

    printk(KERN_INFO "初始化缓存管理器\n");

    // 初始化LRU链表
    INIT_LIST_HEAD(&cm->lru_list);

    // 分配哈希表
    cm->hash_table = kmalloc_array(hash_size, sizeof(struct hlist_head),
                                  GFP_KERNEL);
    if (!cm->hash_table) {
        printk(KERN_ERR "无法分配哈希表\n");
        return -ENOMEM;
    }

    // 初始化哈希表
    for (i = 0; i < hash_size; i++) {
        INIT_HLIST_HEAD(&cm->hash_table[i]);
    }

    // 设置参数
    cm->cache_size = cache_size;
    cm->max_entries = cache_size / PAGE_SIZE;
    cm->current_entries = 0;

    // 初始化统计信息
    memset(&cm->stats, 0, sizeof(cache_stats));

    // 初始化自旋锁
    spin_lock_init(&cm->lock);

    printk(KERN_INFO "缓存管理器初始化成功\n");
    return 0;
}

// 哈希函数
static inline unsigned int cache_hash(sector_t sector, unsigned int hash_size) {
    return sector % hash_size;
}

// 查找缓存项
cache_entry* cache_lookup(cache_manager* cm, sector_t sector,
                         unsigned int hash_size) {
    struct hlist_head* head = &cm->hash_table[cache_hash(sector, hash_size)];
    cache_entry* entry;

    // 遍历哈希链表
    hlist_for_each_entry(entry, head, hash_list) {
        if (entry->sector == sector) {
            // 更新访问时间
            entry->last_access = jiffies;

            // 移动到LRU链表头部
            list_move(&entry->lru_list, &cm->lru_list);

            // 更新统计信息
            cm->stats.hits++;

            return entry;
        }
    }

    // 缓存未命中
    cm->stats.misses++;
    return NULL;
}

// 添加缓存项
int cache_add(cache_manager* cm, sector_t sector, void* data, size_t size,
             unsigned int hash_size) {
    unsigned long flags;
    cache_entry* entry;

    printk(KERN_INFO "添加缓存项\n");

    // 检查是否需要淘汰缓存项
    if (cm->current_entries >= cm->max_entries) {
        cache_evict(cm);
    }

    // 分配缓存项
    entry = kmalloc(sizeof(cache_entry), GFP_KERNEL);
    if (!entry) {
        printk(KERN_ERR "无法分配缓存项\n");
        return -ENOMEM;
    }

    // 分配数据缓冲区
    entry->data = kmalloc(size, GFP_KERNEL);
    if (!entry->data) {
        kfree(entry);
        printk(KERN_ERR "无法分配数据缓冲区\n");
        return -ENOMEM;
    }

    // 复制数据
    memcpy(entry->data, data, size);

    // 设置缓存项属性
    entry->sector = sector;
    entry->size = size;
    entry->dirty = 0;
    entry->ref_count = 1;
    entry->last_access = jiffies;

    // 获取自旋锁
    spin_lock_irqsave(&cm->lock, flags);

    // 添加到哈希表
    hlist_add_head(&entry->hash_list, &cm->hash_table[cache_hash(sector, hash_size)]);

    // 添加到LRU链表头部
    list_add(&entry->lru_list, &cm->lru_list);

    // 更新当前条目数
    cm->current_entries++;

    // 释放自旋锁
    spin_unlock_irqrestore(&cm->lock, flags);

    printk(KERN_INFO "缓存项添加成功\n");
    return 0;
}

// 淘汰缓存项
void cache_evict(cache_manager* cm) {
    unsigned long flags;
    cache_entry* entry;

    // 获取自旋锁
    spin_lock_irqsave(&cm->lock, flags);

    // 检查是否有可淘汰的项
    if (!list_empty(&cm->lru_list)) {
        // 获取LRU链表尾部项
        entry = list_last_entry(&cm->lru_list, cache_entry, lru_list);

        // 从链表中移除
        list_del(&entry->lru_list);
        hlist_del(&entry->hash_list);

        // 更新当前条目数
        cm->current_entries--;

        // 更新统计信息
        cm->stats.evictions++;

        // 如果是脏页，需要写回
        if (entry->dirty) {
            cache_write_back(entry);
        }

        // 释放资源
        kfree(entry->data);
        kfree(entry);
    }

    // 释放自旋锁
    spin_unlock_irqrestore(&cm->lock, flags);
}

// 缓存写回
void cache_write_back(cache_entry* entry) {
    printk(KERN_INFO "缓存写回\n");

    // 模拟写回操作
    write_sector_to_disk(entry->sector, entry->data, entry->size);

    // 清除脏标志
    entry->dirty = 0;

    // 更新统计信息
    // 这里应该更新外部统计信息
}

// 预读取
void cache_read_ahead(cache_manager* cm, sector_t start_sector,
                     unsigned int num_sectors, unsigned int hash_size) {
    sector_t sector;
    void* data;
    size_t size = PAGE_SIZE;

    printk(KERN_INFO "执行预读取\n");

    // 预读取后续扇区
    for (sector = start_sector + 1;
         sector < start_sector + num_sectors; sector++) {

        // 检查是否已在缓存中
        if (!cache_lookup(cm, sector, hash_size)) {
            // 分配缓冲区
            data = kmalloc(size, GFP_KERNEL);
            if (!data) {
                continue;
            }

            // 读取数据
            if (read_sector_from_disk(sector, data, size) == 0) {
                // 添加到缓存
                cache_add(cm, sector, data, size, hash_size);
            } else {
                kfree(data);
            }
        }
    }

    // 更新统计信息
    cm->stats.read_aheads++;
}

// 获取缓存统计信息
void cache_get_stats(cache_manager* cm, cache_stats* stats) {
    unsigned long flags;

    // 获取自旋锁
    spin_lock_irqsave(&cm->lock, flags);

    // 复制统计信息
    memcpy(stats, &cm->stats, sizeof(cache_stats));

    // 释放自旋锁
    spin_unlock_irqrestore(&cm->lock, flags);
}

// 清理缓存管理器
void cleanup_cache_manager(cache_manager* cm) {
    unsigned long flags;
    cache_entry* entry;
    struct list_head* pos, *temp;

    printk(KERN_INFO "清理缓存管理器\n");

    // 获取自旋锁
    spin_lock_irqsave(&cm->lock, flags);

    // 清理LRU链表
    list_for_each_safe(pos, temp, &cm->lru_list) {
        entry = list_entry(pos, cache_entry, lru_list);

        // 从链表中移除
        list_del(&entry->lru_list);
        hlist_del(&entry->hash_list);

        // 写回脏数据
        if (entry->dirty) {
            cache_write_back(entry);
        }

        // 释放资源
        kfree(entry->data);
        kfree(entry);
    }

    // 释放哈希表
    kfree(cm->hash_table);

    // 释放自旋锁
    spin_unlock_irqrestore(&cm->lock, flags);

    printk(KERN_INFO "缓存管理器清理完成\n");
}
```

### 6. 实验项目：设备驱动程序开发 (M5)

#### 6.1 实验目标

- 实现一个虚拟块设备驱动程序
- 实现DMA数据传输
- 测试I/O性能优化效果
- 分析中断处理性能

#### 6.2 实验代码

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/blkdev.h>
#include <linux/hdreg.h>
#include <linux/genhd.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/uaccess.h>
#include <linux/init.h>
#include <linux/vmalloc.h>
#include <linux/spinlock.h>
#include <linux/blk-mq.h>

#define DEVICE_NAME "vblock"
#define DEVICE_SIZE (64 * 1024 * 1024)  // 64MB
#define SECTOR_SIZE 512
#define NUM_SECTORS (DEVICE_SIZE / SECTOR_SIZE)

// 虚拟块设备结构
typedef struct {
    struct gendisk* gd;        // 通用磁盘结构
    struct request_queue* queue; // 请求队列
    spinlock_t lock;           // 自旋锁
    void* data;                // 设备数据
    size_t size;               // 设备大小
    int sectors;               // 扇区数
    int users;                 // 用户计数

    // 性能统计
    unsigned long reads;       // 读取次数
    unsigned long writes;      // 写入次数
    unsigned long bytes_read;   // 读取字节数
    unsigned long bytes_written; // 写入字节数
    unsigned long start_time;  // 启动时间
} virtual_block_device;

// 全局变量
static virtual_block_device vblock_dev;
static int major_num = 0;

// 处理块设备请求
static void vblock_request(struct request_queue* q) {
    struct request* req;
    virtual_block_device* vbd = &vblock_dev;

    // 处理请求队列中的所有请求
    while ((req = blk_fetch_request(q)) != NULL) {
        unsigned long start_sector = blk_rq_pos(req);
        unsigned long num_sectors = blk_rq_sectors(req);
        char* buffer;
        int ret = 0;

        // 检查请求是否有效
        if (start_sector + num_sectors > get_capacity(vbd->gd)) {
            printk(KERN_ERR "请求超出设备范围: %lu + %lu > %d\n",
                   start_sector, num_sectors, vbd->sectors);
            __blk_end_request_all(req, -EIO);
            continue;
        }

        // 获取数据缓冲区
        buffer = bio_data(req->bio);

        // 处理读写请求
        if (rq_data_dir(req) == READ) {
            // 读请求
            memcpy(buffer, vbd->data + start_sector * SECTOR_SIZE,
                   num_sectors * SECTOR_SIZE);

            // 更新统计信息
            vbd->reads++;
            vbd->bytes_read += num_sectors * SECTOR_SIZE;
        } else {
            // 写请求
            memcpy(vbd->data + start_sector * SECTOR_SIZE, buffer,
                   num_sectors * SECTOR_SIZE);

            // 更新统计信息
            vbd->writes++;
            vbd->bytes_written += num_sectors * SECTOR_SIZE;
        }

        // 完成请求
        __blk_end_request_all(req, 0);
    }
}

// 获取设备信息
static int vblock_getgeo(struct block_device* bdev, struct hd_geometry* geo) {
    virtual_block_device* vbd = bdev->bd_disk->private_data;

    // 设置磁盘几何信息
    geo->heads = 16;
    geo->sectors = 63;
    geo->cylinders = vbd->sectors / (geo->heads * geo->sectors);
    geo->start = 0;

    return 0;
}

// 块设备操作
static struct block_device_operations vblock_ops = {
    .owner = THIS_MODULE,
    .getgeo = vblock_getgeo,
};

// 打开设备
static int vblock_open(struct block_device* bdev, fmode_t mode) {
    virtual_block_device* vbd = bdev->bd_disk->private_data;

    // 增加用户计数
    vbd->users++;

    printk(KERN_INFO "虚拟块设备打开，用户数: %d\n", vbd->users);

    return 0;
}

// 释放设备
static void vblock_release(struct gendisk* gd, fmode_t mode) {
    virtual_block_device* vbd = gd->private_data;

    // 减少用户计数
    vbd->users--;

    printk(KERN_INFO "虚拟块设备释放，用户数: %d\n", vbd->users);
}

// /proc文件系统显示统计信息
static int vblock_proc_show(struct seq_file* m, void* v) {
    virtual_block_device* vbd = &vblock_dev;
    unsigned long uptime = jiffies - vbd->start_time;
    unsigned long read_rate = 0, write_rate = 0;

    // 计算读写速率
    if (uptime > 0) {
        read_rate = vbd->bytes_read * HZ / uptime;
        write_rate = vbd->bytes_written * HZ / uptime;
    }

    seq_printf(m, "虚拟块设备统计信息:\n");
    seq_printf(m, "  设备大小: %zu 字节\n", vbd->size);
    seq_printf(m, "  扇区数: %d\n", vbd->sectors);
    seq_printf(m, "  用户数: %d\n", vbd->users);
    seq_printf(m, "  读取次数: %lu\n", vbd->reads);
    seq_printf(m, "  写入次数: %lu\n", vbd->writes);
    seq_printf(m, "  读取字节数: %lu\n", vbd->bytes_read);
    seq_printf(m, "  写入字节数: %lu\n", vbd->bytes_written);
    seq_printf(m, "  读取速率: %lu 字节/秒\n", read_rate);
    seq_printf(m, "  写入速率: %lu 字节/秒\n", write_rate);
    seq_printf(m, "  运行时间: %lu jiffies\n", uptime);

    return 0;
}

// 打开/proc文件
static int vblock_proc_open(struct inode* inode, struct file* file) {
    return single_open(file, vblock_proc_show, NULL);
}

// /proc文件操作
static const struct proc_ops vblock_proc_ops = {
    .proc_open = vblock_proc_open,
    .proc_read = seq_read,
    .proc_lseek = seq_lseek,
    .proc_release = single_release,
};

// 模块初始化
static int __init vblock_init(void) {
    int ret;

    printk(KERN_INFO "虚拟块设备模块初始化\n");

    // 初始化设备结构
    memset(&vblock_dev, 0, sizeof(virtual_block_device));

    // 分配设备数据内存
    vblock_dev.data = vmalloc(DEVICE_SIZE);
    if (!vblock_dev.data) {
        printk(KERN_ERR "无法分配设备数据内存\n");
        return -ENOMEM;
    }

    // 清零设备数据
    memset(vblock_dev.data, 0, DEVICE_SIZE);

    // 设置设备参数
    vblock_dev.size = DEVICE_SIZE;
    vblock_dev.sectors = NUM_SECTORS;
    vblock_dev.start_time = jiffies;

    // 初始化自旋锁
    spin_lock_init(&vblock_dev.lock);

    // 注册块设备
    major_num = register_blkdev(major_num, DEVICE_NAME);
    if (major_num <= 0) {
        printk(KERN_ERR "无法注册块设备\n");
        vfree(vblock_dev.data);
        return -EBUSY;
    }

    // 分配通用磁盘结构
    vblock_dev.gd = alloc_disk(16);
    if (!vblock_dev.gd) {
        printk(KERN_ERR "无法分配磁盘结构\n");
        unregister_blkdev(major_num, DEVICE_NAME);
        vfree(vblock_dev.data);
        return -ENOMEM;
    }

    // 设置磁盘参数
    vblock_dev.gd->major = major_num;
    vblock_dev.gd->first_minor = 0;
    vblock_dev.gd->fops = &vblock_ops;
    vblock_dev.gd->private_data = &vblock_dev;
    vblock_dev.gd->queue = vblock_dev.queue;
    sprintf(vblock_dev.gd->disk_name, DEVICE_NAME);
    set_capacity(vblock_dev.gd, NUM_SECTORS);

    // 创建请求队列
    vblock_dev.queue = blk_init_queue(vblock_request, &vblock_dev.lock);
    if (!vblock_dev.queue) {
        printk(KERN_ERR "无法创建请求队列\n");
        del_gendisk(vblock_dev.gd);
        put_disk(vblock_dev.gd);
        unregister_blkdev(major_num, DEVICE_NAME);
        vfree(vblock_dev.data);
        return -ENOMEM;
    }

    // 设置队列参数
    queue_flag_set_unlocked(QUEUE_FLAG_NONROT, vblock_dev.queue);
    queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, vblock_dev.queue);
    blk_queue_logical_block_size(vblock_dev.queue, SECTOR_SIZE);
    vblock_dev.queue->queuedata = &vblock_dev;

    // 添加磁盘
    add_disk(vblock_dev.gd);

    // 创建/proc文件
    proc_create("vblock_stats", 0, NULL, &vblock_proc_ops);

    printk(KERN_INFO "虚拟块设备初始化成功\n");
    printk(KERN_INFO "设备名: %s, 主设备号: %d\n", DEVICE_NAME, major_num);
    printk(KERN_INFO "设备大小: %zu 字节, 扇区数: %d\n",
           vblock_dev.size, vblock_dev.sectors);

    return 0;
}

// 模块退出
static void __exit vblock_exit(void) {
    printk(KERN_INFO "虚拟块设备模块退出\n");

    // 删除/proc文件
    remove_proc_entry("vblock_stats", NULL);

    // 删除磁盘
    del_gendisk(vblock_dev.gd);
    put_disk(vblock_dev.gd);

    // 清理请求队列
    blk_cleanup_queue(vblock_dev.queue);

    // 注销块设备
    unregister_blkdev(major_num, DEVICE_NAME);

    // 释放设备数据
    vfree(vblock_dev.data);

    printk(KERN_INFO "虚拟块设备清理完成\n");
}

module_init(vblock_init);
module_exit(vblock_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Virtual Block Device Driver");
MODULE_VERSION("1.0");
```

## 实验任务

### 基础任务

1. **实现字符设备驱动**：创建一个简单的字符设备驱动程序
2. **中断处理实验**：实现中断处理程序和中断线程化
3. **DMA传输测试**：实现DMA数据传输和性能测试

### 进阶任务

1. **块设备驱动**：实现一个虚拟块设备驱动程序
2. **I/O调度器**：实现自定义I/O调度算法
3. **缓存优化**：实现缓存管理器和预读取机制

### 挑战任务

1. **SCSI设备驱动**：实现一个SCSI设备驱动程序
2. **网络设备驱动**：实现一个虚拟网络设备驱动
3. **性能分析工具**：开发I/O性能分析工具

## 扩展阅读

### 推荐书籍

1. 《Linux Device Drivers》- Jonathan Corbet
2. 《Understanding the Linux Kernel》- Daniel P. Bovet
3. 《Linux Kernel Development》- Robert Love

### 在线资源

1. [Linux Kernel Documentation](https://www.kernel.org/doc/html/latest/)
2. [Linux Device Drivers 3rd Edition](https://lwn.net/Kernel/LDD3/)
3. [Linux Cross Reference](https://elixir.bootlin.com/linux/latest/source)

## 课后习题

1. **概念题**：解释字符设备和块设备的区别
2. **分析题**：分析DMA技术对I/O性能的影响
3. **设计题**：设计一个高效的I/O调度算法
4. **实现题**：实现一个带有缓存管理的字符设备驱动
5. **优化题**：优化给定的设备驱动程序，提升I/O性能

## 下一讲预告

第15讲将介绍文件系统，包括：

- 文件系统基本概念
- 虚拟文件系统（VFS）
- 文件系统实现
- 日志文件系统
- 分布式文件系统

## 参考资料

- 南京大学操作系统课程讲义: https://jyywiki.cn/OS/2025/
- B站视频资源: [南京大学操作系统课程](https://www.bilibili.com/video/BV1GX4y1K7Kj/)
- 《操作系统概念》- Abraham Silberschatz
- 《深入理解Linux内核》- Daniel P. Bovet