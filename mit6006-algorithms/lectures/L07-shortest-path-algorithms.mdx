---
title: "L07 - æœ€çŸ­è·¯å¾„ç®—æ³•"
description: "æ·±å…¥ç†è§£Dijkstraã€Bellman-Fordã€Floyd-Warshallç­‰æœ€çŸ­è·¯å¾„ç®—æ³•"
---

import { useState, useEffect } from 'react';
import { CodeBlock } from '@/src/components/algorithm';
import { AlgorithmVisualizer } from '@/src/components/algorithm';
import { ArrayVisualizer } from '@/src/components/algorithm';
import { ComplexityAnalyzer } from '@/src/components/algorithm';
import { ExerciseBlock } from '@/src/components/algorithm';

# L07 - æœ€çŸ­è·¯å¾„ç®—æ³•

## ğŸ“š å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è®²ä¹‰åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ğŸ¯ **æŒæ¡æ ¸å¿ƒç®—æ³•**ï¼šç²¾é€šDijkstraã€Bellman-Fordã€Floyd-Warshallç®—æ³•
- âš¡ **åˆ†æé€‚ç”¨åœºæ™¯**ï¼šæ ¹æ®å›¾çš„ç‰¹ç‚¹é€‰æ‹©æœ€ä¼˜ç®—æ³•
- ğŸ› ï¸ **å®ç°ä¼˜åŒ–ç­–ç•¥**ï¼šåº”ç”¨ä¼˜å…ˆé˜Ÿåˆ—å’ŒåŒå‘æœç´¢ä¼˜åŒ–
- ğŸŒ **è§£å†³å®é™…é—®é¢˜**ï¼šå¤„ç†è·¯ç”±ã€å¯¼èˆªç­‰æœ€çŸ­è·¯å¾„åº”ç”¨

## ğŸ¯ æœ€çŸ­è·¯å¾„é—®é¢˜æ¦‚è¿°

### é—®é¢˜çš„åˆ†ç±»ä¸å®šä¹‰

**æœ€çŸ­è·¯å¾„é—®é¢˜**ï¼šåœ¨åŠ æƒå›¾ä¸­æ‰¾åˆ°ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ€»æƒé‡æœ€å°çš„è·¯å¾„ã€‚

| é—®é¢˜ç±»å‹ | é€‚ç”¨æ¡ä»¶ | æ—¶é—´å¤æ‚åº¦ | ä¸»è¦åº”ç”¨ |
|----------|----------|------------|----------|
| **å•æºæœ€çŸ­è·¯å¾„** | éè´Ÿæƒé‡ | O((V+E)log V) | GPSå¯¼èˆª |
| **å•æºæœ€çŸ­è·¯å¾„** | å…è®¸è´Ÿæƒé‡ | O(VE) | é‡‘èåˆ†æ |
| **æ‰€æœ‰é¡¶ç‚¹å¯¹æœ€çŸ­è·¯å¾„** | æ— é™åˆ¶ | O(VÂ³) | ç½‘ç»œè·¯ç”± |
| **å•ç›®æ ‡æœ€çŸ­è·¯å¾„** | éè´Ÿæƒé‡ | O((V+E)log V) | ç‰©æµé…é€ |

### é‡è¦æ¦‚å¿µ

```python
def shortest_path_concepts():
    """
    æœ€çŸ­è·¯å¾„ç®—æ³•çš„é‡è¦æ¦‚å¿µ
    """
    concepts = {
        "æ¾å¼›æ“ä½œ": "æ›´æ–°åˆ°é¡¶ç‚¹çš„æœ€çŸ­è·ç¦»ä¼°è®¡",
        "ä¼˜å…ˆé˜Ÿåˆ—": "é«˜æ•ˆé€‰æ‹©ä¸‹ä¸€ä¸ªé¡¶ç‚¹çš„æ•°æ®ç»“æ„",
        "è´Ÿæƒé‡è¾¹": "æƒé‡ä¸ºè´Ÿçš„è¾¹ï¼Œå½±å“ç®—æ³•æ­£ç¡®æ€§",
        "è´Ÿæƒé‡ç¯": "æ€»æƒé‡ä¸ºè´Ÿçš„ç¯ï¼Œä½¿æœ€çŸ­è·¯å¾„æ— å®šä¹‰",
        "æœ€çŸ­è·¯å¾„æ ‘": "åŒ…å«æºç‚¹åˆ°æ‰€æœ‰é¡¶ç‚¹æœ€çŸ­è·¯å¾„çš„æ ‘",
        "å‰é©±èŠ‚ç‚¹": "åœ¨æœ€çŸ­è·¯å¾„ä¸­å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹"
    }

    print("é‡è¦æ¦‚å¿µï¼š")
    for concept, definition in concepts.items():
        print(f"â€¢ {concept}: {definition}")

# æ¾å¼›æ“ä½œçš„æ•°å­¦å®šä¹‰
def relax(u, v, weight, dist, prev):
    """
    æ¾å¼›æ“ä½œï¼šå°è¯•é€šè¿‡uæ”¹è¿›åˆ°vçš„æœ€çŸ­è·ç¦»
    """
    if dist[u] + weight < dist[v]:
        dist[v] = dist[u] + weight
        prev[v] = u
        return True  # å‘ç”Ÿäº†æ¾å¼›
    return False
```

## ğŸ”§ Dijkstraç®—æ³•

### æ ¸å¿ƒæ€æƒ³ä¸å®ç°

Dijkstraç®—æ³•ç”¨äºè§£å†³**éè´Ÿæƒé‡å›¾**çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š
1. åˆå§‹åŒ–è·ç¦»æ•°ç»„ï¼Œæºç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–ä¸ºâˆ
2. ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹
3. å¯¹è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»å±…è¿›è¡Œæ¾å¼›æ“ä½œ
4. é‡å¤ç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®

```python
import heapq
from typing import List, Dict, Tuple, Set
import math

class DijkstraAlgorithm:
    """
    Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•
    æ—¶é—´å¤æ‚åº¦: O((V + E) log V) ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—
    ç©ºé—´å¤æ‚åº¦: O(V)
    å±€é™æ€§: ä¸èƒ½å¤„ç†è´Ÿæƒé‡è¾¹
    """
    def __init__(self, graph):
        self.graph = graph
        self.num_vertices = graph.num_vertices

    def dijkstra(self, source):
        """
        æ ‡å‡†Dijkstraç®—æ³•å®ç°
        è¿”å›: (distances, predecessors)
        """
        # åˆå§‹åŒ–
        distances = [math.inf] * self.num_vertices
        predecessors = [-1] * self.num_vertices
        distances[source] = 0

        # ä¼˜å…ˆé˜Ÿåˆ—: (distance, vertex)
        priority_queue = [(0, source)]
        visited = set()

        while priority_queue:
            current_distance, current_vertex = heapq.heappop(priority_queue)

            # å¦‚æœå·²ç»æ‰¾åˆ°æ›´çŸ­çš„è·¯å¾„ï¼Œè·³è¿‡
            if current_vertex in visited:
                continue

            visited.add(current_vertex)

            # å¯¹æ‰€æœ‰é‚»å±…è¿›è¡Œæ¾å¼›æ“ä½œ
            for neighbor, weight in self.graph.get_neighbors(current_vertex):
                if neighbor not in visited:
                    new_distance = current_distance + weight

                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        predecessors[neighbor] = current_vertex
                        heapq.heappush(priority_queue, (new_distance, neighbor))

        return distances, predecessors

    def get_shortest_path(self, source, target):
        """è·å–ä»sourceåˆ°targetçš„æœ€çŸ­è·¯å¾„"""
        distances, predecessors = self.dijkstra(source)

        if distances[target] == math.inf:
            return []  # æ²¡æœ‰è·¯å¾„

        # é‡å»ºè·¯å¾„
        path = []
        current = target
        while current != -1:
            path.append(current)
            current = predecessors[current]

        return path[::-1]

    def dijkstra_with_path_reconstruction(self, source):
        """å¸¦è·¯å¾„é‡å»ºçš„Dijkstraç®—æ³•"""
        distances = [math.inf] * self.num_vertices
        predecessors = [-1] * self.num_vertices
        distances[source] = 0

        priority_queue = [(0, source, [-1])]  # (distance, vertex, path)

        while priority_queue:
            current_distance, current_vertex, path = heapq.heappop(priority_queue)

            if current_distance > distances[current_vertex]:
                continue

            # æ›´æ–°å‰é©±
            if len(path) > 1:
                predecessors[current_vertex] = path[-2]

            for neighbor, weight in self.graph.get_neighbors(current_vertex):
                new_distance = current_distance + weight

                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    new_path = path + [current_vertex]
                    heapq.heappush(priority_queue, (new_distance, neighbor, new_path))

        return distances, predecessors
```

### ä¼˜åŒ–ç‰ˆæœ¬çš„Dijkstra

```python
class OptimizedDijkstra:
    """
    ä¼˜åŒ–çš„Dijkstraç®—æ³•å®ç°
    """
    def __init__(self, graph):
        self.graph = graph

    def dijkstra_with_fibonacci_heap(self, source):
        """
        ä½¿ç”¨æ–æ³¢é‚£å¥‘å †ä¼˜åŒ–
        ç†è®ºæ—¶é—´å¤æ‚åº¦: O(V log V + E)
        """
        # æ–æ³¢é‚£å¥‘å †å®ç°è¾ƒä¸ºå¤æ‚ï¼Œè¿™é‡Œç”¨æ¦‚å¿µæ€§ä»£ç 
        distances = [math.inf] * self.graph.num_vertices
        predecessors = [-1] * self.graph.num_vertices
        distances[source] = 0

        # æ¨¡æ‹Ÿæ–æ³¢é‚£å¥‘å †æ“ä½œ
        heap = FibonacciHeap()
        nodes = [heap.insert(math.inf, i) for i in range(self.graph.num_vertices)]
        heap.decrease_key(nodes[source], 0)

        while not heap.is_empty():
            current_distance, current_vertex = heap.extract_min()

            for neighbor, weight in self.graph.get_neighbors(current_vertex):
                new_distance = current_distance + weight

                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    predecessors[neighbor] = current_vertex
                    heap.decrease_key(nodes[neighbor], new_distance)

        return distances, predecessors

    def bidirectional_dijkstra(self, source, target):
        """
        åŒå‘Dijkstraç®—æ³•
        æ—¶é—´å¤æ‚åº¦: O(b^(d/2))ï¼Œå…¶ä¸­bæ˜¯åˆ†æ”¯å› å­ï¼Œdæ˜¯è·ç¦»
        """
        if source == target:
            return [source], 0

        # æ­£å‘æœç´¢
        forward_distances = [math.inf] * self.graph.num_vertices
        forward_predecessors = [-1] * self.graph.num_vertices
        forward_distances[source] = 0
        forward_queue = [(0, source)]

        # åå‘æœç´¢
        backward_distances = [math.inf] * self.graph.num_vertices
        backward_predecessors = [-1] * self.graph.num_vertices
        backward_distances[target] = 0
        backward_queue = [(0, target)]

        best_distance = math.inf
        meeting_vertex = -1

        while forward_queue and backward_queue:
            # æ­£å‘æœç´¢ä¸€æ­¥
            if len(forward_queue) <= len(backward_queue):
                current_dist, current_vertex = heapq.heappop(forward_queue)

                # å¦‚æœå·²ç»æ‰¾åˆ°æ›´å¥½çš„è·¯å¾„ï¼Œè·³è¿‡
                if current_dist > forward_distances[current_vertex]:
                    continue

                # æ£€æŸ¥æ˜¯å¦åœ¨åå‘æœç´¢ä¸­è®¿é—®è¿‡
                if backward_distances[current_vertex] != math.inf:
                    total_distance = forward_distances[current_vertex] + backward_distances[current_vertex]
                    if total_distance < best_distance:
                        best_distance = total_distance
                        meeting_vertex = current_vertex

                # æ¾å¼›æ­£å‘è¾¹
                for neighbor, weight in self.graph.get_neighbors(current_vertex):
                    new_distance = current_dist + weight
                    if new_distance < forward_distances[neighbor]:
                        forward_distances[neighbor] = new_distance
                        forward_predecessors[neighbor] = current_vertex
                        heapq.heappush(forward_queue, (new_distance, neighbor))

            # åå‘æœç´¢ä¸€æ­¥
            else:
                current_dist, current_vertex = heapq.heappop(backward_queue)

                if current_dist > backward_distances[current_vertex]:
                    continue

                # æ£€æŸ¥æ˜¯å¦åœ¨æ­£å‘æœç´¢ä¸­è®¿é—®è¿‡
                if forward_distances[current_vertex] != math.inf:
                    total_distance = forward_distances[current_vertex] + backward_distances[current_vertex]
                    if total_distance < best_distance:
                        best_distance = total_distance
                        meeting_vertex = current_vertex

                # æ¾å¼›åå‘è¾¹ï¼ˆéœ€è¦è½¬ç½®å›¾ï¼‰
                for neighbor, weight in self.graph.get_neighbors(current_vertex):
                    new_distance = current_dist + weight
                    if new_distance < backward_distances[neighbor]:
                        backward_distances[neighbor] = new_distance
                        backward_predecessors[neighbor] = current_vertex
                        heapq.heappush(backward_queue, (new_distance, neighbor))

        # é‡å»ºæœ€çŸ­è·¯å¾„
        if meeting_vertex == -1:
            return [], math.inf  # æ²¡æœ‰è·¯å¾„

        # æ„å»ºè·¯å¾„
        forward_path = []
        current = meeting_vertex
        while current != -1:
            forward_path.append(current)
            current = forward_predecessors[current]

        backward_path = []
        current = meeting_vertex
        while current != -1:
            backward_path.append(current)
            current = backward_predecessors[current]

        full_path = forward_path[::-1] + backward_path[1:]

        return full_path, best_distance

class FibonacciHeap:
    """æ–æ³¢é‚£å¥‘å †çš„ç®€åŒ–å®ç°"""
    def __init__(self):
        self.min_node = None
        self.size = 0

    def insert(self, key, value):
        """æ’å…¥èŠ‚ç‚¹"""
        node = FibonacciNode(key, value)
        if self.min_node is None:
            self.min_node = node
        else:
            # åˆå¹¶åˆ°æ ¹åˆ—è¡¨
            node.right = self.min_node
            node.left = self.min_node.left
            self.min_node.left.right = node
            self.min_node.left = node

            if key < self.min_node.key:
                self.min_node = node

        self.size += 1
        return node

    def extract_min(self):
        """æå–æœ€å°èŠ‚ç‚¹"""
        if self.min_node is None:
            return None

        min_node = self.min_node
        if min_node.child:
            # å°†å­èŠ‚ç‚¹åˆå¹¶åˆ°æ ¹åˆ—è¡¨
            child = min_node.child
            while child:
                next_child = child.right
                # å°†childæ’å…¥åˆ°æ ¹åˆ—è¡¨
                child.left = self.min_node.left
                child.right = self.min_node
                self.min_node.left.right = child
                self.min_node.left = child
                child = next_child

        # ä»æ ¹åˆ—è¡¨ä¸­ç§»é™¤min_node
        min_node.left.right = min_node.right
        min_node.right.left = min_node.left

        if min_node == min_node.right:
            self.min_node = None
        else:
            self.min_node = min_node.right
            self._consolidate()

        self.size -= 1
        return min_node.key, min_node.value

    def decrease_key(self, node, new_key):
        """å‡å°‘èŠ‚ç‚¹çš„key"""
        if new_key > node.key:
            return False

        node.key = new_key
        parent = node.parent

        if parent and new_key < parent.key:
            self._cut(node, parent)
            self._cascading_cut(parent)

        if new_key < self.min_node.key:
            self.min_node = node

        return True

    def _cut(self, node, parent):
        """å‰ªåˆ‡èŠ‚ç‚¹"""
        # ä»çˆ¶èŠ‚ç‚¹çš„å­åˆ—è¡¨ä¸­ç§»é™¤
        if node.right == node:
            parent.child = None
        else:
            node.left.right = node.right
            node.right.left = node.left
            if parent.child == node:
                parent.child = node.right

        parent.degree -= 1
        # æ·»åŠ åˆ°æ ¹åˆ—è¡¨
        node.left = self.min_node.left
        node.right = self.min_node
        self.min_node.left.right = node
        self.min_node.left = node
        node.parent = None
        node.marked = False

    def _cascading_cut(self, node):
        """çº§è”å‰ªåˆ‡"""
        parent = node.parent
        if parent:
            if not node.marked:
                node.marked = True
            else:
                self._cut(node, parent)
                self._cascading_cut(parent)

    def _consolidate(self):
        """åˆå¹¶ç›¸åŒåº¦çš„æ ‘"""
        # å®ç°è¾ƒä¸ºå¤æ‚ï¼Œè¿™é‡Œçœç•¥
        pass

    def is_empty(self):
        return self.size == 0

class FibonacciNode:
    """æ–æ³¢é‚£å¥‘å †èŠ‚ç‚¹"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.degree = 0
        self.parent = None
        self.child = None
        self.left = self
        self.right = self
        self.marked = False
```

<ExerciseBlock
  title="Dijkstraç®—æ³•åˆ†æ"
  question:"Dijkstraç®—æ³•ä¸ºä»€ä¹ˆä¸èƒ½å¤„ç†è´Ÿæƒé‡è¾¹ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "å› ä¸ºè´Ÿæƒé‡è¾¹ä¼šå¯¼è‡´æ— é™å¾ªç¯",
      correct: false,
      explanation: "é—®é¢˜ä¸æ˜¯æ— é™å¾ªç¯ï¼Œè€Œæ˜¯ç®—æ³•çš„æ­£ç¡®æ€§"
    },
    {
      id: "b",
      text: "å› ä¸ºä¸€æ—¦é¡¶ç‚¹è¢«æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œå°±ä¸å†æ›´æ–°å…¶è·ç¦»",
      correct: true,
      explanation: "æ­£ç¡®ï¼Dijkstraçš„è´ªå¿ƒç­–ç•¥å‡è®¾å½“å‰æ‰¾åˆ°çš„è·ç¦»æ˜¯æœ€çŸ­çš„ï¼Œä½†è´Ÿæƒé‡å¯èƒ½æä¾›æ›´çŸ­è·¯å¾„"
    },
    {
      id: "c",
      text: "å› ä¸ºè´Ÿæƒé‡è¾¹ä¼šä½¿ä¼˜å…ˆé˜Ÿåˆ—å¤±æ•ˆ",
      correct: false,
      explanation: "ä¼˜å…ˆé˜Ÿåˆ—ä»ç„¶å¯ä»¥å·¥ä½œ"
    },
    {
      id: "d",
      text: "å› ä¸ºè´Ÿæƒé‡è¾¹ä¼šäº§ç”Ÿè´Ÿæ— ç©·çš„è·ç¦»",
      correct: false,
      explanation: "è´Ÿæƒé‡ä¸ä¸€å®šä¼šäº§ç”Ÿè´Ÿæ— ç©·"
    }
  ]}
  hint="è€ƒè™‘Dijkstraç®—æ³•çš„è´ªå¿ƒé€‰æ‹©ç­–ç•¥"
/>
```

## ğŸ”§ Bellman-Fordç®—æ³•

### æ ¸å¿ƒæ€æƒ³ä¸å®ç°

Bellman-Fordç®—æ³•å¯ä»¥å¤„ç†**è´Ÿæƒé‡è¾¹**ï¼Œå¹¶èƒ½æ£€æµ‹è´Ÿæƒé‡ç¯ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š
1. åˆå§‹åŒ–è·ç¦»æ•°ç»„
2. å¯¹æ‰€æœ‰è¾¹è¿›è¡ŒV-1æ¬¡æ¾å¼›æ“ä½œ
3. ç¬¬Væ¬¡æ¾å¼›æ£€æŸ¥è´Ÿæƒé‡ç¯

```python
class BellmanFordAlgorithm:
    """
    Bellman-Fordæœ€çŸ­è·¯å¾„ç®—æ³•
    æ—¶é—´å¤æ‚åº¦: O(VE)
    ç©ºé—´å¤æ‚åº¦: O(V)
    ä¼˜ç‚¹: å¯ä»¥å¤„ç†è´Ÿæƒé‡è¾¹ï¼Œæ£€æµ‹è´Ÿæƒé‡ç¯
    """
    def __init__(self, graph):
        self.graph = graph

    def bellman_ford(self, source):
        """
        æ ‡å‡†Bellman-Fordç®—æ³•
        è¿”å›: (distances, predecessors, has_negative_cycle)
        """
        num_vertices = self.graph.num_vertices
        distances = [math.inf] * num_vertices
        predecessors = [-1] * num_vertices
        distances[source] = 0

        # è·å–æ‰€æœ‰è¾¹
        edges = []
        for vertex in range(num_vertices):
            for neighbor, weight in self.graph.get_neighbors(vertex):
                edges.append((vertex, neighbor, weight))

        # æ¾å¼›æ“ä½œé‡å¤V-1æ¬¡
        for i in range(num_vertices - 1):
            updated = False
            for u, v, weight in edges:
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
                    predecessors[v] = u
                    updated = True

            # å¦‚æœæ²¡æœ‰æ›´æ–°ï¼Œå¯ä»¥æå‰ç»ˆæ­¢
            if not updated:
                break

        # æ£€æŸ¥è´Ÿæƒé‡ç¯
        has_negative_cycle = False
        for u, v, weight in edges:
            if distances[u] != math.inf and distances[u] + weight < distances[v]:
                has_negative_cycle = True
                break

        return distances, predecessors, has_negative_cycle

    def bellman_ford_with_path_reconstruction(self, source, target):
        """å¸¦è·¯å¾„é‡å»ºçš„Bellman-Ford"""
        distances, predecessors, has_negative_cycle = self.bellman_ford(source)

        if has_negative_cycle:
            return None, "å›¾ä¸­å­˜åœ¨è´Ÿæƒé‡ç¯"
        if distances[target] == math.inf:
            return None, "æ²¡æœ‰è·¯å¾„ä»æºç‚¹åˆ°ç›®æ ‡ç‚¹"

        # é‡å»ºè·¯å¾„
        path = []
        current = target
        while current != -1:
            path.append(current)
            current = predecessors[current]

        return path[::-1], distances[target]

    def find_negative_cycle(self):
        """æ‰¾åˆ°è´Ÿæƒé‡ç¯"""
        num_vertices = self.graph.num_vertices
        distances = [math.inf] * num_vertices
        predecessors = [-1] * num_vertices

        # ä»æ¯ä¸ªé¡¶ç‚¹å¼€å§‹
        for start in range(num_vertices):
            distances = [math.inf] * num_vertices
            predecessors = [-1] * num_vertices
            distances[start] = 0

            edges = []
            for vertex in range(num_vertices):
                for neighbor, weight in self.graph.get_neighbors(vertex):
                    edges.append((vertex, neighbor, weight))

            # V-1æ¬¡æ¾å¼›
            for i in range(num_vertices - 1):
                for u, v, weight in edges:
                    if distances[u] != math.inf and distances[u] + weight < distances[v]:
                        distances[v] = distances[u] + weight
                        predecessors[v] = u

            # ç¬¬Væ¬¡æ¾å¼›æ‰¾è´Ÿç¯
            negative_cycle_edge = None
            for u, v, weight in edges:
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    negative_cycle_edge = (u, v)
                    break

            if negative_cycle_edge:
                # æ‰¾åˆ°è´Ÿç¯ä¸­çš„é¡¶ç‚¹
                u, v = negative_cycle_edge
                cycle_vertices = set()
                current = v

                # å›æº¯æ‰¾åˆ°ç¯
                while current not in cycle_vertices:
                    cycle_vertices.add(current)
                    current = predecessors[current]

                # æ„å»ºç¯
                cycle_start = current
                cycle = [cycle_start]
                current = predecessors[cycle_start]
                while current != cycle_start:
                    cycle.append(current)
                    current = predecessors[current]
                cycle.append(cycle_start)

                return cycle[::-1]

        return None

    def bellman_ford_optimized(self, source):
        """
        ä¼˜åŒ–çš„Bellman-Fordç®—æ³•
        ä½¿ç”¨é˜Ÿåˆ—åªå¤„ç†è·ç¦»å‘ç”Ÿå˜åŒ–çš„é¡¶ç‚¹
        """
        num_vertices = self.graph.num_vertices
        distances = [math.inf] * num_vertices
        predecessors = [-1] * num_vertices
        distances[source] = 0

        from collections import deque
        queue = deque([source])
        in_queue = [False] * num_vertices
        in_queue[source] = True
        queue_count = [0] * num_vertices
        queue_count[source] = 1

        while queue:
            u = queue.popleft()
            in_queue[u] = False

            for v, weight in self.graph.get_neighbors(u):
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
                    predecessors[v] = u

                    if not in_queue[v]:
                        queue.append(v)
                        in_queue[v] = True
                        queue_count[v] += 1

                        # å¦‚æœæŸä¸ªé¡¶ç‚¹è¢«å…¥é˜Ÿè¶…è¿‡Væ¬¡ï¼Œå­˜åœ¨è´Ÿç¯
                        if queue_count[v] > num_vertices:
                            return distances, predecessors, True

        # æ£€æŸ¥è´Ÿç¯
        for u in range(num_vertices):
            for v, weight in self.graph.get_neighbors(u):
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    return distances, predecessors, True

        return distances, predecessors, False
```

### SPFAç®—æ³• (Shortest Path Faster Algorithm)

```python
class SPFAAlgorithm:
    """
    SPFAç®—æ³• - Bellman-Fordçš„é˜Ÿåˆ—ä¼˜åŒ–ç‰ˆæœ¬
    å¹³å‡æ—¶é—´å¤æ‚åº¦: O(E)ï¼Œæœ€åO(VE)
    """
    def __init__(self, graph):
        self.graph = graph

    def spfa(self, source):
        """æ ‡å‡†SPFAç®—æ³•"""
        num_vertices = self.graph.num_vertices
        distances = [math.inf] * num_vertices
        predecessors = [-1] * num_vertices
        in_queue = [False] * num_vertices
        queue_count = [0] * num_vertices

        distances[source] = 0
        queue = deque([source])
        in_queue[source] = True
        queue_count[source] = 1

        while queue:
            u = queue.popleft()
            in_queue[u] = False

            for v, weight in self.graph.get_neighbors(u):
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
                    predecessors[v] = u

                    if not in_queue[v]:
                        queue.append(v)
                        in_queue[v] = True
                        queue_count[v] += 1

                        # æ£€æµ‹è´Ÿç¯
                        if queue_count[v] > num_vertices:
                            return distances, predecessors, True

        # æ£€æŸ¥æ˜¯å¦è¿˜å­˜åœ¨å¯æ¾å¼›çš„è¾¹
        for u in range(num_vertices):
            for v, weight in self.graph.get_neighbors(u):
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    return distances, predecessors, True

        return distances, predecessors, False

    def spfa_with_early_termination(self, source, target=None):
        """å¸¦æå‰ç»ˆæ­¢çš„SPFA"""
        num_vertices = self.graph.num_vertices
        distances = [math.inf] * num_vertices
        predecessors = [-1] * num_vertices
        in_queue = [False] * num_vertices

        distances[source] = 0
        queue = deque([source])
        in_queue[source] = True

        while queue:
            u = queue.popleft()
            in_queue[u] = False

            # å¦‚æœå·²ç»æ‰¾åˆ°ç›®æ ‡ä¸”æ˜¯æœ€çŸ­çš„ï¼Œå¯ä»¥æå‰ç»ˆæ­¢
            if target is not None and u == target:
                break

            for v, weight in self.graph.get_neighbors(u):
                if distances[u] != math.inf and distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
                    predecessors[v] = u

                    if not in_queue[v]:
                        queue.append(v)
                        in_queue[v] = True

        return distances, predecessors
```

<ExerciseBlock
  title="Bellman-Fordåº”ç”¨"
  question:"åœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥é€‰æ‹©Bellman-Fordè€Œä¸æ˜¯Dijkstraç®—æ³•ï¼Ÿ"
  type="multiple-choice"
  difficulty="easy"
  options={[
    {
      id: "a",
      text: "å½“å›¾å¾ˆå¤§æ—¶",
      correct: false,
      explanation: "Bellman-Fordçš„æ—¶é—´å¤æ‚åº¦æ›´é«˜"
    },
    {
      id: "b",
      text: "å½“å­˜åœ¨è´Ÿæƒé‡è¾¹æ—¶",
      correct: true,
      explanation: "æ­£ç¡®ï¼Bellman-Fordå¯ä»¥å¤„ç†è´Ÿæƒé‡è¾¹"
    },
    {
      id: "c",
      text: "å½“éœ€è¦æœ€çŸ­è·¯å¾„æ—¶",
      correct: false,
      explanation: "ä¸¤ç§ç®—æ³•éƒ½å¯ä»¥æ‰¾æœ€çŸ­è·¯å¾„"
    },
    {
      id: "d",
      text: "å½“å›¾å¾ˆç¨ å¯†æ—¶",
      correct: false,
      explanation: "ç¨ å¯†å›¾é€šå¸¸æ›´é€‚åˆDijkstra"
    }
  ]}
  hint="è€ƒè™‘ä¸¤ç§ç®—æ³•çš„å¤„ç†èƒ½åŠ›å·®å¼‚"
/>
```

## ğŸ”§ Floyd-Warshallç®—æ³•

### æ ¸å¿ƒæ€æƒ³ä¸å®ç°

Floyd-Warshallç®—æ³•è§£å†³**æ‰€æœ‰é¡¶ç‚¹å¯¹**çš„æœ€çŸ­è·¯å¾„é—®é¢˜ã€‚

**ç®—æ³•æ€æƒ³**ï¼šåŠ¨æ€è§„åˆ’ï¼Œè€ƒè™‘æ˜¯å¦ç»è¿‡ä¸­é—´é¡¶ç‚¹kæ¥ä¼˜åŒ–iåˆ°jçš„è·¯å¾„ã€‚

```python
class FloydWarshallAlgorithm:
    """
    Floyd-Warshallæ‰€æœ‰é¡¶ç‚¹å¯¹æœ€çŸ­è·¯å¾„ç®—æ³•
    æ—¶é—´å¤æ‚åº¦: O(VÂ³)
    ç©ºé—´å¤æ‚åº¦: O(VÂ²)
    ä¼˜ç‚¹: å¯ä»¥å¤„ç†è´Ÿæƒé‡ï¼ˆæ— è´Ÿç¯ï¼‰ï¼Œä»£ç ç®€æ´
    """
    def __init__(self, graph):
        self.graph = graph
        self.num_vertices = graph.num_vertices

    def floyd_warshall(self):
        """
        æ ‡å‡†Floyd-Warshallç®—æ³•
        è¿”å›: (distance_matrix, predecessor_matrix)
        """
        # åˆå§‹åŒ–è·ç¦»çŸ©é˜µå’Œå‰é©±çŸ©é˜µ
        dist = [[math.inf] * self.num_vertices for _ in range(self.num_vertices)]
        prev = [[-1] * self.num_vertices for _ in range(self.num_vertices)]

        # å¯¹è§’çº¿è®¾ä¸º0
        for i in range(self.num_vertices):
            dist[i][i] = 0

        # å¡«å……åˆå§‹è·ç¦»
        for u in range(self.num_vertices):
            for v, weight in self.graph.get_neighbors(u):
                dist[u][v] = weight
                prev[u][v] = u

        # åŠ¨æ€è§„åˆ’
        for k in range(self.num_vertices):
            for i in range(self.num_vertices):
                for j in range(self.num_vertices):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
                        prev[i][j] = prev[k][j]

        return dist, prev

    def floyd_warshall_with_negative_cycle_detection(self):
        """å¸¦è´Ÿç¯æ£€æµ‹çš„Floyd-Warshall"""
        dist, prev = self.floyd_warshall()

        # æ£€æŸ¥è´Ÿç¯ï¼šå¦‚æœdist[i][i] < 0ï¼Œåˆ™å­˜åœ¨è´Ÿç¯
        negative_cycles = []
        for i in range(self.num_vertices):
            if dist[i][i] < 0:
                negative_cycles.append(i)

        return dist, prev, negative_cycles

    def reconstruct_path(self, prev, source, target):
        """é‡å»ºä»sourceåˆ°targetçš„è·¯å¾„"""
        if prev[source][target] == -1:
            if source == target:
                return [source]
            else:
                return []  # æ²¡æœ‰è·¯å¾„

        path = [target]
        current = target
        while current != source:
            current = prev[source][current]
            path.append(current)

        return path[::-1]

    def floyd_warshall_optimized(self):
        """ç©ºé—´ä¼˜åŒ–çš„Floyd-Warshall"""
        # ä½¿ç”¨å•ä¸ªçŸ©é˜µï¼Œé€å±‚æ›´æ–°
        dist = [[math.inf] * self.num_vertices for _ in range(self.num_vertices)]

        for i in range(self.num_vertices):
            dist[i][i] = 0

        for u in range(self.num_vertices):
            for v, weight in self.graph.get_neighbors(u):
                dist[u][v] = weight

        # æ³¨æ„ï¼šè¿™ç§ä¼˜åŒ–æ— æ³•é‡å»ºè·¯å¾„
        for k in range(self.num_vertices):
            for i in range(self.num_vertices):
                for j in range(self.num_vertices):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]

        return dist

    def transitive_closure(self):
        """
        è®¡ç®—ä¼ é€’é—­åŒ…
        åˆ¤æ–­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¦å¯è¾¾
        """
        reach = [[False] * self.num_vertices for _ in range(self.num_vertices)]

        # åˆå§‹åŒ–ï¼šæ¯ä¸ªé¡¶ç‚¹åˆ°è‡ªèº«å¯è¾¾
        for i in range(self.num_vertices):
            reach[i][i] = True

        # æœ‰è¾¹ç›´æ¥å¯è¾¾
        for u in range(self.num_vertices):
            for v, _ in self.graph.get_neighbors(u):
                reach[u][v] = True

        # Warshallç®—æ³•
        for k in range(self.num_vertices):
            for i in range(self.num_vertices):
                for j in range(self.num_vertices):
                    reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])

        return reach
```

## ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

### 1. GPSå¯¼èˆªç³»ç»Ÿ

```python
class GPSNavigation:
    """
    GPSå¯¼èˆªç³»ç»Ÿ
    ä½¿ç”¨Dijkstraç®—æ³•è®¡ç®—æœ€çŸ­è·¯å¾„
    """
    def __init__(self):
        self.graph = AdjacencyList(directed=True)  # æœ‰å‘å›¾
        self.locations = {}  # åœ°ç†ä½ç½®ä¿¡æ¯
        self.traffic_data = {}  # å®æ—¶äº¤é€šæ•°æ®

    def add_location(self, location_id, name, coordinates):
        """æ·»åŠ åœ°ç‚¹"""
        self.locations[location_id] = {
            "name": name,
            "coordinates": coordinates
        }

    def add_road(self, from_id, to_id, distance, road_type="normal"):
        """æ·»åŠ é“è·¯"""
        # æ ¹æ®é“è·¯ç±»å‹å’Œäº¤é€šæƒ…å†µè°ƒæ•´æƒé‡
        base_weight = distance
        traffic_factor = self.traffic_data.get((from_id, to_id), 1.0)

        # ä¸åŒé“è·¯ç±»å‹çš„æ—¶é—´æƒé‡
        road_factors = {
            "highway": 0.8,
            "normal": 1.0,
            "local": 1.2,
            "congested": 2.0
        }

        weight = base_weight * traffic_factor * road_factors.get(road_type, 1.0)
        self.graph.add_edge(from_id, to_id, weight)

    def update_traffic(self, from_id, to_id, congestion_level):
        """æ›´æ–°äº¤é€šçŠ¶å†µ"""
        # congestion_level: 0-1, 0ä¸ºç•…é€šï¼Œ1ä¸ºæåº¦æ‹¥å µ
        self.traffic_data[(from_id, to_id)] = 1.0 + congestion_level * 2.0

    def find_fastest_route(self, start_id, end_id):
        """æ‰¾åˆ°æœ€å¿«è·¯çº¿"""
        dijkstra = DijkstraAlgorithm(self.graph)
        distances, predecessors = dijkstra.dijkstra(start_id)

        if distances[end_id] == math.inf:
            return None, "æ— æ³•åˆ°è¾¾ç›®çš„åœ°"

        # é‡å»ºè·¯å¾„
        path = []
        current = end_id
        while current != -1:
            path.append(current)
            current = predecessors[current]

        path = path[::-1]

        # è®¡ç®—æ€»è·ç¦»å’Œæ—¶é—´
        total_distance = distances[end_id]
        estimated_time = total_distance / 60  # å‡è®¾60km/hå¹³å‡é€Ÿåº¦

        return {
            "path": path,
            "total_distance": total_distance,
            "estimated_time": estimated_time,
            "route_description": self._describe_route(path)
        }

    def _describe_route(self, path):
        """ç”Ÿæˆè·¯çº¿æè¿°"""
        if len(path) < 2:
            return "èµ·ç‚¹å³ç»ˆç‚¹"

        description = []
        for i in range(len(path) - 1):
            from_loc = self.locations[path[i]]["name"]
            to_loc = self.locations[path[i + 1]]["name"]
            description.append(f"ä»{from_loc}å‰å¾€{to_loc}")

        return " â†’ ".join(description)

    def find_alternative_routes(self, start_id, end_id, num_alternatives=3):
        """æ‰¾åˆ°å¤šæ¡å¤‡é€‰è·¯çº¿"""
        # ä½¿ç”¨A*ç®—æ³•æˆ–åˆ é™¤æœ€çŸ­è·¯å¾„ä¸­çš„è¾¹æ¥æ‰¾å¤‡é€‰è·¯çº¿
        main_route = self.find_fastest_route(start_id, end_id)
        if main_route[0] is None:
            return []

        alternatives = []
        # å®ç°Kæœ€çŸ­è·¯å¾„ç®—æ³•
        # è¿™é‡Œç®€åŒ–å®ç°
        return alternatives

    def find_nearest_service(self, current_location, service_type):
        """æ‰¾åˆ°æœ€è¿‘çš„æœåŠ¡è®¾æ–½"""
        service_locations = self._get_service_locations(service_type)
        if not service_locations:
            return None

        # è®¡ç®—åˆ°æ‰€æœ‰æœåŠ¡è®¾æ–½çš„è·ç¦»
        dijkstra = DijkstraAlgorithm(self.graph)
        distances, _ = dijkstra.dijkstra(current_location)

        # æ‰¾åˆ°æœ€è¿‘çš„æœåŠ¡è®¾æ–½
        nearest_service = min(service_locations,
                             key=lambda loc: distances[loc])

        return {
            "service_id": nearest_service,
            "distance": distances[nearest_service],
            "route": self.find_fastest_route(current_location, nearest_service)
        }

    def _get_service_locations(self, service_type):
        """è·å–ç‰¹å®šç±»å‹çš„æœåŠ¡è®¾æ–½ä½ç½®"""
        # å®é™…åº”ç”¨ä¸­ä»æ•°æ®åº“è·å–
        services = {
            "gas_station": [101, 205, 308],
            "hospital": [102, 207, 310],
            "restaurant": [103, 206, 309]
        }
        return services.get(service_type, [])
```

### 2. ç½‘ç»œè·¯ç”±åè®®

```python
class NetworkRouter:
    """
    ç½‘ç»œè·¯ç”±å™¨å®ç°
    ä½¿ç”¨Floyd-Warshallç®—æ³•è®¡ç®—è·¯ç”±è¡¨
    """
    def __init__(self, router_id):
        self.router_id = router_id
        self.network_graph = AdjacencyList(directed=True)
        self.routing_table = {}
        self.neighbors = set()

    def add_link(self, destination, cost):
        """æ·»åŠ ç½‘ç»œé“¾æ¥"""
        self.network_graph.add_edge(self.router_id, destination, cost)
        self.neighbors.add(destination)

    def remove_link(self, destination):
        """ç§»é™¤ç½‘ç»œé“¾æ¥"""
        self.network_graph.remove_edge(self.router_id, destination)
        self.neighbors.discard(destination)

    def update_routing_table(self, all_routers):
        """æ›´æ–°è·¯ç”±è¡¨"""
        floyd = FloydWarshallAlgorithm(self.network_graph)
        distances, predecessors = floyd.floyd_warshall()

        self.routing_table = {}
        for destination in all_routers:
            if destination != self.router_id:
                if distances[self.router_id][destination] != math.inf:
                    self.routing_table[destination] = {
                        "next_hop": self._get_next_hop(predecessors, self.router_id, destination),
                        "cost": distances[self.router_id][destination]
                    }

    def _get_next_hop(self, predecessors, source, target):
        """è·å–ä¸‹ä¸€è·³è·¯ç”±å™¨"""
        if predecessors[source][target] == -1:
            return None

        # é‡å»ºè·¯å¾„ï¼Œæ‰¾åˆ°ç¬¬ä¸€è·³
        path = [target]
        current = target
        while current != source:
            current = predecessors[source][current]
            path.append(current)

        if len(path) >= 2:
            return path[-2]  # ç¬¬ä¸€è·³
        return None

    def route_packet(self, destination):
        """è·¯ç”±æ•°æ®åŒ…"""
        if destination == self.router_id:
            return "æœ¬åœ°äº¤ä»˜"

        if destination in self.routing_table:
            next_hop = self.routing_table[destination]["next_hop"]
            if next_hop:
                return f"è½¬å‘åˆ°è·¯ç”±å™¨ {next_hop}"
            else:
                return "æ— æ³•è·¯ç”±"
        else:
            return "æœªçŸ¥ç›®çš„åœ°"

    def distance_vector_routing(self, all_routers):
        """
        è·ç¦»å‘é‡è·¯ç”±ç®—æ³•ï¼ˆRIPåè®®ï¼‰
        """
        # åˆå§‹åŒ–è·ç¦»å‘é‡
        distance_vector = {router: math.inf for router in all_routers}
        distance_vector[self.router_id] = 0

        # Bellman-Fordæ–¹ç¨‹
        for _ in range(len(all_routers) - 1):
            updated = False
            for neighbor in self.neighbors:
                # ä»é‚»å±…æ¥æ”¶è·ç¦»å‘é‡
                neighbor_vector = self._receive_distance_vector(neighbor)

                # æ›´æ–°è‡ªå·±çš„è·ç¦»å‘é‡
                for router in all_routers:
                    new_distance = self._get_link_cost(neighbor) + neighbor_vector[router]
                    if new_distance < distance_vector[router]:
                        distance_vector[router] = new_distance
                        updated = True

            if not updated:
                break

        return distance_vector

    def _receive_distance_vector(self, neighbor):
        """æ¥æ”¶é‚»å±…çš„è·ç¦»å‘é‡"""
        # å®é™…ç½‘ç»œåè®®ä¸­é€šè¿‡æ•°æ®åŒ…æ¥æ”¶
        return self._simulate_neighbor_vector(neighbor)

    def _get_link_cost(self, neighbor):
        """è·å–åˆ°é‚»å±…çš„é“¾è·¯æˆæœ¬"""
        for n, cost in self.network_graph.get_neighbors(self.router_id):
            if n == neighbor:
                return cost
        return math.inf

    def _simulate_neighbor_vector(self, neighbor):
        """æ¨¡æ‹Ÿé‚»å±…çš„è·ç¦»å‘é‡"""
        # ç®€åŒ–å®ç°
        vector = {}
        for router in range(10):  # å‡è®¾æœ‰10ä¸ªè·¯ç”±å™¨
            vector[router] = abs(router - neighbor)  # ç®€å•çš„è·ç¦»æ¨¡æ‹Ÿ
        return vector
```

### 3. é‡‘èé£é™©åˆ†æ

```python
class FinancialRiskAnalyzer:
    """
    é‡‘èé£é™©åˆ†æç³»ç»Ÿ
    ä½¿ç”¨Bellman-Fordç®—æ³•æ£€æµ‹å¥—åˆ©æœºä¼š
    """
    def __init__(self):
        self.currency_graph = AdjacencyList(directed=True)
        self.currencies = {}

    def add_currency(self, currency_id, name):
        """æ·»åŠ è´§å¸"""
        self.currencies[currency_id] = name

    def add_exchange_rate(self, from_currency, to_currency, rate):
        """
        æ·»åŠ æ±‡ç‡
        rate: 1å•ä½from_currencyå¯ä»¥å…‘æ¢çš„to_currencyæ•°é‡
        """
        # è½¬æ¢ä¸ºå¯¹æ•°æƒé‡ï¼Œä¾¿äºæ£€æµ‹å¥—åˆ©
        weight = -math.log(rate)
        self.currency_graph.add_edge(from_currency, to_currency, weight)

    def detect_arbitrage(self):
        """
        æ£€æµ‹å¥—åˆ©æœºä¼š
        å¦‚æœå­˜åœ¨è´Ÿæƒé‡ç¯ï¼Œåˆ™å­˜åœ¨å¥—åˆ©æœºä¼š
        """
        bellman = BellmanFordAlgorithm(self.currency_graph)

        # ä»æ¯ä¸ªè´§å¸å¼€å§‹æ£€æµ‹
        for currency_id in self.currencies:
            distances, predecessors, has_negative_cycle = bellman.bellman_ford(currency_id)

            if has_negative_cycle:
                # æ‰¾åˆ°å…·ä½“çš„å¥—åˆ©è·¯å¾„
                arbitrage_cycle = bellman.find_negative_cycle()
                if arbitrage_cycle:
                    return {
                        "has_arbitrage": True,
                        "cycle": arbitrage_cycle,
                        "cycle_names": [self.currencies[c] for c in arbitrage_cycle],
                        "profit": self._calculate_arbitrage_profit(arbitrage_cycle)
                    }

        return {"has_arbitrage": False}

    def _calculate_arbitrage_profit(self, cycle):
        """è®¡ç®—å¥—åˆ©åˆ©æ¶¦"""
        if len(cycle) < 2:
            return 0

        # è®¡ç®—ç¯çš„æ±‡ç‡ä¹˜ç§¯
        product = 1.0
        for i in range(len(cycle) - 1):
            from_curr = cycle[i]
            to_curr = cycle[i + 1]

            # è·å–æ±‡ç‡
            for neighbor, weight in self.currency_graph.get_neighbors(from_curr):
                if neighbor == to_curr:
                    rate = math.exp(-weight)
                    product *= rate
                    break

        # è®¡ç®—åˆ©æ¶¦ç™¾åˆ†æ¯”
        profit_percentage = (product - 1.0) * 100
        return profit_percentage

    def find_best_conversion_path(self, from_currency, to_currency, amount=1):
        """æ‰¾åˆ°æœ€ä½³å…‘æ¢è·¯å¾„"""
        dijkstra = DijkstraAlgorithm(self.currency_graph)
        distances, predecessors = dijkstra.dijkstra(from_currency)

        if distances[to_currency] == math.inf:
            return None, "æ— æ³•å…‘æ¢"

        # é‡å»ºè·¯å¾„
        path = []
        current = to_currency
        while current != -1:
            path.append(current)
            current = predecessors[current]

        path = path[::-1]

        # è®¡ç®—æœ€ç»ˆé‡‘é¢
        final_amount = amount * math.exp(-distances[to_currency])

        return {
            "path": path,
            "path_names": [self.currencies[c] for c in path],
            "final_amount": final_amount,
            "exchange_rate": final_amount / amount
        }

    def currency_network_analysis(self):
        """åˆ†æè´§å¸ç½‘ç»œ"""
        floyd = FloydWarshallAlgorithm(self.currency_graph)
        distances, predecessors = floyd.floyd_warshall()

        analysis = {
            "most_connected_currency": self._find_most_connected(),
            "highest_volatility_pairs": self._find_high_volatility_pairs(distances),
            "conversion_efficiency": self._calculate_conversion_efficiency(distances)
        }

        return analysis

    def _find_most_connected(self):
        """æ‰¾åˆ°è¿æ¥æœ€å¤šçš„è´§å¸"""
        connections = {}
        for currency_id in self.currencies:
            connections[currency_id] = len(self.currency_graph.get_neighbors(currency_id))

        return max(connections.items(), key=lambda x: x[1])

    def _find_high_volatility_pairs(self, distances):
        """æ‰¾åˆ°é«˜æ³¢åŠ¨æ€§çš„è´§å¸å¯¹"""
        volatile_pairs = []
        for i in self.currencies:
            for j in self.currencies:
                if i != j and distances[i][j] != math.inf:
                    volatility = abs(distances[i][j] + distances[j][i])
                    if volatility > 0.1:  # é˜ˆå€¼
                        volatile_pairs.append((i, j, volatility))

        return sorted(volatile_pairs, key=lambda x: x[2], reverse=True)[:5]

    def _calculate_conversion_efficiency(self, distances):
        """è®¡ç®—å…‘æ¢æ•ˆç‡"""
        total_pairs = 0
        efficient_pairs = 0

        for i in self.currencies:
            for j in self.currencies:
                if i != j and distances[i][j] != math.inf:
                    total_pairs += 1
                    # å¦‚æœå…‘æ¢ç‡åˆç†ï¼ˆæŸå¤±å°äº1%ï¼‰
                    if distances[i][j] < 0.01:
                        efficient_pairs += 1

        return efficient_pairs / total_pairs if total_pairs > 0 else 0
```

<ExerciseBlock
  title="ç®—æ³•é€‰æ‹©"
  question:"åœ¨ä¸€ä¸ªéœ€è¦è®¡ç®—æ‰€æœ‰åŸå¸‚é—´æœ€çŸ­è·¯å¾„çš„èˆªç©ºç½‘ç»œä¸­ï¼Œåº”è¯¥ä½¿ç”¨ä»€ä¹ˆç®—æ³•ï¼Ÿ"
  type="multiple-choice"
  difficulty="easy"
  options={[
    {
      id: "a",
      text: "Dijkstraç®—æ³•",
      correct: false,
      explanation: "Dijkstraåªèƒ½è®¡ç®—å•æºæœ€çŸ­è·¯å¾„"
    },
    {
      id: "b",
      text: "Bellman-Fordç®—æ³•",
      correct: false,
      explanation: "Bellman-Fordä¹Ÿæ˜¯å•æºç®—æ³•"
    },
    {
      id: "c",
      text: "Floyd-Warshallç®—æ³•",
      correct: true,
      explanation: "æ­£ç¡®ï¼Floyd-Warshallä¸“é—¨è§£å†³æ‰€æœ‰é¡¶ç‚¹å¯¹æœ€çŸ­è·¯å¾„é—®é¢˜"
    },
    {
      id: "d",
      text: "A*ç®—æ³•",
      correct: false,
      explanation: "A*é€‚ç”¨äºå•ç›®æ ‡æœç´¢"
    }
  ]}
  hint="è€ƒè™‘éœ€è¦è®¡ç®—çš„è·¯å¾„æ•°é‡"
/>
```

## ğŸ“Š æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### ç®—æ³•æ€§èƒ½å¯¹æ¯”

```python
def shortest_path_performance_comparison():
    """
    æœ€çŸ­è·¯å¾„ç®—æ³•æ€§èƒ½å¯¹æ¯”
    """
    comparison = {
        "Dijkstra": {
            "time_complexity": "O((V+E)log V)",
            "space_complexity": "O(V)",
            "best_for": "éè´Ÿæƒé‡ï¼Œç¨€ç–å›¾",
            "limitations": "ä¸èƒ½å¤„ç†è´Ÿæƒé‡"
        },
        "Bellman-Ford": {
            "time_complexity": "O(VE)",
            "space_complexity": "O(V)",
            "best_for": "è´Ÿæƒé‡ï¼Œæ£€æµ‹è´Ÿç¯",
            "limitations": "è¾ƒæ…¢ï¼Œä¸é€‚åˆå¤§è§„æ¨¡å›¾"
        },
        "Floyd-Warshall": {
            "time_complexity": "O(VÂ³)",
            "space_complexity": "O(VÂ²)",
            "best_for": "æ‰€æœ‰é¡¶ç‚¹å¯¹ï¼Œç¨ å¯†å›¾",
            "limitations": "ç©ºé—´æ¶ˆè€—å¤§"
        },
        "SPFA": {
            "time_complexity": "å¹³å‡O(E)ï¼Œæœ€åO(VE)",
            "space_complexity": "O(V)",
            "best_for": "è´Ÿæƒé‡ï¼Œå¹³å‡æ€§èƒ½å¥½",
            "limitations": "æœ€åæƒ…å†µå¾ˆæ…¢"
        }
    }

    return comparison

# æ€§èƒ½æµ‹è¯•æ•°æ®ç¤ºä¾‹
performance_data = [
    {"n": 100, "time": 0.01, "algorithm": "Dijkstra"},
    {"n": 1000, "time": 0.15, "algorithm": "Dijkstra"},
    {"n": 10000, "time": 2.3, "algorithm": "Dijkstra"},
    {"n": 100000, "time": 35.6, "algorithm": "Dijkstra"}
]
```

<ComplexityAnalyzer
  title="Dijkstraç®—æ³•æ€§èƒ½åˆ†æ"
  algorithm="Dijkstraæœ€çŸ­è·¯å¾„"
  theoreticalComplexity="O((V+E)log V)"
  data={performance_data}
  color="rgb(239, 68, 68)"
/>

### å®é™…ä¼˜åŒ–æŠ€å·§

```python
class ShortestPathOptimizations:
    """
    æœ€çŸ­è·¯å¾„ç®—æ³•ä¼˜åŒ–æŠ€å·§
    """
    def __init__(self, graph):
        self.graph = graph

    def dijkstra_with_goal_direction(self, source, target):
        """å¸¦ç›®æ ‡å¯¼å‘çš„Dijkstraç®—æ³•"""
        distances = {source: 0}
        predecessors = {}
        priority_queue = [(0, source)]

        while priority_queue:
            current_distance, current = heapq.heappop(priority_queue)

            if current == target:
                break

            if current_distance > distances.get(current, math.inf):
                continue

            # ä¼˜å…ˆæ¢ç´¢æœå‘ç›®æ ‡çš„è¾¹
            neighbors = self.graph.get_neighbors(current)
            neighbors.sort(key=lambda x: self._heuristic_distance(x[0], target))

            for neighbor, weight in neighbors:
                new_distance = current_distance + weight

                if new_distance < distances.get(neighbor, math.inf):
                    distances[neighbor] = new_distance
                    predecessors[neighbor] = current
                    heapq.heappush(priority_queue, (new_distance, neighbor))

        return distances, predecessors

    def _heuristic_distance(self, node1, node2):
        """å¯å‘å¼è·ç¦»ä¼°è®¡"""
        # å®é™…åº”ç”¨ä¸­å¯ä»¥æ ¹æ®å…·ä½“é—®é¢˜å®šä¹‰
        return abs(node1 - node2)

    def multi_source_dijkstra(self, sources):
        """å¤šæºDijkstraç®—æ³•"""
        import heapq

        distances = {source: 0 for source in sources}
        predecessors = {}
        priority_queue = [(0, source) for source in sources]

        while priority_queue:
            current_distance, current = heapq.heappop(priority_queue)

            if current_distance > distances.get(current, math.inf):
                continue

            for neighbor, weight in self.graph.get_neighbors(current):
                new_distance = current_distance + weight

                if new_distance < distances.get(neighbor, math.inf):
                    distances[neighbor] = new_distance
                    predecessors[neighbor] = current
                    heapq.heappush(priority_queue, (new_distance, neighbor))

        return distances, predecessors

    def incremental_shortest_path(self, source, dynamic_edges):
        """
        å¢é‡æœ€çŸ­è·¯å¾„ç®—æ³•
        é€‚ç”¨äºè¾¹æƒé‡åŠ¨æ€å˜åŒ–çš„æƒ…å†µ
        """
        distances = {source: 0}
        predecessors = {}
        affected_vertices = set([source])

        while affected_vertices:
            current = affected_vertices.pop()
            current_distance = distances[current]

            for neighbor, weight in self.graph.get_neighbors(current):
                # æ£€æŸ¥æ˜¯å¦æ˜¯åŠ¨æ€è¾¹
                if (current, neighbor) in dynamic_edges:
                    current_weight = dynamic_edges[(current, neighbor)]
                else:
                    current_weight = weight

                new_distance = current_distance + current_weight

                if new_distance < distances.get(neighbor, math.inf):
                    distances[neighbor] = new_distance
                    predecessors[neighbor] = current
                    affected_vertices.add(neighbor)

        return distances, predecessors

    def parallel_dijkstra(self, source):
        """
        å¹¶è¡ŒDijkstraç®—æ³•
        é€‚ç”¨äºå¤šæ ¸å¤„ç†å™¨
        """
        # æ¦‚å¿µæ€§å®ç°
        from concurrent.futures import ThreadPoolExecutor

        distances = {source: 0}
        predecessors = {}

        def process_vertex(vertex):
            """å¤„ç†å•ä¸ªé¡¶ç‚¹çš„é‚»å±…"""
            updates = []
            for neighbor, weight in self.graph.get_neighbors(vertex):
                new_distance = distances[vertex] + weight
                if new_distance < distances.get(neighbor, math.inf):
                    updates.append((neighbor, new_distance, vertex))
            return updates

        current_level = {source}
        while current_level:
            # å¹¶è¡Œå¤„ç†å½“å‰å±‚çš„æ‰€æœ‰é¡¶ç‚¹
            with ThreadPoolExecutor() as executor:
                futures = [executor.submit(process_vertex, vertex) for vertex in current_level]
                all_updates = []

                for future in futures:
                    all_updates.extend(future.result())

            # åº”ç”¨æ›´æ–°
            next_level = set()
            for neighbor, new_distance, predecessor in all_updates:
                if new_distance < distances.get(neighbor, math.inf):
                    distances[neighbor] = new_distance
                    predecessors[neighbor] = predecessor
                    next_level.add(neighbor)

            current_level = next_level

        return distances, predecessors
```

<ExerciseBlock
  title="æ€§èƒ½ä¼˜åŒ–"
  question:"åœ¨åŒ…å«10ä¸‡ä¸ªé¡¶ç‚¹å’Œ100ä¸‡æ¡è¾¹çš„ç¤¾äº¤ç½‘ç»œä¸­ï¼Œè¦æ‰¾åˆ°ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œå“ªç§ä¼˜åŒ–ç­–ç•¥æœ€æœ‰æ•ˆï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "ä½¿ç”¨æ ‡å‡†Dijkstraç®—æ³•",
      correct: false,
      explanation: "å¯¹å¤§è§„æ¨¡å›¾æ•ˆç‡å¤ªä½"
    },
    {
      id: "b",
      text: "ä½¿ç”¨åŒå‘Dijkstraæœç´¢",
      correct: true,
      explanation: "æ­£ç¡®ï¼åŒå‘æœç´¢å¯ä»¥å¤§å¹…å‡å°‘æœç´¢ç©ºé—´"
    },
    {
      id: "c",
      text: "ä½¿ç”¨Floyd-Warshallç®—æ³•",
      correct: false,
      explanation: "ç©ºé—´å¤æ‚åº¦å¤ªé«˜ï¼Œä¸é€‚åˆå¤§è§„æ¨¡å›¾"
    },
    {
      id: "d",
      text: "ä½¿ç”¨Bellman-Fordç®—æ³•",
      correct: false,
      explanation: "æ—¶é—´å¤æ‚åº¦å¤ªé«˜"
    }
  ]}
  hint="è€ƒè™‘æœç´¢ç©ºé—´çš„å‡å°‘å’Œå†…å­˜æ•ˆç‡"
/>
```

## ğŸ“ æ€»ç»“ä¸æœ€ä½³å®è·µ

### å…³é”®è¦ç‚¹

1. **ç®—æ³•é€‰æ‹©æŒ‡å—**ï¼š
   - éè´Ÿæƒé‡ï¼šDijkstraï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
   - è´Ÿæƒé‡æ£€æµ‹ï¼šBellman-Ford
   - æ‰€æœ‰é¡¶ç‚¹å¯¹ï¼šFloyd-Warshall
   - åŠ¨æ€å›¾ï¼šå¢é‡ç®—æ³•

2. **ä¼˜åŒ–ç­–ç•¥**ï¼š
   - åŒå‘æœç´¢å‡å°‘æœç´¢ç©ºé—´
   - å¯å‘å¼å‡½æ•°æé«˜æ•ˆç‡
   - å¹¶è¡ŒåŒ–åˆ©ç”¨å¤šæ ¸
   - å¢é‡å¤„ç†åŠ¨æ€å˜åŒ–

3. **å®é™…åº”ç”¨è€ƒè™‘**ï¼š
   - å†…å­˜é™åˆ¶vsè®¡ç®—æ—¶é—´
   - å®æ—¶æ€§è¦æ±‚
   - æ•°æ®è§„æ¨¡ç‰¹å¾
   - è´Ÿæƒé‡å¤„ç†

### å®é™…åº”ç”¨å»ºè®®

```python
def shortest_path_algorithm_recommendation(graph_characteristics):
    """
    æ ¹æ®å›¾ç‰¹å¾æ¨èæœ€çŸ­è·¯å¾„ç®—æ³•
    """
    recommendations = {}

    if graph_characteristics["has_negative_weights"]:
        if graph_characteristics["detect_cycles"]:
            recommendations["algorithm"] = "Bellman-Ford"
            recommendations["reason"] = "éœ€è¦æ£€æµ‹è´Ÿæƒé‡ç¯"
        else:
            recommendations["algorithm"] = "SPFA"
            recommendations["reason"] = "è´Ÿæƒé‡ï¼Œå¹³å‡æ€§èƒ½å¥½"
    else:
        if graph_characteristics["num_vertices"] < 1000:
            recommendations["algorithm"] = "Floyd-Warshall"
            recommendations["reason"] = "å°è§„æ¨¡å›¾ï¼Œéœ€è¦æ‰€æœ‰é¡¶ç‚¹å¯¹"
        elif graph_characteristics["single_source"]:
            if graph_characteristics["real_time"]:
                recommendations["algorithm"] = "åŒå‘Dijkstra"
                recommendations["reason"] = "å®æ—¶æ€§è¦æ±‚é«˜"
            else:
                recommendations["algorithm"] = "Dijkstra with priority queue"
                recommendations["reason"] = "æ ‡å‡†å•æºæœ€çŸ­è·¯å¾„"
        else:
            recommendations["algorithm"] = "å¤šæ¬¡è¿è¡ŒDijkstra"
            recommendations["reason"] = "å¤šæºä½†ä¸éœ€è¦æ‰€æœ‰é¡¶ç‚¹å¯¹"

    return recommendations
```

### é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µ

```python
class ShortestPathErrorHandling:
    """æœ€çŸ­è·¯å¾„ç®—æ³•çš„é”™è¯¯å¤„ç†"""
    def __init__(self, graph):
        self.graph = graph

    def validate_graph(self):
        """éªŒè¯å›¾çš„æœ‰æ•ˆæ€§"""
        errors = []

        # æ£€æŸ¥é¡¶ç‚¹ç¼–å·
        for vertex in range(self.graph.num_vertices):
            neighbors = self.graph.get_neighbors(vertex)
            for neighbor, _ in neighbors:
                if neighbor < 0 or neighbor >= self.graph.num_vertices:
                    errors.append(f"æ— æ•ˆçš„é‚»å±…é¡¶ç‚¹: {neighbor}")

        return errors

    def handle_negative_weights(self, algorithm):
        """å¤„ç†è´Ÿæƒé‡"""
        if algorithm == "dijkstra":
            # æ£€æŸ¥æ˜¯å¦æœ‰è´Ÿæƒé‡
            has_negative = False
            for vertex in range(self.graph.num_vertices):
                for neighbor, weight in self.graph.get_neighbors(vertex):
                    if weight < 0:
                        has_negative = True
                        break

            if has_negative:
                raise ValueError("Dijkstraç®—æ³•ä¸èƒ½å¤„ç†è´Ÿæƒé‡")

        return True

    def handle_disconnected_graph(self, source, target):
        """å¤„ç†ä¸è¿é€šå›¾"""
        # å…ˆæ£€æŸ¥è¿é€šæ€§
        bfs = BFSTraversal(self.graph)
        connected = bfs.bfs_shortest_path(source, target)

        if not connected:
            return {"error": "æºç‚¹å’Œç›®æ ‡ç‚¹ä¸è¿é€š"}

        return None

    def memory_efficient_floyd_warshall(self):
        """å†…å­˜é«˜æ•ˆçš„Floyd-Warshallå®ç°"""
        num_vertices = self.graph.num_vertices

        # åˆ†å—å¤„ç†ï¼Œé¿å…ä¸€æ¬¡æ€§å­˜å‚¨æ•´ä¸ªçŸ©é˜µ
        block_size = 1000  # æ ¹æ®å¯ç”¨å†…å­˜è°ƒæ•´
        dist = [[math.inf] * num_vertices for _ in range(min(block_size, num_vertices))]

        for start_block in range(0, num_vertices, block_size):
            end_block = min(start_block + block_size, num_vertices)

            # åˆå§‹åŒ–å½“å‰å—
            for i in range(start_block, end_block):
                for j in range(num_vertices):
                    if i == j:
                        dist[i - start_block][j] = 0
                    else:
                        dist[i - start_block][j] = math.inf

            # å¡«å……åˆå§‹è·ç¦»
            for i in range(start_block, end_block):
                for j, weight in self.graph.get_neighbors(i):
                    dist[i - start_block][j] = weight

            # å¤„ç†å½“å‰å—
            for k in range(num_vertices):
                for i in range(start_block, end_block):
                    for j in range(num_vertices):
                        if dist[i - start_block][k] + self._get_distance(k, j) < dist[i - start_block][j]:
                            dist[i - start_block][j] = dist[i - start_block][k] + self._get_distance(k, j)

        return dist

    def _get_distance(self, i, j):
        """è·å–ä¸¤ä¸ªé¡¶ç‚¹é—´çš„è·ç¦»"""
        if i == j:
            return 0
        for neighbor, weight in self.graph.get_neighbors(i):
            if neighbor == j:
                return weight
        return math.inf
```

<ExerciseBlock
  title="ç« èŠ‚æµ‹éªŒ"
  question:"åœ¨åŒ…å«è´Ÿæƒé‡ä½†æ— è´Ÿç¯çš„å›¾ä¸­ï¼Œå“ªç§ç®—æ³•æœ€é€‚åˆæ‰¾å•æºæœ€çŸ­è·¯å¾„ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "Dijkstraç®—æ³•",
      correct: false,
      explanation: "Dijkstraä¸èƒ½å¤„ç†è´Ÿæƒé‡"
    },
    {
      id: "b",
      text: "Bellman-Fordç®—æ³•",
      correct: true,
      explanation: "æ­£ç¡®ï¼Bellman-Fordå¯ä»¥å¤„ç†è´Ÿæƒé‡ï¼ˆæ— è´Ÿç¯ï¼‰"
    },
    {
      id: "c",
      text: "Floyd-Warshallç®—æ³•",
      correct: false,
      explanation: "Floyd-Warshallç”¨äºæ‰€æœ‰é¡¶ç‚¹å¯¹ï¼Œè¿‡äºé‡é‡çº§"
    },
    {
      id: "d",
      text: "BFSç®—æ³•",
      correct: false,
      explanation: "BFSåªé€‚ç”¨äºæ— æƒå›¾"
    }
  ]}
  hint="è€ƒè™‘ç®—æ³•å¯¹è´Ÿæƒé‡çš„å¤„ç†èƒ½åŠ›"
/>
```

---

## ğŸš€ è¯¾åç»ƒä¹ 

1. **åŸºç¡€ç»ƒä¹ **ï¼šå®ç°Dijkstraã€Bellman-Fordã€Floyd-Warshallç®—æ³•
2. **è¿›é˜¶ç»ƒä¹ **ï¼šå®ç°åŒå‘æœç´¢å’ŒSPFAä¼˜åŒ–ç®—æ³•
3. **å®æˆ˜ç»ƒä¹ **ï¼šæ„å»ºGPSå¯¼èˆªç³»ç»Ÿæˆ–ç½‘ç»œè·¯ç”±æ¨¡æ‹Ÿå™¨
4. **é¡¹ç›®ç»ƒä¹ **ï¼šè®¾è®¡é‡‘èå¥—åˆ©æ£€æµ‹ç³»ç»Ÿ

**è®°ä½**ï¼šæœ€çŸ­è·¯å¾„ç®—æ³•æ˜¯å›¾è®ºä¸­çš„æ ¸å¿ƒé—®é¢˜ï¼Œåœ¨ç°å®ä¸–ç•Œæœ‰å¹¿æ³›åº”ç”¨ï¼ğŸ›£ï¸