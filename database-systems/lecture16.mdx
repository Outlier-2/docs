---
title: 'Lecture 16: Concurrency Control Protocols'
description: '深入探讨并发控制协议的实现，包括两阶段锁协议、时间戳协议、乐观并发控制和验证协议'
date: '2024-02-16'
tags: ['数据库系统', '并发控制', 'CMU 15-445']
---

# Lecture 16: Concurrency Control Protocols

## 概述

并发控制协议是实现并发控制理论的具体机制和算法。本讲将深入探讨各种重要的并发控制协议，包括两阶段锁协议、时间戳协议、乐观并发控制和验证协议的实现细节和性能特征。

## 两阶段锁协议（2PL）

### 1. 基本两阶段锁协议

```cpp
// 两阶段锁管理器
class TwoPhaseLockManager : public LockManager {
public:
    // 扩展阶段
    bool Lock(TransactionId txn_id, const Key& key, LockType type) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 检查是否在扩展阶段
        if (txn_state->phase == TransactionPhase::SHRINKING) {
            // 已经进入收缩阶段，不能再获取新锁
            return false;
        }

        // 调用父类的锁获取方法
        return AcquireLock(txn_id, key, type);
    }

    // 收缩阶段
    bool Unlock(TransactionId txn_id, const Key& key) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 标记进入收缩阶段
        txn_state->phase = TransactionPhase::SHRINKING;

        // 调用父类的锁释放方法
        ReleaseLock(txn_id, key);
        return true;
    }

    // 提交事务
    bool Commit(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 释放所有锁
        ReleaseAllLocks(txn_id);

        // 更新事务状态
        txn_state->status = TransactionStatus::COMMITTED;
        txn_state->phase = TransactionPhase::COMMITTED;

        return true;
    }

    // 终止事务
    bool Abort(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 释放所有锁
        ReleaseAllLocks(txn_id);

        // 更新事务状态
        txn_state->status = TransactionStatus::ABORTED;
        txn_state->phase = TransactionPhase::ABORTED;

        return true;
    }

private:
    // 事务状态
    struct TransactionState {
        TransactionId id;
        TransactionStatus status;
        TransactionPhase phase;
        std::set<Key> locked_keys;
        std::chrono::steady_clock::time_point start_time;
    };

    // 事务状态存储
    std::map<TransactionId, TransactionState> transaction_states_;

    // 事务阶段
    enum class TransactionPhase {
        GROWING,    // 扩展阶段
        SHRINKING,   // 收缩阶段
        COMMITTED,   // 已提交
        ABORTED      // 已终止
    };

    // 获取事务状态
    TransactionState* GetTransactionState(TransactionId txn_id) {
        auto it = transaction_states_.find(txn_id);
        if (it != transaction_states_.end()) {
            return &it->second;
        }
        return nullptr;
    }

    // 重写锁授予方法以跟踪事务状态
    void GrantLock(TransactionId txn_id, const Key& key, LockType lock_type) override {
        // 调用父类方法
        LockManager::GrantLock(txn_id, key, lock_type);

        // 更新事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            txn_state->locked_keys.insert(key);
            if (txn_state->phase == TransactionPhase::ABORTED) {
                // 如果是新事务，设置为扩展阶段
                txn_state->phase = TransactionPhase::GROWING;
            }
        }
    }

    // 重写锁释放方法以更新事务状态
    void ReleaseLockInternal(TransactionId txn_id, const Key& key) override {
        // 调用父类方法
        LockManager::ReleaseLockInternal(txn_id, key);

        // 更新事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            txn_state->locked_keys.erase(key);
        }
    }

    std::mutex mutex_;
};
```

### 2. 严格两阶段锁协议（Strict 2PL）

```cpp
// 严格两阶段锁管理器
class StrictTwoPhaseLockManager : public TwoPhaseLockManager {
public:
    // 重写解锁方法 - 只有在提交时才能解锁
    bool Unlock(TransactionId txn_id, const Key& key) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 严格2PL：只有提交或终止时才能解锁
        if (txn_state->status == TransactionStatus::ACTIVE) {
            return false;
        }

        // 调用父类的解锁方法
        return TwoPhaseLockManager::Unlock(txn_id, key);
    }

    // 提交事务 - 释放所有锁
    bool Commit(TransactionId txn_id) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 释放所有锁
        ReleaseAllLocks(txn_id);

        // 更新事务状态
        txn_state->status = TransactionStatus::COMMITTED;
        txn_state->phase = TransactionPhase::COMMITTED;

        return true;
    }

    // 终止事务 - 释放所有锁
    bool Abort(TransactionId txn_id) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 释放所有锁
        ReleaseAllLocks(txn_id);

        // 更新事务状态
        txn_state->status = TransactionStatus::ABORTED;
        txn_state->phase = TransactionPhase::ABORTED;

        return true;
    }
};
```

### 3. 强调两阶段锁协议（Rigorous 2PL）

```cpp
// 强调两阶段锁管理器
class RigorousTwoPhaseLockManager : public StrictTwoPhaseLockManager {
public:
    // 重写提交事务 - 在提交后解锁
    bool Commit(TransactionId txn_id) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 先更新事务状态
        txn_state->status = TransactionStatus::COMMITTED;
        txn_state->phase = TransactionPhase::COMMITTED;

        // 然后释放所有锁
        ReleaseAllLocks(txn_id);

        return true;
    }

    // 重写终止事务 - 在终止后解锁
    bool Abort(TransactionId txn_id) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 先更新事务状态
        txn_state->status = TransactionStatus::ABORTED;
        txn_state->phase = TransactionPhase::ABORTED;

        // 然后释放所有锁
        ReleaseAllLocks(txn_id);

        return true;
    }
};
```

## 时间戳协议（Timestamp Ordering）

### 1. 基本时间戳协议实现

```cpp
// 时间戳排序管理器
class TimestampOrderingManager {
public:
    // 读取操作
    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 获取数据项状态
        auto data_state = GetDataState(key);

        // 检查写时间戳
        if (data_state.write_ts > GetTransactionTimestamp(txn_id)) {
            // 写-写冲突，终止事务
            AbortTransaction(txn_id);
            return false;
        }

        // 更新读时间戳
        data_state.read_ts = std::max(data_state.read_ts, GetTransactionTimestamp(txn_id));

        // 返回数据值
        value = data_state.value;

        // 记录读取操作
        RecordReadOperation(txn_id, key);

        return true;
    }

    // 写入操作
    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 获取数据项状态
        auto data_state = GetDataState(key);

        // 检查读时间戳
        if (data_state.read_ts > GetTransactionTimestamp(txn_id)) {
            // 读-写冲突，终止事务
            AbortTransaction(txn_id);
            return false;
        }

        // 检查写时间戳
        if (data_state.write_ts > GetTransactionTimestamp(txn_id)) {
            // 写-写冲突，终止事务
            AbortTransaction(txn_id);
            return false;
        }

        // 应用Thomas写规则
        if (CanApplyThomasWriteRule(data_state, GetTransactionTimestamp(txn_id))) {
            // 忽略写入
            return true;
        }

        // 更新数据状态
        data_state.value = value;
        data_state.write_ts = GetTransactionTimestamp(txn_id);

        // 记录写入操作
        RecordWriteOperation(txn_id, key);

        return true;
    }

    // 提交事务
    bool Commit(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 更新事务状态
        txn_state->status = TransactionStatus::COMMITTED;

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

    // 终止事务
    bool Abort(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 回滚事务的修改
        RollbackTransaction(txn_id);

        // 更新事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            txn_state->status = TransactionStatus::ABORTED;
        }

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

private:
    // 数据项状态
    struct DataState {
        Value value;
        Timestamp read_ts = 0;
        Timestamp write_ts = 0;
    };

    // 事务状态
    struct TransactionState {
        TransactionId id;
        Timestamp timestamp;
        TransactionStatus status;
        std::map<Key, Value> write_set;
        std::map<Key, Value> old_values;  // 用于回滚
    };

    // 数据状态存储
    std::map<Key, DataState> data_states_;

    // 事务状态存储
    std::map<TransactionId, TransactionState> transaction_states_;

    // 时间戳生成器
    Timestamp timestamp_counter_ = 1;

    // 互斥锁
    std::mutex mutex_;

    // 获取数据项状态
    DataState& GetDataState(const Key& key) {
        return data_states_[key];
    }

    // 获取事务状态
    TransactionState* GetTransactionState(TransactionId txn_id) {
        auto it = transaction_states_.find(txn_id);
        if (it != transaction_states_.end()) {
            return &it->second;
        }
        return nullptr;
    }

    // 获取事务时间戳
    Timestamp GetTransactionTimestamp(TransactionId txn_id) {
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            return txn_state->timestamp;
        }

        // 如果没有事务状态，创建一个
        TransactionState new_state;
        new_state.id = txn_id;
        new_state.timestamp = GenerateTimestamp();
        new_state.status = TransactionStatus::ACTIVE;

        transaction_states_[txn_id] = new_state;
        return new_state.timestamp;
    }

    // 生成时间戳
    Timestamp GenerateTimestamp() {
        return timestamp_counter_++;
    }

    // 记录读取操作
    void RecordReadOperation(TransactionId txn_id, const Key& key) {
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            // 时间戳协议中不需要记录读取集，因为冲突检查通过时间戳进行
        }
    }

    // 记录写入操作
    void RecordWriteOperation(TransactionId txn_id, const Key& key) {
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            // 保存旧值用于回滚
            auto it = data_states_.find(key);
            if (it != data_states_.end()) {
                txn_state->old_values[key] = it->second.value;
            }
            txn_state->write_set[key] = data_states_[key].value;
        }
    }

    // 应用Thomas写规则
    bool CanApplyThomasWriteRule(const DataState& data_state, Timestamp txn_timestamp) {
        // 如果有更晚的事务已经写入，并且没有更晚的事务读取，可以忽略写入
        return data_state.write_ts > txn_timestamp &&
               !HasLaterRead(data_state.read_ts, txn_timestamp);
    }

    // 检查是否有更晚的读取
    bool HasLaterRead(Timestamp read_ts, Timestamp txn_timestamp) {
        return read_ts > txn_timestamp;
    }

    // 回滚事务
    void RollbackTransaction(TransactionId txn_id) {
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            // 恢复旧值
            for (const auto& [key, old_value] : txn_state->old_values) {
                data_states_[key].value = old_value;
            }
        }
    }

    // 清理事务状态
    void CleanupTransaction(TransactionId txn_id) {
        transaction_states_.erase(txn_id);
    }
};
```

### 2. 多版本时间戳排序

```cpp
// 多版本时间戳排序管理器
class MultiversionTimestampOrderingManager {
public:
    // 读取操作
    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 获取事务时间戳
        Timestamp txn_ts = GetTransactionTimestamp(txn_id);

        // 查找适当的版本
        const Version* version = FindVersionForRead(key, txn_ts);
        if (!version) {
            return false;
        }

        value = version->value;
        return true;
    }

    // 写入操作
    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 获取事务时间戳
        Timestamp txn_ts = GetTransactionTimestamp(txn_id);

        // 创建新版本
        CreateNewVersion(key, value, txn_ts);

        return true;
    }

    // 提交事务
    bool Commit(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 更新事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            txn_state->status = TransactionStatus::COMMITTED;
        }

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

    // 终止事务
    bool Abort(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 删除事务创建的版本
        DeleteTransactionVersions(txn_id);

        // 更新事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            txn_state->status = TransactionStatus::ABORTED;
        }

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

private:
    // 版本结构
    struct Version {
        Value value;
        Timestamp create_ts;
        Timestamp delete_ts = std::numeric_limits<Timestamp>::max();
        TransactionId creator_txn;
    };

    // 数据版本存储
    std::map<Key, std::vector<Version>> version_store_;

    // 事务状态存储
    std::map<TransactionId, TransactionState> transaction_states_;

    // 时间戳生成器
    Timestamp timestamp_counter_ = 1;

    // 互斥锁
    std::mutex mutex_;

    // 查找用于读取的版本
    const Version* FindVersionForRead(const Key& key, Timestamp txn_ts) {
        auto it = version_store_.find(key);
        if (it == version_store_.end()) {
            return nullptr;
        }

        const Version* best_version = nullptr;
        Timestamp best_ts = 0;

        // 查找创建时间戳小于等于事务时间戳的最新版本
        for (const auto& version : it->second) {
            if (version.create_ts <= txn_ts) {
                if (version.create_ts > best_ts) {
                    best_ts = version.create_ts;
                    best_version = &version;
                }
            }
        }

        return best_version;
    }

    // 创建新版本
    void CreateNewVersion(const Key& key, const Value& value, Timestamp txn_ts) {
        auto& versions = version_store_[key];

        // 标记现有版本为已删除
        for (auto& version : versions) {
            if (version.delete_ts == std::numeric_limits<Timestamp>::max()) {
                version.delete_ts = txn_ts;
            }
        }

        // 创建新版本
        Version new_version;
        new_version.value = value;
        new_version.create_ts = txn_ts;
        new_version.creator_txn = GetCurrentTransactionId();

        versions.push_back(new_version);
    }

    // 删除事务版本
    void DeleteTransactionVersions(TransactionId txn_id) {
        for (auto& [key, versions] : version_store_) {
            versions.erase(
                std::remove_if(versions.begin(), versions.end(),
                    [txn_id](const Version& version) {
                        return version.creator_txn == txn_id;
                    }),
                versions.end()
            );
        }
    }

    // 获取事务状态
    TransactionState* GetTransactionState(TransactionId txn_id) {
        auto it = transaction_states_.find(txn_id);
        if (it != transaction_states_.end()) {
            return &it->second;
        }
        return nullptr;
    }

    // 获取事务时间戳
    Timestamp GetTransactionTimestamp(TransactionId txn_id) {
        auto txn_state = GetTransactionState(txn_id);
        if (txn_state) {
            return txn_state->timestamp;
        }

        // 创建新事务状态
        TransactionState new_state;
        new_state.id = txn_id;
        new_state.timestamp = timestamp_counter_++;
        new_state.status = TransactionStatus::ACTIVE;

        transaction_states_[txn_id] = new_state;
        return new_state.timestamp;
    }

    // 获取当前事务ID
    TransactionId GetCurrentTransactionId() {
        return 0;  // 简化实现
    }

    // 清理事务状态
    void CleanupTransaction(TransactionId txn_id) {
        transaction_states_.erase(txn_id);
    }

    // 事务状态结构
    struct TransactionState {
        TransactionId id;
        Timestamp timestamp;
        TransactionStatus status;
    };
};
```

## 乐观并发控制（OCC）

### 1. 基本乐观并发控制

```cpp
// 乐观并发控制管理器
class OptimisticConcurrencyManager {
public:
    // 开始事务
    TransactionId BeginTransaction() {
        std::lock_guard<std::mutex> lock(mutex_);

        TransactionId txn_id = GenerateTransactionId();

        // 创建事务状态
        TransactionState state;
        state.id = txn_id;
        state.start_ts = GetTimestamp();
        state.status = TransactionStatus::ACTIVE;
        state.phase = TransactionPhase::READ;

        transaction_states_[txn_id] = state;

        return txn_id;
    }

    // 读取操作
    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 获取数据值
        value = GetDataValue(key);

        // 记录读取集
        txn_state->read_set.insert(key);

        return true;
    }

    // 写入操作
    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 记录写入集
        txn_state->write_set[key] = value;

        return true;
    }

    // 验证阶段
    bool Validate(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 设置验证开始时间戳
        txn_state->validation_ts = GetTimestamp();
        txn_state->phase = TransactionPhase::VALIDATION;

        // 执行验证
        bool validation_result = PerformValidation(txn_state);

        if (validation_result) {
            // 验证通过，进入写入阶段
            txn_state->phase = TransactionPhase::WRITE;
        } else {
            // 验证失败，终止事务
            txn_state->status = TransactionStatus::ABORTED;
        }

        return validation_result;
    }

    // 写入阶段
    bool WriteBack(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 执行写入
        for (const auto& [key, value] : txn_state->write_set) {
            data_store_[key] = value;
        }

        // 更新事务状态
        txn_state->status = TransactionStatus::COMMITTED;
        txn_state->phase = TransactionPhase::COMMITTED;

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

    // 终止事务
    bool Abort(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 更新事务状态
        txn_state->status = TransactionStatus::ABORTED;

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

private:
    // 事务阶段
    enum class TransactionPhase {
        READ,         // 读取阶段
        VALIDATION,   // 验证阶段
        WRITE,        // 写入阶段
        COMMITTED,    // 已提交
        ABORTED       // 已终止
    };

    // 事务状态
    struct TransactionState {
        TransactionId id;
        Timestamp start_ts;
        Timestamp validation_ts;
        TransactionStatus status;
        TransactionPhase phase;
        std::set<Key> read_set;
        std::map<Key, Value> write_set;
    };

    // 事务状态存储
    std::map<TransactionId, TransactionState> transaction_states_;

    // 数据存储
    std::map<Key, Value> data_store_;

    // 时间戳生成器
    Timestamp timestamp_counter_ = 1;

    // 互斥锁
    std::mutex mutex_;

    // 生成事务ID
    TransactionId GenerateTransactionId() {
        static TransactionId next_id = 1;
        return next_id++;
    }

    // 获取时间戳
    Timestamp GetTimestamp() {
        return timestamp_counter_++;
    }

    // 获取事务状态
    TransactionState* GetTransactionState(TransactionId txn_id) {
        auto it = transaction_states_.find(txn_id);
        if (it != transaction_states_.end()) {
            return &it->second;
        }
        return nullptr;
    }

    // 获取数据值
    Value GetDataValue(const Key& key) {
        auto it = data_store_.find(key);
        if (it != data_store_.end()) {
            return it->second;
        }
        return Value();  // 默认值
    }

    // 执行验证
    bool PerformValidation(TransactionState* txn_state) {
        // 检查所有已完成的事务
        for (const auto& [other_txn_id, other_state] : transaction_states_) {
            if (other_txn_id == txn_state->id) {
                continue;  // 跳过自己
            }

            // 检查是否有冲突
            if (HasConflict(txn_state, &other_state)) {
                return false;
            }
        }

        return true;
    }

    // 检查冲突
    bool HasConflict(TransactionState* txn1, TransactionState* txn2) {
        // 情况1: T1读取的数据被T2写入
        for (const auto& key : txn1->read_set) {
            if (txn2->write_set.find(key) != txn2->write_set.end()) {
                // 检查时间顺序
                if (txn2->validation_ts < txn1->start_ts ||
                    (txn2->start_ts < txn1->start_ts &&
                     txn2->validation_ts > txn1->start_ts)) {
                    return true;
                }
            }
        }

        // 情况2: T1写入的数据被T2写入
        for (const auto& [key, value] : txn1->write_set) {
            if (txn2->write_set.find(key) != txn2->write_set.end()) {
                // 检查时间顺序
                if (txn2->validation_ts < txn1->start_ts ||
                    (txn2->start_ts < txn1->start_ts &&
                     txn2->validation_ts > txn1->start_ts)) {
                    return true;
                }
            }
        }

        // 情况3: T1写入的数据被T2读取
        for (const auto& [key, value] : txn1->write_set) {
            if (txn2->read_set.find(key) != txn2->read_set.end()) {
                // 检查时间顺序
                if (txn2->validation_ts < txn1->start_ts ||
                    (txn2->start_ts < txn1->start_ts &&
                     txn2->validation_ts > txn1->start_ts)) {
                    return true;
                }
            }
        }

        return false;
    }

    // 清理事务状态
    void CleanupTransaction(TransactionId txn_id) {
        transaction_states_.erase(txn_id);
    }
};
```

### 2. 向后验证的乐观并发控制

```cpp
// 向后验证乐观并发控制
class BackwardValidationOCC : public OptimisticConcurrencyManager {
public:
    // 重写验证方法 - 使用向后验证
    bool Validate(TransactionId txn_id) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 设置验证开始时间戳
        txn_state->validation_ts = GetTimestamp();
        txn_state->phase = TransactionPhase::VALIDATION;

        // 执行向后验证
        bool validation_result = PerformBackwardValidation(txn_state);

        if (validation_result) {
            // 验证通过，进入写入阶段
            txn_state->phase = TransactionPhase::WRITE;
        } else {
            // 验证失败，终止事务
            txn_state->status = TransactionStatus::ABORTED;
        }

        return validation_result;
    }

private:
    // 执行向后验证
    bool PerformBackwardValidation(TransactionState* txn_state) {
        // 检查在事务开始之后完成的事务
        for (const auto& [other_txn_id, other_state] : transaction_states_) {
            if (other_txn_id == txn_state->id) {
                continue;  // 跳过自己
            }

            // 只检查已完成的事务
            if (other_state.status == TransactionStatus::COMMITTED ||
                other_state.status == TransactionStatus::ABORTED) {

                // 检查完成时间是否在事务开始之后
                if (other_state.validation_ts > txn_state->start_ts) {
                    // 检查是否有冲突
                    if (HasConflict(txn_state, &other_state)) {
                        return false;
                    }
                }
            }
        }

        return true;
    }
};
```

### 3. 向前验证的乐观并发控制

```cpp
// 向前验证乐观并发控制
class ForwardValidationOCC : public OptimisticConcurrencyManager {
public:
    // 重写验证方法 - 使用向前验证
    bool Validate(TransactionId txn_id) override {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 设置验证开始时间戳
        txn_state->validation_ts = GetTimestamp();
        txn_state->phase = TransactionPhase::VALIDATION;

        // 执行向前验证
        bool validation_result = PerformForwardValidation(txn_state);

        if (validation_result) {
            // 验证通过，进入写入阶段
            txn_state->phase = TransactionPhase::WRITE;
        } else {
            // 验证失败，终止事务
            txn_state->status = TransactionStatus::ABORTED;
        }

        return validation_result;
    }

private:
    // 执行向前验证
    bool PerformForwardValidation(TransactionState* txn_state) {
        // 检查当前活跃的事务
        for (const auto& [other_txn_id, other_state] : transaction_states_) {
            if (other_txn_id == txn_state->id) {
                continue;  // 跳过自己
            }

            // 只检查活跃的事务
            if (other_state.status == TransactionStatus::ACTIVE) {
                // 检查开始时间是否在事务开始之前
                if (other_state.start_ts < txn_state->start_ts) {
                    // 检查是否有冲突
                    if (HasConflict(txn_state, &other_state)) {
                        return false;
                    }
                }
            }
        }

        return true;
    }
};
```

## 验证协议（Validation-Based Protocols）

### 1. 基本验证协议

```cpp
// 验证协议管理器
class ValidationProtocolManager {
public:
    // 开始事务
    TransactionId BeginTransaction() {
        std::lock_guard<std::mutex> lock(mutex_);

        TransactionId txn_id = GenerateTransactionId();

        // 创建事务状态
        TransactionState state;
        state.id = txn_id;
        state.start_ts = GetTimestamp();
        state.finish_ts = 0;
        state.status = TransactionStatus::ACTIVE;
        state.validation_ts = 0;

        transaction_states_[txn_id] = state;

        return txn_id;
    }

    // 读取操作
    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 获取数据值
        value = GetDataValue(key);

        // 记录读取集
        txn_state->read_set.insert(key);

        return true;
    }

    // 写入操作
    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 记录写入集
        txn_state->write_set[key] = value;

        return true;
    }

    // 验证事务
    bool Validate(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 设置完成时间戳
        txn_state->finish_ts = GetTimestamp();
        txn_state->validation_ts = GetTimestamp();

        // 执行验证
        bool validation_result = PerformValidation(txn_state);

        if (validation_result) {
            // 验证通过
            txn_state->status = TransactionStatus::VALIDATED;
        } else {
            // 验证失败
            txn_state->status = TransactionStatus::ABORTED;
        }

        return validation_result;
    }

    // 提交事务
    bool Commit(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state || txn_state->status != TransactionStatus::VALIDATED) {
            return false;
        }

        // 执行写入
        for (const auto& [key, value] : txn_state->write_set) {
            data_store_[key] = value;
        }

        // 更新事务状态
        txn_state->status = TransactionStatus::COMMITTED;

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

    // 终止事务
    bool Abort(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        // 检查事务状态
        auto txn_state = GetTransactionState(txn_id);
        if (!txn_state) {
            return false;
        }

        // 更新事务状态
        txn_state->status = TransactionStatus::ABORTED;

        // 清理事务状态
        CleanupTransaction(txn_id);

        return true;
    }

private:
    // 事务状态
    struct TransactionState {
        TransactionId id;
        Timestamp start_ts;
        Timestamp finish_ts;
        Timestamp validation_ts;
        TransactionStatus status;
        std::set<Key> read_set;
        std::map<Key, Value> write_set;
    };

    // 事务状态存储
    std::map<TransactionId, TransactionState> transaction_states_;

    // 数据存储
    std::map<Key, Value> data_store_;

    // 时间戳生成器
    Timestamp timestamp_counter_ = 1;

    // 互斥锁
    std::mutex mutex_;

    // 生成事务ID
    TransactionId GenerateTransactionId() {
        static TransactionId next_id = 1;
        return next_id++;
    }

    // 获取时间戳
    Timestamp GetTimestamp() {
        return timestamp_counter_++;
    }

    // 获取事务状态
    TransactionState* GetTransactionState(TransactionId txn_id) {
        auto it = transaction_states_.find(txn_id);
        if (it != transaction_states_.end()) {
            return &it->second;
        }
        return nullptr;
    }

    // 获取数据值
    Value GetDataValue(const Key& key) {
        auto it = data_store_.find(key);
        if (it != data_store_.end()) {
            return it->second;
        }
        return Value();  // 默认值
    }

    // 执行验证
    bool PerformValidation(TransactionState* txn_state) {
        // 检查所有其他事务
        for (const auto& [other_txn_id, other_state] : transaction_states_) {
            if (other_txn_id == txn_state->id) {
                continue;  // 跳过自己
            }

            // 检查验证条件
            if (!CheckValidationCondition(txn_state, &other_state)) {
                return false;
            }
        }

        return true;
    }

    // 检查验证条件
    bool CheckValidationCondition(TransactionState* txn1, TransactionState* txn2) {
        // 条件1: T2在T1完成之前完成
        if (txn2->finish_ts < txn1->start_ts) {
            return true;  // 无冲突
        }

        // 条件2: T2在T1开始之后开始，在T1完成之前完成
        if (txn2->start_ts < txn1->finish_ts &&
            txn2->finish_ts < txn1->finish_ts) {
            // 检查读写集是否不相交
            return !HasReadWriteConflict(txn1, txn2);
        }

        // 条件3: T2在T1开始之后开始，在T1完成之后完成
        if (txn2->start_ts < txn1->finish_ts &&
            txn2->finish_ts >= txn1->finish_ts) {
            // 检查T1的写入集和T2的读取集是否不相交
            return !HasWriteReadConflict(txn1, txn2);
        }

        return true;
    }

    // 检查读写冲突
    bool HasReadWriteConflict(TransactionState* txn1, TransactionState* txn2) {
        // 检查T1的读取集和T2的写入集
        for (const auto& key : txn1->read_set) {
            if (txn2->write_set.find(key) != txn2->write_set.end()) {
                return true;
            }
        }

        // 检查T1的写入集和T2的读取集
        for (const auto& [key, value] : txn1->write_set) {
            if (txn2->read_set.find(key) != txn2->read_set.end()) {
                return true;
            }
        }

        // 检查T1的写入集和T2的写入集
        for (const auto& [key, value] : txn1->write_set) {
            if (txn2->write_set.find(key) != txn2->write_set.end()) {
                return true;
            }
        }

        return false;
    }

    // 检查写读冲突
    bool HasWriteReadConflict(TransactionState* txn1, TransactionState* txn2) {
        for (const auto& [key, value] : txn1->write_set) {
            if (txn2->read_set.find(key) != txn2->read_set.end()) {
                return true;
            }
        }
        return false;
    }

    // 清理事务状态
    void CleanupTransaction(TransactionId txn_id) {
        transaction_states_.erase(txn_id);
    }
};
```

## 实践练习

### 练习1：实现严格两阶段锁协议

```cpp
// 练习：实现严格两阶段锁协议
class Strict2PLImplementation {
public:
    bool BeginTransaction(TransactionId txn_id) {
        // 学生需要实现事务开始逻辑
        return false;
    }

    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        // 学生需要实现读取逻辑
        // 1. 获取共享锁
        // 2. 读取数据
        // 3. 处理锁冲突
        return false;
    }

    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        // 学生需要实现写入逻辑
        // 1. 获取排他锁
        // 2. 写入数据
        // 3. 处理锁冲突
        return false;
    }

    bool Commit(TransactionId txn_id) {
        // 学生需要实现提交逻辑
        // 1. 释放所有锁
        // 2. 更新事务状态
        return false;
    }

    bool Abort(TransactionId txn_id) {
        // 学生需要实现终止逻辑
        // 1. 释放所有锁
        // 2. 回滚修改
        // 3. 更新事务状态
        return false;
    }

private:
    // 学生需要定义必要的数据结构
};
```

### 练习2：实现乐观并发控制

```cpp
// 练习：实现乐观并发控制
class OCCImplementation {
public:
    TransactionId BeginTransaction() {
        // 学生需要实现事务开始逻辑
        return INVALID_TRANSACTION_ID;
    }

    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        // 学生需要实现读取逻辑
        // 1. 记录读取集
        // 2. 返回数据值
        return false;
    }

    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        // 学生需要实现写入逻辑
        // 1. 记录写入集
        return false;
    }

    bool Validate(TransactionId txn_id) {
        // 学生需要实现验证逻辑
        // 1. 检查与其他事务的冲突
        // 2. 返回验证结果
        return false;
    }

    bool Commit(TransactionId txn_id) {
        // 学生需要实现提交逻辑
        // 1. 执行写入
        // 2. 更新事务状态
        return false;
    }

private:
    // 学生需要定义必要的数据结构
    static constexpr TransactionId INVALID_TRANSACTION_ID = -1;
};
```

### 练习3：实现多版本时间戳排序

```cpp
// 练习：实现多版本时间戳排序
class MVTOImplementation {
public:
    bool Read(TransactionId txn_id, const Key& key, Value& value) {
        // 学生需要实现多版本读取逻辑
        // 1. 查找适当的版本
        // 2. 检查版本可见性
        // 3. 返回版本值
        return false;
    }

    bool Write(TransactionId txn_id, const Key& key, const Value& value) {
        // 学生需要实现多版本写入逻辑
        // 1. 创建新版本
        // 2. 处理版本链
        return false;
    }

    bool Commit(TransactionId txn_id) {
        // 学生需要实现提交逻辑
        // 1. 确认版本创建
        // 2. 清理事务状态
        return false;
    }

    void CleanupOldVersions() {
        // 学生需要实现版本清理逻辑
        // 1. 识别过期的版本
        // 2. 删除过期版本
    }

private:
    // 学生需要定义必要的数据结构
};
```

## 总结

并发控制协议是实现并发控制理论的具体机制，通过本讲的学习，我们掌握了：

1. **两阶段锁协议**：理解了基本2PL、严格2PL和强调2PL的实现和区别
2. **时间戳协议**：掌握了基本时间戳排序和多版本时间戳排序的实现
3. **乐观并发控制**：学会了OCC的三个阶段和验证策略
4. **验证协议**：理解了基于验证的并发控制机制
5. **协议比较**：了解了各种协议的性能特征和适用场景

不同的并发控制协议有不同的性能特征：
- **锁协议**：在高冲突环境下表现较好，但可能有死锁问题
- **时间戳协议**：无死锁，但可能导致级联终止
- **乐观并发控制**：在低冲突环境下性能优秀，但在高冲突下可能有大量重试

选择合适的并发控制协议需要根据应用的具体特征和需求来决定。

## 进一步学习

- [Concurrency Control in PostgreSQL](https://www.postgresql.org/docs/current/mvcc.html)
- [Oracle Transaction Management](https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/transactions.html)
- [SQL Server Concurrency Control](https://docs.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
- [Concurrency Control Research](https://dl.acm.org/topic/ccs/concurrency-control)
- [Database System Concepts](https://www.db-book.com/)