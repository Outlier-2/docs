---
title: "L08 - æœ€å°ç”Ÿæˆæ ‘"
description: "æ·±å…¥å­¦ä¹ æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ï¼ŒåŒ…æ‹¬Kruskalã€Primå’ŒBorÅ¯vkaç®—æ³•ï¼ŒæŒæ¡å›¾è®ºä¸­çš„æ ¸å¿ƒä¼˜åŒ–æŠ€æœ¯"
date: "2024-01-08"
category: "ç®—æ³•"
difficulty: "ä¸­ç­‰"
tags: ["å›¾ç®—æ³•", "æœ€å°ç”Ÿæˆæ ‘", "Kruskal", "Prim", "BorÅ¯vka", "ä¼˜åŒ–ç®—æ³•"]
duration: "3å°æ—¶"
prerequisites: ["L06-å›¾ç®—æ³•åŸºç¡€", "L05-å“ˆå¸Œè¡¨"]
next: ["L09-åŠ¨æ€è§„åˆ’"]
math: true
interactive: true
---

import { CodeBlock } from '@/src/components/algorithm/CodeBlock';
import { AlgorithmVisualizer } from '@/src/components/algorithm/AlgorithmVisualizer';
import { ArrayVisualizer } from '@/src/components/algorithm/ArrayVisualizer';
import { ComplexityAnalyzer } from '@/src/components/algorithm/ComplexityAnalyzer';
import { TreeVisualizer } from '@/src/components/algorithm/TreeVisualizer';
import { ExerciseBlock } from '@/src/components/algorithm/ExerciseBlock';

# L08 - æœ€å°ç”Ÿæˆæ ‘

## å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬è¯¾ç¨‹ï¼Œä½ å°†ï¼š

- ğŸ” **æŒæ¡æœ€å°ç”Ÿæˆæ ‘çš„åŸºæœ¬æ¦‚å¿µå’Œæ€§è´¨**ï¼Œç†è§£ç”Ÿæˆæ ‘ã€åˆ‡å‰²ã€å®‰å…¨è¾¹ç­‰æ ¸å¿ƒæ¦‚å¿µ
- ğŸ§® **æ·±å…¥ç†è§£Kruskalã€Primå’ŒBorÅ¯vkaç®—æ³•çš„åŸç†**ï¼ŒæŒæ¡ä¸‰ç§ç»å…¸ç®—æ³•çš„å®ç°
- âš¡ **å­¦ä¼šå¤„ç†å¸¦æƒæ— å‘å›¾çš„æœ€å°ç”Ÿæˆæ ‘é—®é¢˜**ï¼ŒåŒ…æ‹¬æ¬¡å°ç”Ÿæˆæ ‘å’ŒåŠ¨æ€MST
- ğŸŒ **èƒ½å¤Ÿåº”ç”¨æœ€å°ç”Ÿæˆæ ‘è§£å†³å®é™…é—®é¢˜**ï¼Œå¦‚ç½‘ç»œè®¾è®¡ã€èšç±»åˆ†æã€ç”µè·¯è®¾è®¡ç­‰

## æœ€å°ç”Ÿæˆæ ‘åŸºç¡€

### åŸºæœ¬æ¦‚å¿µ

**æœ€å°ç”Ÿæˆæ ‘**æ˜¯å›¾è®ºä¸­çš„ç»å…¸é—®é¢˜ï¼Œåœ¨ç°å®ä¸–ç•Œä¸­æœ‰å¹¿æ³›åº”ç”¨ï¼š

#### æ ¸å¿ƒå®šä¹‰

- **ç”Ÿæˆæ ‘(Spanning Tree)**: åŒ…å«å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹çš„æ— ç¯è¿é€šå­å›¾
- **æœ€å°ç”Ÿæˆæ ‘(MST)**: æƒé‡ä¹‹å’Œæœ€å°çš„ç”Ÿæˆæ ‘
- **åˆ‡å‰²(Cut)**: å°†é¡¶ç‚¹é›†åˆ†æˆä¸¤ä¸ªä¸äº¤å­é›†çš„åˆ’åˆ†
- **å®‰å…¨è¾¹(Safe Edge)**: è¿æ¥ä¸åŒåˆ‡å‰²å­é›†çš„æœ€å°æƒé‡è¾¹

#### æ•°å­¦æ€§è´¨

<AlgorithmVisualizer
  title="æœ€å°ç”Ÿæˆæ ‘æ€§è´¨"
  algorithm="mst-properties"
  steps={[
    {
      title: "å”¯ä¸€æ€§",
      content: "ä¸€ä¸ªè¿é€šå›¾çš„æœ€å°ç”Ÿæˆæ ‘æƒé‡æ˜¯å”¯ä¸€çš„",
      formula: "T_1 = T_2 â‡” w(T_1) = w(T_2)"
    },
    {
      title: "è¾¹æ•°",
      content: "æœ€å°ç”Ÿæˆæ ‘åŒ…å«V-1æ¡è¾¹ï¼ˆVä¸ºé¡¶ç‚¹æ•°ï¼‰",
      formula: "|E(T)| = |V| - 1"
    },
    {
      title: "æ— ç¯æ€§",
      content: "æœ€å°ç”Ÿæˆæ ‘æ˜¯æ— ç¯çš„è¿é€šå›¾",
      formula: "T æ˜¯è¿é€šçš„ âˆ§ T ä¸åŒ…å«ç¯"
    },
    {
      title: "æœ€å°æ€§",
      content: "åœ¨æ‰€æœ‰ç”Ÿæˆæ ‘ä¸­æƒé‡æœ€å°",
      formula: "âˆ€ T' âˆˆ S, w(T) â‰¤ w(T')"
    }
  ]}
/>

### é‡è¦å®šç†

**Kruskalç®—æ³•æ­£ç¡®æ€§è¯æ˜**ï¼šé€šè¿‡è´ªå¿ƒç­–ç•¥é€‰æ‹©æœ€å°æƒé‡è¾¹ï¼Œä½¿ç”¨å¹¶æŸ¥é›†é¿å…å½¢æˆç¯

**Primç®—æ³•æ­£ç¡®æ€§è¯æ˜**ï¼šä»ä»»æ„é¡¶ç‚¹å¼€å§‹ï¼Œæ¯æ¬¡é€‰æ‹©è¿æ¥å½“å‰æ ‘ä¸å¤–éƒ¨é¡¶ç‚¹çš„æœ€å°æƒé‡è¾¹

## Pythonå®ç°è¯¦è§£

### 1. æ— å‘åŠ æƒå›¾æ•°æ®ç»“æ„

<CodeBlock
  title="æ— å‘åŠ æƒå›¾å®ç°"
  code={`from typing import List, Dict, Tuple, Set, Optional
import heapq
from collections import defaultdict

class UndirectedWeightedGraph:
    """æ— å‘åŠ æƒå›¾

    æ—¶é—´å¤æ‚åº¦åˆ†æï¼š
    - add_vertex: O(1)
    - add_edge: O(1)
    - remove_edge: O(deg(v)) åº¦ç›¸å…³
    - get_neighbors: O(1)
    - is_connected: O(V + E)
    """

    def __init__(self):
        self.vertices = set()
        self.edges = []
        self.adjacency_list = defaultdict(list)

    def add_vertex(self, vertex) -> None:
        """æ·»åŠ é¡¶ç‚¹

        Args:
            vertex: é¡¶ç‚¹æ ‡è¯†ç¬¦
        """
        self.vertices.add(vertex)

    def add_edge(self, u, v, weight: float) -> None:
        """æ·»åŠ è¾¹

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            weight: è¾¹æƒé‡
        """
        self.add_vertex(u)
        self.add_vertex(v)
        self.edges.append((u, v, weight))
        self.adjacency_list[u].append((v, weight))
        self.adjacency_list[v].append((u, weight))

    def remove_edge(self, u, v, weight: float) -> None:
        """åˆ é™¤è¾¹

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            weight: è¾¹æƒé‡
        """
        self.edges.remove((u, v, weight))
        self.adjacency_list[u].remove((v, weight))
        self.adjacency_list[v].remove((u, weight))

    def get_vertices(self) -> Set:
        """è·å–æ‰€æœ‰é¡¶ç‚¹

        Returns:
            é¡¶ç‚¹é›†åˆ
        """
        return self.vertices

    def get_edges(self) -> List[Tuple]:
        """è·å–æ‰€æœ‰è¾¹

        Returns:
            è¾¹åˆ—è¡¨ [(u, v, weight)]
        """
        return self.edges

    def get_neighbors(self, vertex) -> List[Tuple]:
        """è·å–é‚»å±…

        Args:
            vertex: ç›®æ ‡é¡¶ç‚¹

        Returns:
            é‚»å±…åˆ—è¡¨ [(neighbor, weight)]
        """
        return self.adjacency_list.get(vertex, [])

    def get_total_weight(self) -> float:
        """è®¡ç®—å›¾çš„æ€»æƒé‡

        Returns:
            æ€»æƒé‡ï¼ˆæ— å‘å›¾æ¯æ¡è¾¹è¢«è®¡ç®—ä¸¤æ¬¡ï¼Œéœ€é™¤ä»¥2ï¼‰
        """
        return sum(weight for _, _, weight in self.edges) / 2

    def is_connected(self) -> bool:
        """æ£€æŸ¥å›¾æ˜¯å¦è¿é€š

        Returns:
            æ˜¯å¦è¿é€š
        """
        if not self.vertices:
            return True

        visited = set()
        stack = [next(iter(self.vertices))]

        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                for neighbor, _ in self.get_neighbors(current):
                    if neighbor not in visited:
                        stack.append(neighbor)

        return len(visited) == len(self.vertices)

    def __str__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º

        Returns:
            å›¾çš„å­—ç¬¦ä¸²è¡¨ç¤º
        """
        result = []
        for vertex in self.vertices:
            neighbors = self.get_neighbors(vertex)
            result.append(f"{vertex}: {neighbors}")
        return "\\n".join(result)`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. Kruskalç®—æ³•

<CodeBlock
  title="Kruskalç®—æ³•å®ç°"
  code={`class UnionFind:
    """å¹¶æŸ¥é›†æ•°æ®ç»“æ„

    æ”¯æŒè·¯å¾„å‹ç¼©å’ŒæŒ‰ç§©åˆå¹¶ï¼Œæ—¶é—´å¤æ‚åº¦è¿‘ä¹O(1)
    """

    def __init__(self, vertices):
        self.parent = {vertex: vertex for vertex in vertices}
        self.rank = {vertex: 0 for vertex in vertices}

    def find(self, vertex):
        """æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ï¼ˆè·¯å¾„å‹ç¼©ï¼‰

        Args:
            vertex: ç›®æ ‡é¡¶ç‚¹

        Returns:
            æ ¹èŠ‚ç‚¹
        """
        if self.parent[vertex] != vertex:
            self.parent[vertex] = self.find(self.parent[vertex])
        return self.parent[vertex]

    def union(self, vertex1, vertex2) -> bool:
        """åˆå¹¶ä¸¤ä¸ªé›†åˆï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰

        Args:
            vertex1: ç¬¬ä¸€ä¸ªé¡¶ç‚¹
            vertex2: ç¬¬äºŒä¸ªé¡¶ç‚¹

        Returns:
            æ˜¯å¦æˆåŠŸåˆå¹¶
        """
        root1 = self.find(vertex1)
        root2 = self.find(vertex2)

        if root1 == root2:
            return False  # å·²ç»åœ¨åŒä¸€é›†åˆ

        if self.rank[root1] < self.rank[root2]:
            self.parent[root1] = root2
        elif self.rank[root1] > self.rank[root2]:
            self.parent[root2] = root1
        else:
            self.parent[root2] = root1
            self.rank[root1] += 1

        return True

def kruskal_mst(graph: UndirectedWeightedGraph) -> Tuple[List[Tuple], float]:
    """Kruskalç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘

    ç®—æ³•æ­¥éª¤ï¼š
    1. æŒ‰æƒé‡å‡åºæ’åºæ‰€æœ‰è¾¹
    2. åˆå§‹åŒ–å¹¶æŸ¥é›†
    3. ä¾æ¬¡é€‰æ‹©æœ€å°æƒé‡è¾¹ï¼Œè‹¥ä¸å½¢æˆç¯åˆ™åŠ å…¥MST

    æ—¶é—´å¤æ‚åº¦: O(E log E) = O(E log V)
    ç©ºé—´å¤æ‚åº¦: O(V)

    Args:
        graph: æ— å‘åŠ æƒå›¾

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡)

    Raises:
        ValueError: å›¾ä¸è¿é€šæ—¶æŠ›å‡º
    """
    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    # æŒ‰æƒé‡æ’åºè¾¹
    edges = sorted(graph.get_edges(), key=lambda x: x[2])
    union_find = UnionFind(graph.get_vertices())
    mst_edges = []
    total_weight = 0

    for u, v, weight in edges:
        if union_find.find(u) != union_find.find(v):
            union_find.union(u, v)
            mst_edges.append((u, v, weight))
            total_weight += weight

            # æå‰ç»ˆæ­¢æ¡ä»¶
            if len(mst_edges) == len(graph.get_vertices()) - 1:
                break

    return mst_edges, total_weight

def kruskal_with_detailed_logging(graph: UndirectedWeightedGraph) -> Tuple[List[Tuple], float, List[str]]:
    """å¸¦è¯¦ç»†æ—¥å¿—çš„Kruskalç®—æ³•

    ç”¨äºç®—æ³•æ¼”ç¤ºå’Œè°ƒè¯•

    Args:
        graph: æ— å‘åŠ æƒå›¾

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡, æ‰§è¡Œæ—¥å¿—)
    """
    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    edges = sorted(graph.get_edges(), key=lambda x: x[2])
    union_find = UnionFind(graph.get_vertices())
    mst_edges = []
    total_weight = 0
    logs = []

    logs.append(f"å¼€å§‹Kruskalç®—æ³•ï¼Œå…±æœ‰{len(edges)}æ¡è¾¹ï¼Œ{len(graph.get_vertices())}ä¸ªé¡¶ç‚¹")

    for i, (u, v, weight) in enumerate(edges):
        logs.append(f"å¤„ç†ç¬¬{i+1}æ¡è¾¹: ({u}, {v}, {weight})")

        root_u = union_find.find(u)
        root_v = union_find.find(v)

        if root_u != root_v:
            union_find.union(u, v)
            mst_edges.append((u, v, weight))
            total_weight += weight
            logs.append(f"  âœ“ åŠ å…¥MSTï¼Œå½“å‰æƒé‡: {total_weight}")
        else:
            logs.append(f"  âœ— è·³è¿‡ï¼Œä¼šå½¢æˆç¯")

        if len(mst_edges) == len(graph.get_vertices()) - 1:
            logs.append(f"å®Œæˆï¼MSTåŒ…å«{len(mst_edges)}æ¡è¾¹ï¼Œæ€»æƒé‡: {total_weight}")
            break

    return mst_edges, total_weight, logs`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 3. Primç®—æ³•

<CodeBlock
  title="Primç®—æ³•å®ç°"
  code={`def prim_mst(graph: UndirectedWeightedGraph, start_vertex=None) -> Tuple[List[Tuple], float]:
    """Primç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘

    ç®—æ³•æ­¥éª¤ï¼š
    1. ä»ä»»æ„é¡¶ç‚¹å¼€å§‹
    2. ç»´æŠ¤å·²è®¿é—®é¡¶ç‚¹é›†åˆ
    3. ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—é€‰æ‹©è¿æ¥å·²è®¿é—®å’Œæœªè®¿é—®é¡¶ç‚¹çš„æœ€å°æƒé‡è¾¹

    æ—¶é—´å¤æ‚åº¦: O(E log V) ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—
    ç©ºé—´å¤æ‚åº¦: O(V)

    Args:
        graph: æ— å‘åŠ æƒå›¾
        start_vertex: èµ·å§‹é¡¶ç‚¹ï¼ˆå¯é€‰ï¼‰

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡)

    Raises:
        ValueError: å›¾ä¸è¿é€šæ—¶æŠ›å‡º
    """
    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    vertices = graph.get_vertices()
    if not vertices:
        return [], 0

    # é€‰æ‹©èµ·å§‹é¡¶ç‚¹
    if start_vertex is None:
        start_vertex = next(iter(vertices))

    # åˆå§‹åŒ–
    mst_edges = []
    total_weight = 0
    visited = set()
    min_heap = []

    # æ·»åŠ èµ·å§‹é¡¶ç‚¹çš„æ‰€æœ‰è¾¹
    visited.add(start_vertex)
    for neighbor, weight in graph.get_neighbors(start_vertex):
        heapq.heappush(min_heap, (weight, start_vertex, neighbor))

    while min_heap and len(visited) < len(vertices):
        weight, u, v = heapq.heappop(min_heap)

        if v not in visited:
            visited.add(v)
            mst_edges.append((u, v, weight))
            total_weight += weight

            # æ·»åŠ æ–°é¡¶ç‚¹çš„è¾¹
            for neighbor, edge_weight in graph.get_neighbors(v):
                if neighbor not in visited:
                    heapq.heappush(min_heap, (edge_weight, v, neighbor))

    return mst_edges, total_weight

def prim_lazy_mst(graph: UndirectedWeightedGraph, start_vertex=None) -> Tuple[List[Tuple], float]:
    """å»¶è¿ŸPrimç®—æ³•ï¼ˆé¿å…é‡å¤è¾¹ï¼‰

    ä¼˜åŒ–ç‰ˆæœ¬ï¼Œé¿å…å †ä¸­å­˜å‚¨å¤§é‡æ— æ•ˆè¾¹

    Args:
        graph: æ— å‘åŠ æƒå›¾
        start_vertex: èµ·å§‹é¡¶ç‚¹ï¼ˆå¯é€‰ï¼‰

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡)
    """
    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    vertices = graph.get_vertices()
    if not vertices:
        return [], 0

    if start_vertex is None:
        start_vertex = next(iter(vertices))

    mst_edges = []
    total_weight = 0
    visited = set()
    min_heap = []

    visited.add(start_vertex)

    def add_edges(vertex):
        """æ·»åŠ é¡¶ç‚¹çš„æ‰€æœ‰è¾¹åˆ°å †ä¸­"""
        for neighbor, weight in graph.get_neighbors(vertex):
            if neighbor not in visited:
                heapq.heappush(min_heap, (weight, vertex, neighbor))

    add_edges(start_vertex)

    while min_heap and len(visited) < len(vertices):
        # æ‰¾åˆ°æœ‰æ•ˆçš„æœ€å°è¾¹
        while min_heap:
            weight, u, v = heapq.heappop(min_heap)
            if v not in visited:
                break
        else:
            break

        visited.add(v)
        mst_edges.append((u, v, weight))
        total_weight += weight
        add_edges(v)

    return mst_edges, total_weight

def prim_with_detailed_logging(graph: UndirectedWeightedGraph, start_vertex=None) -> Tuple[List[Tuple], float, List[str]]:
    """å¸¦è¯¦ç»†æ—¥å¿—çš„Primç®—æ³•

    Args:
        graph: æ— å‘åŠ æƒå›¾
        start_vertex: èµ·å§‹é¡¶ç‚¹ï¼ˆå¯é€‰ï¼‰

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡, æ‰§è¡Œæ—¥å¿—)
    """
    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    vertices = graph.get_vertices()
    if not vertices:
        return [], 0, ["ç©ºå›¾"]

    if start_vertex is None:
        start_vertex = next(iter(vertices))

    mst_edges = []
    total_weight = 0
    visited = set()
    min_heap = []
    logs = []

    visited.add(start_vertex)
    logs.append(f"ä»é¡¶ç‚¹ {start_vertex} å¼€å§‹Primç®—æ³•")

    def add_edges_with_logging(vertex):
        """æ·»åŠ é¡¶ç‚¹çš„æ‰€æœ‰è¾¹åˆ°å †ä¸­ï¼Œå¸¦æ—¥å¿—"""
        logs.append(f"æ·»åŠ é¡¶ç‚¹ {vertex} çš„è¾¹:")
        for neighbor, weight in graph.get_neighbors(vertex):
            if neighbor not in visited:
                heapq.heappush(min_heap, (weight, vertex, neighbor))
                logs.append(f"  - è¾¹({vertex}, {neighbor}, {weight})")

    add_edges_with_logging(start_vertex)

    while min_heap and len(visited) < len(vertices):
        # æ‰¾åˆ°æœ‰æ•ˆçš„æœ€å°è¾¹
        while min_heap:
            weight, u, v = heapq.heappop(min_heap)
            if v not in visited:
                break
        else:
            break

        visited.add(v)
        mst_edges.append((u, v, weight))
        total_weight += weight
        logs.append(f"é€‰æ‹©è¾¹({u}, {v}, {weight}), å½“å‰æ€»æƒé‡: {total_weight}")
        logs.append(f"å·²è®¿é—®é¡¶ç‚¹: {visited}")

        add_edges_with_logging(v)

    logs.append(f"å®Œæˆï¼MSTåŒ…å«{len(mst_edges)}æ¡è¾¹ï¼Œæ€»æƒé‡: {total_weight}")
    return mst_edges, total_weight, logs`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 4. BorÅ¯vkaç®—æ³•

<CodeBlock
  title="BorÅ¯vkaç®—æ³•å®ç°"
  code={`def boruvka_mst(graph: UndirectedWeightedGraph) -> Tuple[List[Tuple], float]:
    """BorÅ¯vkaç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘

    ç®—æ³•ç‰¹ç‚¹ï¼š
    1. é€‚åˆå¹¶è¡ŒåŒ–å¤„ç†
    2. åˆ†è½®æ¬¡å¤„ç†ï¼Œæ¯è½®ä¸ºæ¯ä¸ªç»„ä»¶æ‰¾åˆ°æœ€å°å‡ºè¾¹
    3. å†å²ä¸Šæœ€æ—©çš„MSTç®—æ³•ä¹‹ä¸€

    æ—¶é—´å¤æ‚åº¦: O(E log V)
    é€‚åˆå¹¶è¡ŒåŒ–

    Args:
        graph: æ— å‘åŠ æƒå›¾

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡)

    Raises:
        ValueError: å›¾ä¸è¿é€šæ—¶æŠ›å‡º
    """
    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    vertices = graph.get_vertices()
    mst_edges = []
    total_weight = 0

    # åˆå§‹åŒ–æ¯ä¸ªé¡¶ç‚¹ä¸ºç‹¬ç«‹ç»„ä»¶
    component = {vertex: vertex for vertex in vertices}
    component_size = {vertex: 1 for vertex in vertices}

    def find(vertex):
        """æŸ¥æ‰¾ç»„ä»¶ï¼ˆå¸¦è·¯å¾„å‹ç¼©ï¼‰"""
        while component[vertex] != vertex:
            component[vertex] = component[component[vertex]]
            vertex = component[vertex]
        return vertex

    def union(vertex1, vertex2):
        """åˆå¹¶ç»„ä»¶ï¼ˆæŒ‰å¤§å°åˆå¹¶ï¼‰"""
        root1 = find(vertex1)
        root2 = find(vertex2)

        if root1 == root2:
            return False

        if component_size[root1] < component_size[root2]:
            component[root1] = root2
            component_size[root2] += component_size[root1]
        else:
            component[root2] = root1
            component_size[root1] += component_size[root2]

        return True

    # æœ€å¤šè¿›è¡Œlog Vè½®
    round_num = 0
    while len(mst_edges) < len(vertices) - 1:
        round_num += 1

        # ä¸ºæ¯ä¸ªç»„ä»¶æ‰¾åˆ°æœ€å°å‡ºè¾¹
        min_edges = {}

        for u, v, weight in graph.get_edges():
            root_u = find(u)
            root_v = find(v)

            if root_u != root_v:
                if root_u not in min_edges or weight < min_edges[root_u][2]:
                    min_edges[root_u] = (u, v, weight)

                if root_v not in min_edges or weight < min_edges[root_v][2]:
                    min_edges[root_v] = (v, u, weight)

        # æ·»åŠ æœ€å°è¾¹åˆ°MST
        edges_added = 0
        for component_root, edge in min_edges.items():
            u, v, weight = edge
            if find(u) != find(v):
                union(u, v)
                mst_edges.append(edge)
                total_weight += weight
                edges_added += 1

        if edges_added == 0:
            break

    return mst_edges, total_weight

def boruvka_parallel_version(graph: UndirectedWeightedGraph, num_threads=4) -> Tuple[List[Tuple], float]:
    """å¹¶è¡ŒBorÅ¯vkaç®—æ³•

    åˆ©ç”¨BorÅ¯vkaç®—æ³•çš„å¹¶è¡Œç‰¹æ€§

    Args:
        graph: æ— å‘åŠ æƒå›¾
        num_threads: çº¿ç¨‹æ•°

    Returns:
        (MSTè¾¹åˆ—è¡¨, æ€»æƒé‡)
    """
    import concurrent.futures

    if not graph.is_connected():
        raise ValueError("å›¾ä¸è¿é€šï¼Œæ— æ³•ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘")

    vertices = graph.get_vertices()
    mst_edges = []
    total_weight = 0

    # åˆå§‹åŒ–ç»„ä»¶
    component = {vertex: vertex for vertex in vertices}
    component_size = {vertex: 1 for vertex in vertices}

    def find(vertex):
        """æŸ¥æ‰¾ç»„ä»¶"""
        while component[vertex] != vertex:
            component[vertex] = component[component[vertex]]
            vertex = component[vertex]
        return vertex

    def union(vertex1, vertex2):
        """åˆå¹¶ç»„ä»¶"""
        root1 = find(vertex1)
        root2 = find(vertex2)

        if root1 == root2:
            return False

        if component_size[root1] < component_size[root2]:
            component[root1] = root2
            component_size[root2] += component_size[root1]
        else:
            component[root2] = root1
            component_size[root1] += component_size[root2]

        return True

    def find_min_edges_for_component(component_roots):
        """ä¸ºæŒ‡å®šç»„ä»¶æ‰¾æœ€å°å‡ºè¾¹"""
        local_min_edges = {}
        for root in component_roots:
            min_edge = None
            min_weight = float('inf')

            for u, v, weight in graph.get_edges():
                root_u = find(u)
                root_v = find(v)

                if root_u == root and root_u != root_v:
                    if weight < min_weight:
                        min_weight = weight
                        min_edge = (u, v, weight)
                elif root_v == root and root_u != root_v:
                    if weight < min_weight:
                        min_weight = weight
                        min_edge = (v, u, weight)

            if min_edge:
                local_min_edges[root] = min_edge

        return local_min_edges

    # å¹¶è¡ŒBorÅ¯vka
    round_num = 0
    while len(mst_edges) < len(vertices) - 1:
        round_num += 1

        # åˆ†å‰²ç»„ä»¶åˆ°ä¸åŒçº¿ç¨‹
        current_components = set(find(v) for v in vertices)
        component_list = list(current_components)

        # åˆ†é…ç»„ä»¶åˆ°çº¿ç¨‹
        components_per_thread = len(component_list) // num_threads
        component_chunks = [component_list[i:i + components_per_thread]
                           for i in range(0, len(component_list), components_per_thread)]

        # å¹¶è¡ŒæŸ¥æ‰¾æœ€å°è¾¹
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
            futures = [executor.submit(find_min_edges_for_component, chunk)
                      for chunk in component_chunks]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]

        # åˆå¹¶ç»“æœ
        min_edges = {}
        for local_min_edges in results:
            min_edges.update(local_min_edges)

        # æ·»åŠ è¾¹åˆ°MST
        edges_added = 0
        for component_root, edge in min_edges.items():
            u, v, weight = edge
            if find(u) != find(v):
                union(u, v)
                mst_edges.append(edge)
                total_weight += weight
                edges_added += 1

        if edges_added == 0:
            break

    return mst_edges, total_weight`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## ç®—æ³•æ¯”è¾ƒä¸æ€§èƒ½åˆ†æ

<ComplexityAnalyzer
  algorithms={[
    {
      name: "Kruskalç®—æ³•",
      timeComplexity: "O(E log E)",
      spaceComplexity: "O(V)",
      bestCase: "O(E log E)",
      worstCase: "O(E log E)",
      averageCase: "O(E log E)",
      description: "é€‚åˆç¨€ç–å›¾ï¼Œå®ç°ç®€å•ï¼Œéœ€è¦æ’åºå’Œå¹¶æŸ¥é›†"
    },
    {
      name: "Primç®—æ³•",
      timeComplexity: "O(E log V)",
      spaceComplexity: "O(V)",
      bestCase: "O(E log V)",
      worstCase: "O(E log V)",
      averageCase: "O(E log V)",
      description: "é€‚åˆç¨ å¯†å›¾ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œéœ€è¦å›¾ç»“æ„"
    },
    {
      name: "BorÅ¯vkaç®—æ³•",
      timeComplexity: "O(E log V)",
      spaceComplexity: "O(V)",
      bestCase: "O(E log V)",
      worstCase: "O(E log V)",
      averageCase: "O(E log V)",
      description: "é€‚åˆå¹¶è¡ŒåŒ–ï¼Œåˆ†è½®æ¬¡å¤„ç†ï¼Œå†å²æœ€æ—©ç®—æ³•"
    }
  ]}
/>

### ç®—æ³•é€‰æ‹©ç­–ç•¥

<AlgorithmVisualizer
  title="MSTç®—æ³•é€‰æ‹©ç­–ç•¥"
  algorithm="algorithm-selection"
  steps={[
    {
      title: "å›¾çš„ç±»å‹",
      content: "åˆ¤æ–­å›¾æ˜¯ç¨€ç–è¿˜æ˜¯ç¨ å¯†",
      conditions: ["E â‰ˆ V", "E â‰ˆ VÂ²", "E >> V log V"]
    },
    {
      title: "å†…å­˜é™åˆ¶",
      content: "è€ƒè™‘å†…å­˜ä½¿ç”¨é™åˆ¶",
      conditions: ["å†…å­˜å……è¶³", "å†…å­˜æœ‰é™", "éœ€è¦å¹¶è¡ŒåŒ–"]
    },
    {
      title: "ç®—æ³•é€‰æ‹©",
      content: "æ ¹æ®æ¡ä»¶é€‰æ‹©åˆé€‚ç®—æ³•",
      results: {
        "ç¨€ç–å›¾": "Kruskalç®—æ³•",
        "ç¨ å¯†å›¾": "Primç®—æ³•",
        "éœ€è¦å¹¶è¡Œ": "BorÅ¯vkaç®—æ³•"
      }
    }
  ]}
/>

## é«˜çº§MSTç®—æ³•

### 1. æ¬¡å°ç”Ÿæˆæ ‘

<CodeBlock
  title="æ¬¡å°ç”Ÿæˆæ ‘ç®—æ³•"
  code={`def find_max_edge_on_path(graph: UndirectedWeightedGraph, mst_edges: List[Tuple], u: str, v: str) -> float:
    """åœ¨MSTä¸­æŸ¥æ‰¾uåˆ°vè·¯å¾„ä¸Šçš„æœ€å¤§è¾¹æƒé‡

    ç®—æ³•æ­¥éª¤ï¼š
    1. æ„å»ºMSTçš„é‚»æ¥è¡¨
    2. ä½¿ç”¨BFSæŸ¥æ‰¾uåˆ°vçš„è·¯å¾„
    3. è®°å½•è·¯å¾„ä¸Šçš„æœ€å¤§æƒé‡

    Args:
        graph: åŸå§‹å›¾
        mst_edges: MSTè¾¹åˆ—è¡¨
        u: èµ·å§‹é¡¶ç‚¹
        v: ç›®æ ‡é¡¶ç‚¹

    Returns:
        è·¯å¾„ä¸Šçš„æœ€å¤§è¾¹æƒé‡
    """
    # æ„å»ºMSTçš„é‚»æ¥è¡¨
    mst_graph = defaultdict(list)
    for edge_u, edge_v, weight in mst_edges:
        mst_graph[edge_u].append((edge_v, weight))
        mst_graph[edge_v].append((edge_u, weight))

    # BFSæŸ¥æ‰¾è·¯å¾„
    parent = {}
    max_weight = {}
    queue = [u]
    parent[u] = None
    max_weight[u] = 0

    while queue:
        current = queue.pop(0)
        if current == v:
            break

        for neighbor, weight in mst_graph[current]:
            if neighbor not in parent:
                parent[neighbor] = current
                max_weight[neighbor] = max(max_weight[current], weight)
                queue.append(neighbor)

    return max_weight.get(v, 0)

def second_best_mst(graph: UndirectedWeightedGraph) -> Tuple[List[Tuple], float]:
    """æ¬¡å°ç”Ÿæˆæ ‘ç®—æ³•

    ç®—æ³•æ€è·¯ï¼š
    1. é¦–å…ˆè®¡ç®—æœ€å°ç”Ÿæˆæ ‘
    2. å°è¯•ç”¨æ¯æ¡éMSTè¾¹æ›¿æ¢MSTä¸­çš„ä¸€æ¡è¾¹
    3. é€‰æ‹©æƒé‡æœ€å°çš„æ›¿ä»£æ–¹æ¡ˆ

    æ—¶é—´å¤æ‚åº¦: O(E * V)

    Args:
        graph: æ— å‘åŠ æƒå›¾

    Returns:
        (æ¬¡å°ç”Ÿæˆæ ‘è¾¹åˆ—è¡¨, æ€»æƒé‡)
    """
    # é¦–å…ˆè®¡ç®—æœ€å°ç”Ÿæˆæ ‘
    mst_edges, mst_weight = kruskal_mst(graph)

    best_second_weight = float('inf')
    best_second_edges = []

    # å°è¯•æ›¿æ¢æ¯æ¡éMSTè¾¹
    non_mst_edges = [edge for edge in graph.get_edges() if edge not in mst_edges]

    for new_u, new_v, new_weight in non_mst_edges:
        # åœ¨MSTä¸­æŸ¥æ‰¾new_uåˆ°new_vè·¯å¾„ä¸Šçš„æœ€å¤§è¾¹
        max_edge_weight = find_max_edge_on_path(graph, mst_edges, new_u, new_v)

        # è®¡ç®—æ–°æ ‘çš„æ€»æƒé‡
        new_weight_total = mst_weight - max_edge_weight + new_weight

        if new_weight_total < best_second_weight:
            best_second_weight = new_weight_total

            # æ„å»ºæ–°çš„è¾¹é›†
            temp_edges = mst_edges.copy()
            # ç§»é™¤æœ€å¤§è¾¹
            for i, (u, v, weight) in enumerate(temp_edges):
                if weight == max_edge_weight:
                    del temp_edges[i]
                    break
            # æ·»åŠ æ–°è¾¹
            temp_edges.append((new_u, new_v, new_weight))
            best_second_edges = temp_edges

    return best_second_edges, best_second_weight

def kth_best_mst(graph: UndirectedWeightedGraph, k: int = 3) -> List[Tuple[List[Tuple], float]]:
    """ç¬¬kå°ç”Ÿæˆæ ‘ç®—æ³•

    æ‰¾åˆ°æƒé‡ç¬¬kå°çš„ç”Ÿæˆæ ‘

    Args:
        graph: æ— å‘åŠ æƒå›¾
        k: è¦æ±‚çš„æ’å

    Returns:
        ç”Ÿæˆæ ‘åˆ—è¡¨ï¼ŒæŒ‰æƒé‡å‡åºæ’åˆ—
    """
    if k <= 0:
        return []

    # ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤å€™é€‰ç”Ÿæˆæ ‘
    heap = []

    # é¦–å…ˆè®¡ç®—æœ€å°ç”Ÿæˆæ ‘
    mst_edges, mst_weight = kruskal_mst(graph)
    heapq.heappush(heap, (mst_weight, 0, mst_edges))

    result = []
    used_trees = set()

    while heap and len(result) < k:
        weight, generation, edges = heapq.heappop(heap)

        # æ£€æŸ¥æ˜¯å¦å·²ç»ä½¿ç”¨è¿‡
        edges_tuple = tuple(sorted(edges))
        if edges_tuple in used_trees:
            continue

        used_trees.add(edges_tuple)
        result.append((edges, weight))

        # ç”Ÿæˆä¸‹ä¸€ä»£çš„å€™é€‰æ ‘
        if generation < k:  # é™åˆ¶ç”Ÿæˆæ·±åº¦
            candidates = _generate_candidate_trees(graph, edges, weight)
            for candidate_weight, candidate_edges in candidates:
                candidate_tuple = tuple(sorted(candidate_edges))
                if candidate_tuple not in used_trees:
                    heapq.heappush(heap, (candidate_weight, generation + 1, candidate_edges))

    return result

def _generate_candidate_trees(graph: UndirectedWeightedGraph, base_edges: List[Tuple], base_weight: float) -> List[Tuple[float, List[Tuple]]]:
    """ç”Ÿæˆå€™é€‰ç”Ÿæˆæ ‘

    é€šè¿‡è¾¹æ›¿æ¢ç”Ÿæˆæ–°çš„ç”Ÿæˆæ ‘

    Args:
        graph: åŸå§‹å›¾
        base_edges: åŸºç¡€ç”Ÿæˆæ ‘è¾¹
        base_weight: åŸºç¡€ç”Ÿæˆæ ‘æƒé‡

    Returns:
        å€™é€‰ç”Ÿæˆæ ‘åˆ—è¡¨ [(æƒé‡, è¾¹åˆ—è¡¨)]
    """
    candidates = []
    non_mst_edges = [edge for edge in graph.get_edges() if edge not in base_edges]

    for new_u, new_v, new_weight in non_mst_edges:
        # æ‰¾åˆ°å¯æ›¿æ¢çš„è¾¹
        max_edge_weight = find_max_edge_on_path(graph, base_edges, new_u, new_v)

        if max_edge_weight < new_weight:  # åªæœ‰å½“èƒ½æ”¹è¿›æ—¶æ‰æ›¿æ¢
            new_tree_weight = base_weight - max_edge_weight + new_weight

            # æ„å»ºæ–°æ ‘
            new_edges = []
            max_edge_removed = False
            for edge in base_edges:
                if edge[2] == max_edge_weight and not max_edge_removed:
                    max_edge_removed = True
                else:
                    new_edges.append(edge)
            new_edges.append((new_u, new_v, new_weight))

            candidates.append((new_tree_weight, new_edges))

    return candidates`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. åŠ¨æ€æœ€å°ç”Ÿæˆæ ‘

<CodeBlock
  title="åŠ¨æ€æœ€å°ç”Ÿæˆæ ‘ç®—æ³•"
  code={`class DynamicMST:
    """åŠ¨æ€æœ€å°ç”Ÿæˆæ ‘

    æ”¯æŒè¾¹çš„åŠ¨æ€å¢åˆ å’Œæƒé‡æ›´æ–°

    æ“ä½œæ—¶é—´å¤æ‚åº¦ï¼š
    - åˆå§‹åŒ–: O(E log E)
    - æ·»åŠ è¾¹: O(V) å¹³å‡æƒ…å†µ
    - åˆ é™¤è¾¹: O(E log E) æœ€åæƒ…å†µ
    - æ›´æ–°æƒé‡: O(V) å¹³å‡æƒ…å†µ
    """

    def __init__(self, graph: UndirectedWeightedGraph):
        self.graph = graph
        self.mst_edges = []
        self.total_weight = 0
        self.edge_weight_map = {}

    def initialize(self) -> None:
        """åˆå§‹åŒ–MST

        æ„å»ºåˆå§‹çš„æœ€å°ç”Ÿæˆæ ‘
        """
        self.mst_edges, self.total_weight = kruskal_mst(self.graph)
        self._build_edge_weight_map()

    def _build_edge_weight_map(self) -> None:
        """æ„å»ºè¾¹æƒé‡æ˜ å°„

        å¿«é€ŸæŸ¥æ‰¾è¾¹çš„æƒé‡
        """
        self.edge_weight_map = {(u, v): weight for u, v, weight in self.graph.get_edges()}

    def add_edge(self, u, v, weight: float) -> None:
        """æ·»åŠ è¾¹

        å¦‚æœæ–°è¾¹èƒ½æ”¹è¿›MSTï¼Œåˆ™æ›´æ–°MST

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            weight: è¾¹æƒé‡
        """
        self.graph.add_edge(u, v, weight)
        self.edge_weight_map[(u, v)] = weight
        self.edge_weight_map[(v, u)] = weight

        # å¦‚æœæ–°è¾¹èƒ½æ”¹è¿›MSTï¼Œåˆ™æ›´æ–°
        if self._can_improve_mst(u, v, weight):
            self._update_mst_with_new_edge(u, v, weight)

    def remove_edge(self, u, v, weight: float) -> None:
        """åˆ é™¤è¾¹

        å¦‚æœåˆ é™¤çš„æ˜¯MSTè¾¹ï¼Œéœ€è¦é‡æ–°è®¡ç®—MST

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            weight: è¾¹æƒé‡
        """
        self.graph.remove_edge(u, v, weight)
        del self.edge_weight_map[(u, v)]
        del self.edge_weight_map[(v, u)]

        # å¦‚æœåˆ é™¤çš„æ˜¯MSTè¾¹ï¼Œéœ€è¦é‡æ–°è®¡ç®—
        if (u, v, weight) in self.mst_edges or (v, u, weight) in self.mst_edges:
            self._recalculate_mst()

    def update_edge_weight(self, u, v, old_weight: float, new_weight: float) -> None:
        """æ›´æ–°è¾¹æƒé‡

        æ™ºèƒ½æ›´æ–°ï¼šåªæœ‰å½±å“MSTæ—¶æ‰é‡æ–°è®¡ç®—

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            old_weight: æ—§æƒé‡
            new_weight: æ–°æƒé‡
        """
        self.graph.remove_edge(u, v, old_weight)
        self.graph.add_edge(u, v, new_weight)
        self.edge_weight_map[(u, v)] = new_weight
        self.edge_weight_map[(v, u)] = new_weight

        if (u, v, old_weight) in self.mst_edges or (v, u, old_weight) in self.mst_edges:
            if new_weight > old_weight:
                # æƒé‡å¢åŠ ï¼Œå¯èƒ½ä¸å†æ˜¯MST
                self._recalculate_mst()
            else:
                # æƒé‡å‡å°‘ï¼Œä¿æŒåŸMSTï¼ˆå› ä¸ºå·²ç»æ˜¯æ›´å°çš„æƒé‡ï¼‰
                pass
        else:
            # éMSTè¾¹æƒé‡å‡å°‘ï¼Œå¯èƒ½æˆä¸ºæ›´å¥½çš„é€‰æ‹©
            if new_weight < old_weight and self._can_improve_mst(u, v, new_weight):
                self._update_mst_with_new_edge(u, v, new_weight)

    def _can_improve_mst(self, u, v, weight: float) -> bool:
        """æ£€æŸ¥æ–°è¾¹æ˜¯å¦èƒ½æ”¹è¿›MST

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            weight: è¾¹æƒé‡

        Returns:
            æ˜¯å¦èƒ½æ”¹è¿›MST
        """
        if not self.mst_edges:
            return True

        # åœ¨MSTä¸­æŸ¥æ‰¾uåˆ°vè·¯å¾„ä¸Šçš„æœ€å¤§è¾¹
        max_weight = find_max_edge_on_path(self.graph, self.mst_edges, u, v)
        return weight < max_weight

    def _update_mst_with_new_edge(self, u, v, weight: float) -> None:
        """ç”¨æ–°è¾¹æ›´æ–°MST

        Args:
            u: èµ·å§‹é¡¶ç‚¹
            v: ç›®æ ‡é¡¶ç‚¹
            weight: è¾¹æƒé‡
        """
        # æ‰¾åˆ°å¹¶ç§»é™¤è·¯å¾„ä¸Šçš„æœ€å¤§è¾¹
        max_weight = find_max_edge_on_path(self.graph, self.mst_edges, u, v)

        for i, (edge_u, edge_v, edge_weight) in enumerate(self.mst_edges):
            if edge_weight == max_weight:
                del self.mst_edges[i]
                break

        # æ·»åŠ æ–°è¾¹
        self.mst_edges.append((u, v, weight))
        self.total_weight = self.total_weight - max_weight + weight

    def _recalculate_mst(self) -> None:
        """é‡æ–°è®¡ç®—MST

        å½“MSTç»“æ„å‘ç”Ÿé‡å¤§å˜åŒ–æ—¶é‡æ–°è®¡ç®—
        """
        self.mst_edges, self.total_weight = kruskal_mst(self.graph)

    def get_mst_weight(self) -> float:
        """è·å–å½“å‰MSTæƒé‡

        Returns:
            å½“å‰MSTæ€»æƒé‡
        """
        return self.total_weight

    def get_mst_edges(self) -> List[Tuple]:
        """è·å–å½“å‰MSTè¾¹

        Returns:
            å½“å‰MSTè¾¹åˆ—è¡¨
        """
        return self.mst_edges.copy()

    def get_operations_stats(self) -> Dict[str, int]:
        """è·å–æ“ä½œç»Ÿè®¡ä¿¡æ¯

        Returns:
            å„ç±»æ“ä½œçš„ç»Ÿè®¡
        """
        return {
            'total_operations': getattr(self, '_total_ops', 0),
            'add_operations': getattr(self, '_add_ops', 0),
            'remove_operations': getattr(self, '_remove_ops', 0),
            'update_operations': getattr(self, '_update_ops', 0),
            'recalculate_count': getattr(self, '_recalc_count', 0)
        }`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## å®é™…åº”ç”¨åœºæ™¯

### 1. ç½‘ç»œè®¾è®¡ä¼˜åŒ–

<CodeBlock
  title="ç½‘ç»œè®¾è®¡å™¨å®ç°"
  code={`class NetworkDesigner:
    """ç½‘ç»œè®¾è®¡å™¨

    åº”ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ä¼˜åŒ–ç½‘ç»œå¸ƒçº¿æˆæœ¬
    é€‚ç”¨äºé€šä¿¡ç½‘ç»œã€ç”µåŠ›ç½‘ç»œã€äº¤é€šç½‘ç»œç­‰
    """

    def __init__(self):
        self.network_graph = UndirectedWeightedGraph()
        self.cities = {}
        self.optimization_history = []

    def add_city(self, city_id: str, name: str, x_coord: float, y_coord: float) -> None:
        """æ·»åŠ åŸå¸‚èŠ‚ç‚¹

        Args:
            city_id: åŸå¸‚å”¯ä¸€æ ‡è¯†
            name: åŸå¸‚åç§°
            x_coord: Xåæ ‡
            y_coord: Yåæ ‡
        """
        self.cities[city_id] = {
            'name': name,
            'x': x_coord,
            'y': y_coord,
            'population': 0,
            'importance': 1.0
        }
        self.network_graph.add_vertex(city_id)

    def set_city_properties(self, city_id: str, population: int = None, importance: float = None) -> None:
        """è®¾ç½®åŸå¸‚å±æ€§

        Args:
            city_id: åŸå¸‚æ ‡è¯†
            population: äººå£æ•°é‡
            importance: é‡è¦ç¨‹åº¦ï¼ˆ0-1ï¼‰
        """
        if city_id in self.cities:
            if population is not None:
                self.cities[city_id]['population'] = population
            if importance is not None:
                self.cities[city_id]['importance'] = importance

    def calculate_distance(self, city1_id: str, city2_id: str) -> float:
        """è®¡ç®—åŸå¸‚é—´æ¬§æ°è·ç¦»

        Args:
            city1_id: ç¬¬ä¸€ä¸ªåŸå¸‚æ ‡è¯†
            city2_id: ç¬¬äºŒä¸ªåŸå¸‚æ ‡è¯†

        Returns:
            ä¸¤åŸå¸‚é—´è·ç¦»
        """
        city1 = self.cities[city1_id]
        city2 = self.cities[city2_id]
        return ((city1['x'] - city2['x'])**2 + (city1['y'] - city2['y'])**2)**0.5

    def add_connection(self, city1_id: str, city2_id: str,
                      cost_per_unit: float = 1.0,
                      difficulty_factor: float = 1.0) -> None:
        """æ·»åŠ åŸå¸‚é—´è¿æ¥

        Args:
            city1_id: ç¬¬ä¸€ä¸ªåŸå¸‚æ ‡è¯†
            city2_id: ç¬¬äºŒä¸ªåŸå¸‚æ ‡è¯†
            cost_per_unit: å•ä½è·ç¦»æˆæœ¬
            difficulty_factor: åœ°å½¢éš¾åº¦ç³»æ•°
        """
        distance = self.calculate_distance(city1_id, city2_id)

        # è€ƒè™‘åŸå¸‚é‡è¦æ€§å’Œåœ°å½¢å› ç´ 
        importance_adjustment = (self.cities[city1_id]['importance'] +
                               self.cities[city2_id]['importance']) / 2
        total_cost = distance * cost_per_unit * difficulty_factor / importance_adjustment

        self.network_graph.add_edge(city1_id, city2_id, total_cost)

    def design_optimal_network(self, algorithm: str = 'kruskal') -> Dict:
        """è®¾è®¡æœ€ä¼˜ç½‘ç»œ

        Args:
            algorithm: ä½¿ç”¨çš„MSTç®—æ³• ('kruskal', 'prim', 'boruvka')

        Returns:
            ç½‘ç»œè®¾è®¡ç»“æœ
        """
        # é€‰æ‹©ç®—æ³•
        if algorithm == 'kruskal':
            mst_edges, total_cost = kruskal_mst(self.network_graph)
        elif algorithm == 'prim':
            mst_edges, total_cost = prim_mst(self.network_graph)
        elif algorithm == 'boruvka':
            mst_edges, total_cost = boruvka_mst(self.network_graph)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„ç®—æ³•: {algorithm}")

        # æ„å»ºç½‘ç»œè®¾è®¡ç»“æœ
        network_design = []
        for u, v, cost in mst_edges:
            network_design.append({
                'from': self.cities[u]['name'],
                'to': self.cities[v]['name'],
                'cost': cost,
                'distance': self.calculate_distance(u, v),
                'from_importance': self.cities[u]['importance'],
                'to_importance': self.cities[v]['importance']
            })

        result = {
            'algorithm': algorithm,
            'total_cost': total_cost,
            'total_distance': sum(item['distance'] for item in network_design),
            'connections': network_design,
            'cities_connected': len(self.cities),
            'average_connection_cost': total_cost / len(network_design) if network_design else 0
        }

        self.optimization_history.append(result)
        return result

    def design_redundant_network(self, redundancy_level: int = 1) -> Dict:
        """è®¾è®¡å†—ä½™ç½‘ç»œ

        ä½¿ç”¨æ¬¡å°ç”Ÿæˆæ ‘æä¾›å†—ä½™è¿æ¥

        Args:
            redundancy_level: å†—ä½™çº§åˆ«ï¼ˆ1-é¢å¤–ä¸€æ¡è·¯å¾„ï¼Œ2-é¢å¤–ä¸¤æ¡è·¯å¾„ç­‰ï¼‰

        Returns:
            å†—ä½™ç½‘ç»œè®¾è®¡ç»“æœ
        """
        # ä¸»ç½‘ç»œ
        primary_result = self.design_optimal_network()

        # å†—ä½™ç½‘ç»œ
        backup_networks = []
        current_graph = UndirectedWeightedGraph()

        # å¤åˆ¶åŸå§‹å›¾
        for vertex in self.network_graph.get_vertices():
            current_graph.add_vertex(vertex)
        for edge in self.network_graph.get_edges():
            current_graph.add_edge(*edge)

        # ç§»é™¤ä¸»ç½‘ç»œè¾¹
        for u, v, cost in primary_result['connections']:
            for edge in current_graph.get_edges():
                if (edge[0] == u and edge[1] == v) or (edge[0] == v and edge[1] == u):
                    current_graph.remove_edge(*edge)
                    break

        # æ„å»ºå†—ä½™ç½‘ç»œ
        for i in range(redundancy_level):
            if current_graph.is_connected():
                backup_edges, backup_cost = kruskal_mst(current_graph)
                backup_design = []

                for u, v, cost in backup_edges:
                    backup_design.append({
                        'from': self.cities[u]['name'],
                        'to': self.cities[v]['name'],
                        'cost': cost,
                        'distance': self.calculate_distance(u, v)
                    })
                    # ç§»é™¤å·²ä½¿ç”¨çš„è¾¹
                    for edge in current_graph.get_edges():
                        if (edge[0] == u and edge[1] == v) or (edge[0] == v and edge[1] == u):
                            current_graph.remove_edge(*edge)
                            break

                backup_networks.append({
                    'backup_level': i + 1,
                    'cost': backup_cost,
                    'connections': backup_design
                })
            else:
                break

        return {
            'primary_network': primary_result,
            'backup_networks': backup_networks,
            'total_redundancy_cost': sum(net['cost'] for net in backup_networks),
            'reliability_score': self._calculate_reliability_score(primary_result, backup_networks)
        }

    def _calculate_reliability_score(self, primary: Dict, backups: List[Dict]) -> float:
        """è®¡ç®—ç½‘ç»œå¯é æ€§è¯„åˆ†

        Args:
            primary: ä¸»ç½‘ç»œ
            backups: å¤‡ä»½ç½‘ç»œåˆ—è¡¨

        Returns:
            å¯é æ€§è¯„åˆ† (0-1)
        """
        base_reliability = 0.95  # ä¸»ç½‘ç»œåŸºç¡€å¯é æ€§
        backup_bonus = 0.03 * len(backups)  # æ¯ä¸ªå¤‡ä»½ç½‘ç»œæå‡3%

        return min(base_reliability + backup_bonus, 0.99)

    def compare_algorithms(self) -> Dict:
        """æ¯”è¾ƒä¸åŒç®—æ³•çš„æ€§èƒ½

        Returns:
            å„ç®—æ³•çš„æ¯”è¾ƒç»“æœ
        """
        algorithms = ['kruskal', 'prim', 'boruvka']
        results = {}

        for algo in algorithms:
            import time
            start_time = time.time()
            try:
                result = self.design_optimal_network(algo)
                end_time = time.time()
                results[algo] = {
                    'success': True,
                    'cost': result['total_cost'],
                    'time': end_time - start_time,
                    'connections': len(result['connections'])
                }
            except Exception as e:
                results[algo] = {
                    'success': False,
                    'error': str(e)
                }

        return {
            'comparison': results,
            'recommendation': self._recommend_algorithm(results)
        }

    def _recommend_algorithm(self, results: Dict) -> str:
        """æ¨èæœ€é€‚åˆçš„ç®—æ³•

        Args:
            results: å„ç®—æ³•ç»“æœ

        Returns:
            æ¨èçš„ç®—æ³•åç§°
        """
        successful = {k: v for k, v in results.items() if v['success']}

        if not successful:
            return 'none'

        # æ ¹æ®ç½‘ç»œè§„æ¨¡æ¨è
        num_vertices = len(self.cities)
        num_edges = len(self.network_graph.get_edges())

        if num_edges > num_vertices * 2:  # ç¨ å¯†å›¾
            return 'prim'
        elif num_vertices > 1000:  # å¤§è§„æ¨¡å›¾
            return 'boruvka'
        else:  # ä¸€èˆ¬æƒ…å†µ
            return 'kruskal'`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

### 2. èšç±»åˆ†æåº”ç”¨

<CodeBlock
  title="åŸºäºMSTçš„èšç±»ç®—æ³•"
  code={`class MSTCluster:
    """åŸºäºæœ€å°ç”Ÿæˆæ ‘çš„èšç±»ç®—æ³•

    é€šè¿‡æ„å»ºæ•°æ®ç‚¹é—´çš„ç›¸ä¼¼åº¦å›¾ï¼Œç„¶åä½¿ç”¨MSTè¿›è¡Œèšç±»
    é€‚ç”¨äºå‘ç°è‡ªç„¶çš„æ•°æ®åˆ†ç»„ç»“æ„
    """

    def __init__(self, data_points: List[List[float]],
                 distance_metric: str = 'euclidean'):
        """åˆå§‹åŒ–èšç±»å™¨

        Args:
            data_points: æ•°æ®ç‚¹åˆ—è¡¨ï¼Œæ¯ä¸ªç‚¹æ˜¯ä¸€ä¸ªå‘é‡
            distance_metric: è·ç¦»åº¦é‡æ–¹å¼ ('euclidean', 'manhattan', 'cosine')
        """
        self.data_points = data_points
        self.distance_metric = distance_metric
        self.graph = self._build_similarity_graph()
        self.clustering_history = []

    def _build_similarity_graph(self) -> UndirectedWeightedGraph:
        """æ„å»ºç›¸ä¼¼åº¦å›¾

        æ¯ä¸ªæ•°æ®ç‚¹ä½œä¸ºé¡¶ç‚¹ï¼Œç‚¹é—´è·ç¦»ä½œä¸ºè¾¹æƒé‡

        Returns:
            ç›¸ä¼¼åº¦å›¾
        """
        graph = UndirectedWeightedGraph()

        # æ·»åŠ é¡¶ç‚¹
        for i, point in enumerate(self.data_points):
            graph.add_vertex(f"P{i}")

        # æ·»åŠ è¾¹ï¼ˆä½¿ç”¨æŒ‡å®šè·ç¦»åº¦é‡ï¼‰
        for i in range(len(self.data_points)):
            for j in range(i + 1, len(self.data_points)):
                distance = self._calculate_distance(
                    self.data_points[i],
                    self.data_points[j]
                )
                graph.add_edge(f"P{i}", f"P{j}", distance)

        return graph

    def _calculate_distance(self, point1: List[float], point2: List[float]) -> float:
        """è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»

        Args:
            point1: ç¬¬ä¸€ä¸ªç‚¹
            point2: ç¬¬äºŒä¸ªç‚¹

        Returns:
            è·ç¦»å€¼
        """
        if self.distance_metric == 'euclidean':
            return sum((a - b)**2 for a, b in zip(point1, point2))**0.5
        elif self.distance_metric == 'manhattan':
            return sum(abs(a - b) for a, b in zip(point1, point2))
        elif self.distance_metric == 'cosine':
            dot_product = sum(a * b for a, b in zip(point1, point2))
            norm1 = sum(a**2 for a in point1)**0.5
            norm2 = sum(b**2 for b in point2)**0.5
            if norm1 == 0 or norm2 == 0:
                return 1.0
            return 1.0 - dot_product / (norm1 * norm2)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„è·ç¦»åº¦é‡: {self.distance_metric}")

    def cluster(self, n_clusters: int,
                method: str = 'cut_max_edges') -> List[List[int]]:
        """èšç±»åˆ°æŒ‡å®šæ•°é‡

        Args:
            n_clusters: ç›®æ ‡èšç±»æ•°é‡
            method: èšç±»æ–¹æ³• ('cut_max_edges', 'cut_threshold')

        Returns:
            èšç±»ç»“æœåˆ—è¡¨ï¼Œæ¯ä¸ªå­åˆ—è¡¨åŒ…å«æ•°æ®ç‚¹ç´¢å¼•
        """
        # æ„å»ºMST
        mst_edges, _ = kruskal_mst(self.graph)

        if method == 'cut_max_edges':
            return self._cluster_by_cutting_edges(mst_edges, n_clusters)
        elif method == 'cut_threshold':
            return self._cluster_by_threshold(mst_edges, n_clusters)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„èšç±»æ–¹æ³•: {method}")

    def _cluster_by_cutting_edges(self, mst_edges: List[Tuple],
                                 n_clusters: int) -> List[List[int]]:
        """é€šè¿‡åˆ‡æ–­æœ€å¤§è¾¹è¿›è¡Œèšç±»

        ç§»é™¤MSTä¸­æƒé‡æœ€å¤§çš„n_clusters-1æ¡è¾¹

        Args:
            mst_edges: MSTè¾¹åˆ—è¡¨
            n_clusters: ç›®æ ‡èšç±»æ•°é‡

        Returns:
            èšç±»ç»“æœ
        """
        # æŒ‰æƒé‡æ’åºè¾¹ï¼ˆé™åºï¼‰
        sorted_edges = sorted(mst_edges, key=lambda x: x[2], reverse=True)

        # ç§»é™¤æƒé‡æœ€å¤§çš„n_clusters-1æ¡è¾¹
        temp_graph = UndirectedWeightedGraph()
        for vertex in self.graph.get_vertices():
            temp_graph.add_vertex(vertex)

        # æ·»åŠ å‰©ä½™çš„è¾¹
        edges_to_keep = sorted_edges[n_clusters-1:] if n_clusters > 1 else sorted_edges
        for u, v, weight in edges_to_keep:
            temp_graph.add_edge(u, v, weight)

        # æ‰¾åˆ°è¿é€šåˆ†é‡
        components = self._find_connected_components(temp_graph)

        # è½¬æ¢ä¸ºæ•°æ®ç‚¹ç´¢å¼•
        result = []
        for component in components:
            indices = [int(point[1:]) for point in component]
            result.append(indices)

        # è®°å½•èšç±»å†å²
        self.clustering_history.append({
            'method': 'cut_max_edges',
            'n_clusters': n_clusters,
            'clusters': len(components),
            'cut_edges': n_clusters - 1
        })

        return result

    def _cluster_by_threshold(self, mst_edges: List[Tuple],
                             n_clusters: int) -> List[List[int]]:
        """é€šè¿‡é˜ˆå€¼è¿›è¡Œèšç±»

        åŠ¨æ€æ‰¾åˆ°åˆé€‚çš„åˆ‡æ–­é˜ˆå€¼

        Args:
            mst_edges: MSTè¾¹åˆ—è¡¨
            n_clusters: ç›®æ ‡èšç±»æ•°é‡

        Returns:
            èšç±»ç»“æœ
        """
        # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°åˆé€‚çš„é˜ˆå€¼
        weights = [weight for _, _, weight in mst_edges]
        weights.sort()

        left, right = 0, len(weights) - 1
        best_threshold = weights[-1]

        while left <= right:
            mid = (left + right) // 2
            threshold = weights[mid]

            # ä¸´æ—¶å›¾ï¼šåªä¿ç•™æƒé‡å°äºé˜ˆå€¼çš„è¾¹
            temp_graph = UndirectedWeightedGraph()
            for vertex in self.graph.get_vertices():
                temp_graph.add_vertex(vertex)

            for u, v, weight in mst_edges:
                if weight <= threshold:
                    temp_graph.add_edge(u, v, weight)

            components = self._find_connected_components(temp_graph)

            if len(components) >= n_clusters:
                best_threshold = threshold
                right = mid - 1
            else:
                left = mid + 1

        # ä½¿ç”¨æœ€ä½³é˜ˆå€¼è¿›è¡Œæœ€ç»ˆèšç±»
        final_graph = UndirectedWeightedGraph()
        for vertex in self.graph.get_vertices():
            final_graph.add_vertex(vertex)

        for u, v, weight in mst_edges:
            if weight <= best_threshold:
                final_graph.add_edge(u, v, weight)

        components = self._find_connected_components(final_graph)

        # è½¬æ¢ä¸ºæ•°æ®ç‚¹ç´¢å¼•
        result = []
        for component in components:
            indices = [int(point[1:]) for point in component]
            result.append(indices)

        self.clustering_history.append({
            'method': 'cut_threshold',
            'n_clusters': n_clusters,
            'clusters': len(components),
            'threshold': best_threshold
        })

        return result

    def _find_connected_components(self, graph: UndirectedWeightedGraph) -> List[List[str]]:
        """æŸ¥æ‰¾è¿é€šåˆ†é‡

        Args:
            graph: å›¾å¯¹è±¡

        Returns:
            è¿é€šåˆ†é‡åˆ—è¡¨
        """
        visited = set()
        components = []

        def dfs(vertex: str, component: List[str]) -> None:
            """æ·±åº¦ä¼˜å…ˆæœç´¢"""
            visited.add(vertex)
            component.append(vertex)
            for neighbor, _ in graph.get_neighbors(vertex):
                if neighbor not in visited:
                    dfs(neighbor, component)

        for vertex in graph.get_vertices():
            if vertex not in visited:
                component = []
                dfs(vertex, component)
                components.append(component)

        return components

    def find_optimal_clusters(self, max_clusters: int = 10) -> Dict:
        """æ‰¾åˆ°æœ€ä¼˜èšç±»æ•°é‡

        ä½¿ç”¨è‚˜éƒ¨æ³•åˆ™å’Œè½®å»“ç³»æ•°è¯„ä¼°

        Args:
            max_clusters: æœ€å¤§èšç±»æ•°é‡

        Returns:
            æœ€ä¼˜èšç±»åˆ†æç»“æœ
        """
        results = []

        for k in range(2, min(max_clusters + 1, len(self.data_points))):
            # æ‰§è¡Œèšç±»
            clusters = self.cluster(k)

            # è®¡ç®—è¯„ä¼°æŒ‡æ ‡
            silhouette_score = self._calculate_silhouette_score(clusters)
            within_cluster_variance = self._calculate_within_cluster_variance(clusters)

            results.append({
                'k': k,
                'silhouette_score': silhouette_score,
                'within_cluster_variance': within_cluster_variance,
                'clusters': clusters
            })

        # æ‰¾åˆ°æœ€ä¼˜kå€¼
        optimal_k = self._find_elbow_point(results)

        return {
            'optimal_k': optimal_k,
            'analysis': results,
            'recommendation': f"å»ºè®®èšç±»æ•°é‡: {optimal_k}"
        }

    def _calculate_silhouette_score(self, clusters: List[List[int]]) -> float:
        """è®¡ç®—è½®å»“ç³»æ•°

        Args:
            clusters: èšç±»ç»“æœ

        Returns:
            è½®å»“ç³»æ•° (-1åˆ°1)
        """
        total_score = 0
        total_points = 0

        for cluster_idx, cluster in enumerate(clusters):
            for point_idx in cluster:
                # è®¡ç®—ç‚¹ä¸å…¶æ‰€åœ¨ç°‡çš„ç´§å¯†åº¦
                if len(cluster) > 1:
                    a = sum(self._calculate_distance(
                        self.data_points[point_idx],
                        self.data_points[other_idx]
                    ) for other_idx in cluster if other_idx != point_idx) / (len(cluster) - 1)
                else:
                    a = 0

                # è®¡ç®—ç‚¹ä¸å…¶ä»–ç°‡çš„åˆ†ç¦»åº¦
                b = float('inf')
                for other_cluster_idx, other_cluster in enumerate(clusters):
                    if other_cluster_idx != cluster_idx:
                        other_cluster_distance = sum(self._calculate_distance(
                            self.data_points[point_idx],
                            self.data_points[other_idx]
                        ) for other_idx in other_cluster) / len(other_cluster)
                        b = min(b, other_cluster_distance)

                if max(a, b) > 0:
                    silhouette = (b - a) / max(a, b)
                    total_score += silhouette
                    total_points += 1

        return total_score / total_points if total_points > 0 else 0

    def _calculate_within_cluster_variance(self, clusters: List[List[int]]) -> float:
        """è®¡ç®—ç°‡å†…æ–¹å·®

        Args:
            clusters: èšç±»ç»“æœ

        Returns:
            ç°‡å†…æ€»æ–¹å·®
        """
        total_variance = 0

        for cluster in clusters:
            if len(cluster) > 1:
                # è®¡ç®—ç°‡ä¸­å¿ƒ
                centroid = [0.0] * len(self.data_points[cluster[0]])
                for point_idx in cluster:
                    for i, coord in enumerate(self.data_points[point_idx]):
                        centroid[i] += coord
                centroid = [coord / len(cluster) for coord in centroid]

                # è®¡ç®—ç°‡å†…æ–¹å·®
                cluster_variance = 0
                for point_idx in cluster:
                    distance = self._calculate_distance(
                        self.data_points[point_idx],
                        centroid
                    )
                    cluster_variance += distance ** 2

                total_variance += cluster_variance

        return total_variance

    def _find_elbow_point(self, results: List[Dict]) -> int:
        """ä½¿ç”¨è‚˜éƒ¨æ³•åˆ™æ‰¾åˆ°æœ€ä¼˜kå€¼

        Args:
            results: èšç±»åˆ†æç»“æœ

        Returns:
            æœ€ä¼˜kå€¼
        """
        if len(results) < 3:
            return 2

        # è®¡ç®—äºŒæ¬¡å·®åˆ†
        variances = [r['within_cluster_variance'] for r in results]
        second_diffs = []

        for i in range(1, len(variances) - 1):
            second_diff = abs(variances[i-1] - 2*variances[i] + variances[i+1])
            second_diffs.append(second_diff)

        # æ‰¾åˆ°æœ€å¤§äºŒæ¬¡å·®åˆ†ç‚¹
        max_diff_idx = second_diffs.index(max(second_diffs))
        return results[max_diff_idx + 1]['k']

    def visualize_clusters(self, clusters: List[List[int]]) -> str:
        """ç”Ÿæˆèšç±»å¯è§†åŒ–æè¿°

        Args:
            clusters: èšç±»ç»“æœ

        Returns:
            å¯è§†åŒ–æè¿°å­—ç¬¦ä¸²
        """
        description = []
        description.append(f"èšç±»ç»“æœ: {len(clusters)} ä¸ªç°‡")

        for i, cluster in enumerate(clusters):
            cluster_size = len(cluster)
            if cluster_size > 0:
                # è®¡ç®—ç°‡çš„ä¸­å¿ƒç‚¹
                centroid = [0.0] * len(self.data_points[cluster[0]])
                for point_idx in cluster:
                    for j, coord in enumerate(self.data_points[point_idx]):
                        centroid[j] += coord
                centroid = [coord / cluster_size for coord in centroid]

                # è®¡ç®—ç°‡çš„åŠå¾„
                max_distance = max(
                    self._calculate_distance(self.data_points[point_idx], centroid)
                    for point_idx in cluster
                )

                description.append(f"ç°‡ {i+1}: {cluster_size} ä¸ªç‚¹")
                description.append(f"  ä¸­å¿ƒ: {[round(x, 2) for x in centroid]}")
                description.append(f"  åŠå¾„: {round(max_distance, 2)}")

        return "\\n".join(description)`}
  language="python"
  editable={true}
  showLineNumbers={true}
/>

## äº¤äº’å¼æ¼”ç¤º

### Kruskalç®—æ³•æ­¥éª¤æ¼”ç¤º

<AlgorithmVisualizer
  title="Kruskalç®—æ³•äº¤äº’å¼æ¼”ç¤º"
  algorithm="kruskal-demo"
  steps={[
    {
      title: "åˆå§‹åŒ–",
      content: "åˆ›å»ºå¹¶æŸ¥é›†ç»“æ„ï¼Œæ¯ä¸ªé¡¶ç‚¹éƒ½æ˜¯ç‹¬ç«‹çš„é›†åˆ",
      code: "union_find = UnionFind(vertices)"
    },
    {
      title: "è¾¹æ’åº",
      content: "æŒ‰æƒé‡å‡åºæ’åºæ‰€æœ‰è¾¹",
      code: "edges = sorted(graph.get_edges(), key=lambda x: x[2])"
    },
    {
      title: "è´ªå¿ƒé€‰æ‹©",
      content: "ä¾æ¬¡é€‰æ‹©æœ€å°æƒé‡è¾¹ï¼Œè‹¥ä¸å½¢æˆç¯åˆ™åŠ å…¥MST",
      code: "if union_find.find(u) != union_find.find(v):\\n    union_find.union(u, v)\\n    mst_edges.append((u, v, weight))"
    },
    {
      title: "å®Œæˆæ¡ä»¶",
      content: "å½“MSTåŒ…å«V-1æ¡è¾¹æ—¶ç®—æ³•å®Œæˆ",
      code: "if len(mst_edges) == len(vertices) - 1:\\n    break"
    }
  ]}
/>

### ç®—æ³•æ€§èƒ½æ¯”è¾ƒ

<ComplexityAnalyzer
  title="ä¸‰ç§MSTç®—æ³•æ€§èƒ½å¯¹æ¯”"
  description="åœ¨ä¸åŒå›¾è§„æ¨¡ä¸‹æ¯”è¾ƒKruskalã€Primå’ŒBorÅ¯vkaç®—æ³•çš„æ€§èƒ½"
  data={[
    {
      size: "50é¡¶ç‚¹, 100è¾¹",
      kruskal: 0.0012,
      prim: 0.0008,
      boruvka: 0.0015
    },
    {
      size: "100é¡¶ç‚¹, 300è¾¹",
      kruskal: 0.0034,
      prim: 0.0021,
      boruvka: 0.0038
    },
    {
      size: "500é¡¶ç‚¹, 1500è¾¹",
      kruskal: 0.028,
      prim: 0.015,
      boruvka: 0.032
    },
    {
      size: "1000é¡¶ç‚¹, 5000è¾¹",
      kruskal: 0.089,
      prim: 0.042,
      boruvka: 0.095
    }
  ]}
/>

## å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®ç°ç½‘ç»œä¼˜åŒ–å™¨

<ExerciseBlock
  title="ç½‘ç»œä¼˜åŒ–å™¨å®ç°"
  description="å®ç°ä¸€ä¸ªç½‘ç»œä¼˜åŒ–å™¨ï¼Œä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ä¼˜åŒ–åŸå¸‚é—´çš„è¿æ¥æˆæœ¬ã€‚"
  difficulty="ä¸­ç­‰"
  type="coding"
  initialCode={`# TODO: å®ç°ç½‘ç»œä¼˜åŒ–å™¨ç±»
class NetworkOptimizer:
    def __init__(self):
        self.cities = {}
        self.connections = []

    def add_city(self, name, x, y, population=0):
        # æ·»åŠ åŸå¸‚åˆ°ç½‘ç»œ
        pass

    def add_connection(self, city1, city2, cost_per_km):
        # æ·»åŠ åŸå¸‚é—´è¿æ¥
        pass

    def optimize_network(self, budget_limit=None):
        # ä½¿ç”¨MSTç®—æ³•ä¼˜åŒ–ç½‘ç»œï¼Œè€ƒè™‘é¢„ç®—é™åˆ¶
        pass`}
  expectedOutput="è¿”å›ä¼˜åŒ–åçš„ç½‘ç»œè®¾è®¡æ–¹æ¡ˆï¼ŒåŒ…æ‹¬è¿æ¥åˆ—è¡¨å’Œæ€»æˆæœ¬"
  solution={`class NetworkOptimizer:
    def __init__(self):
        self.cities = {}
        self.connections = []
        self.graph = UndirectedWeightedGraph()

    def add_city(self, name, x, y, population=0):
        self.cities[name] = {'x': x, 'y': y, 'population': population}
        self.graph.add_vertex(name)

    def add_connection(self, city1, city2, cost_per_km):
        city1_info = self.cities[city1]
        city2_info = self.cities[city2]
        distance = ((city1_info['x'] - city2_info['x'])**2 +
                   (city1_info['y'] - city2_info['y'])**2)**0.5
        total_cost = distance * cost_per_km
        self.graph.add_edge(city1, city2, total_cost)
        self.connections.append((city1, city2, total_cost))

    def optimize_network(self, budget_limit=None):
        # ä½¿ç”¨Kruskalç®—æ³•æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘
        mst_edges, total_cost = kruskal_mst(self.graph)

        if budget_limit and total_cost > budget_limit:
            # å¦‚æœè¶…å‡ºé¢„ç®—ï¼Œéœ€è¦è°ƒæ•´ç­–ç•¥
            return self._optimize_with_budget(budget_limit)

        return {
            'connections': mst_edges,
            'total_cost': total_cost,
            'within_budget': budget_limit is None or total_cost <= budget_limit
        }

    def _optimize_with_budget(self, budget_limit):
        # é¢„ç®—é™åˆ¶ä¸‹çš„ä¼˜åŒ–ç­–ç•¥
        sorted_edges = sorted(self.connections, key=lambda x: x[2])
        selected_edges = []
        total_cost = 0
        union_find = UnionFind(self.cities.keys())

        for edge in sorted_edges:
            if total_cost + edge[2] <= budget_limit:
                if union_find.find(edge[0]) != union_find.find(edge[1]):
                    union_find.union(edge[0], edge[1])
                    selected_edges.append(edge)
                    total_cost += edge[2]

        return {
            'connections': selected_edges,
            'total_cost': total_cost,
            'within_budget': True,
            'note': f'é¢„ç®—é™åˆ¶ä¸‹çš„éƒ¨åˆ†ä¼˜åŒ–ï¼Œè¿æ¥äº†{len(selected_edges)}ä¸ªåŸå¸‚'
        }`}
/>

### ç»ƒä¹ 2ï¼šèšç±»åˆ†æå™¨

<ExerciseBlock
  title="èšç±»åˆ†æå™¨å®ç°"
  description="å®ç°ä¸€ä¸ªåŸºäºMSTçš„æ•°æ®èšç±»åˆ†æå™¨ï¼Œèƒ½å¤Ÿè‡ªåŠ¨ç¡®å®šæœ€ä¼˜èšç±»æ•°é‡ã€‚"
  difficulty="å›°éš¾"
  type="coding"
  initialCode={`# TODO: å®ç°MSTèšç±»åˆ†æå™¨
class MSTClusterAnalyzer:
    def __init__(self, data_points):
        self.data_points = data_points
        self.distance_matrix = self._compute_distance_matrix()

    def _compute_distance_matrix(self):
        # è®¡ç®—ç‚¹é—´è·ç¦»çŸ©é˜µ
        pass

    def find_optimal_clusters(self, max_k=10):
        # ä½¿ç”¨è‚˜éƒ¨æ³•åˆ™æ‰¾åˆ°æœ€ä¼˜èšç±»æ•°é‡
        pass

    def cluster_data(self, k):
        # å°†æ•°æ®èšç±»ä¸ºkä¸ªç°‡
        pass`}
  expectedOutput="è¿”å›èšç±»ç»“æœå’Œæœ€ä¼˜èšç±»æ•°é‡åˆ†æ"
  solution={`class MSTClusterAnalyzer:
    def __init__(self, data_points):
        self.data_points = data_points
        self.distance_matrix = self._compute_distance_matrix()
        self.clustering_history = []

    def _compute_distance_matrix(self):
        n = len(self.data_points)
        matrix = [[0] * n for _ in range(n)]

        for i in range(n):
            for j in range(i + 1, n):
                distance = sum((a - b)**2 for a, b in
                              zip(self.data_points[i], self.data_points[j]))**0.5
                matrix[i][j] = matrix[j][i] = distance

        return matrix

    def find_optimal_clusters(self, max_k=10):
        # è®¡ç®—ä¸åŒkå€¼çš„èšç±»è´¨é‡
        k_values = range(2, min(max_k + 1, len(self.data_points)))
        variances = []

        for k in k_values:
            clusters = self.cluster_data(k)
            variance = self._compute_within_cluster_variance(clusters)
            variances.append(variance)

        # ä½¿ç”¨è‚˜éƒ¨æ³•åˆ™
        optimal_k = self._find_elbow_point(k_values, variances)

        return {
            'optimal_k': optimal_k,
            'variances': list(zip(k_values, variances)),
            'elbow_analysis': self._analyze_elbow(k_values, variances)
        }

    def cluster_data(self, k):
        # æ„å»ºå®Œå…¨å›¾
        graph = UndirectedWeightedGraph()
        for i in range(len(self.data_points)):
            graph.add_vertex(str(i))

        for i in range(len(self.data_points)):
            for j in range(i + 1, len(self.data_points)):
                graph.add_edge(str(i), str(j), self.distance_matrix[i][j])

        # æ„å»ºMST
        mst_edges, _ = kruskal_mst(graph)

        # ç§»é™¤k-1æ¡æœ€é•¿çš„è¾¹
        sorted_edges = sorted(mst_edges, key=lambda x: x[2], reverse=True)
        edges_to_keep = sorted_edges[k-1:] if k > 1 else sorted_edges

        # æ„å»ºèšç±»å›¾
        cluster_graph = UndirectedWeightedGraph()
        for i in range(len(self.data_points)):
            cluster_graph.add_vertex(str(i))

        for u, v, weight in edges_to_keep:
            cluster_graph.add_edge(u, v, weight)

        # æ‰¾åˆ°è¿é€šåˆ†é‡
        return self._find_connected_components(cluster_graph)

    def _compute_within_cluster_variance(self, clusters):
        total_variance = 0
        for cluster in clusters:
            if len(cluster) > 1:
                # è®¡ç®—ç°‡ä¸­å¿ƒ
                centroid = [0] * len(self.data_points[int(cluster[0])])
                for point_str in cluster:
                    point_idx = int(point_str)
                    for i, coord in enumerate(self.data_points[point_idx]):
                        centroid[i] += coord
                centroid = [coord / len(cluster) for coord in centroid]

                # è®¡ç®—æ–¹å·®
                cluster_variance = 0
                for point_str in cluster:
                    point_idx = int(point_str)
                    distance = sum((a - b)**2 for a, b in
                                 zip(self.data_points[point_idx], centroid))**0.5
                    cluster_variance += distance ** 2
                total_variance += cluster_variance

        return total_variance

    def _find_elbow_point(self, k_values, variances):
        if len(variances) < 3:
            return k_values[0]

        # è®¡ç®—è§’åº¦å˜åŒ–
        angles = []
        for i in range(1, len(variances) - 1):
            v1 = variances[i-1] - variances[i]
            v2 = variances[i] - variances[i+1]
            if v1 > 0 and v2 > 0:
                angle = abs(v2 - v1) / ((v1 + v2) / 2)
                angles.append(angle)
            else:
                angles.append(0)

        # æ‰¾åˆ°æœ€å¤§è§’åº¦å˜åŒ–ç‚¹
        if angles:
            max_angle_idx = angles.index(max(angles))
            return k_values[max_angle_idx + 1]

        return k_values[0]

    def _find_connected_components(self, graph):
        visited = set()
        components = []

        def dfs(vertex, component):
            visited.add(vertex)
            component.append(vertex)
            for neighbor, _ in graph.get_neighbors(vertex):
                if neighbor not in visited:
                    dfs(neighbor, component)

        for vertex in graph.get_vertices():
            if vertex not in visited:
                component = []
                dfs(vertex, component)
                components.append(component)

        return components`}
/>

## æ€»ç»“ä¸è¦ç‚¹

### æ ¸å¿ƒæ¦‚å¿µå›é¡¾

1. **æœ€å°ç”Ÿæˆæ ‘å®šä¹‰**: åŒ…å«æ‰€æœ‰é¡¶ç‚¹çš„æ— ç¯è¿é€šå­å›¾ï¼Œä¸”æƒé‡å’Œæœ€å°
2. **åˆ‡å‰²æ€§è´¨**: ä»»ä½•åˆ‡å‰²çš„æœ€å°æƒé‡è¾¹éƒ½å±äºæŸä¸ªMST
3. **ä¸‰ç§ç»å…¸ç®—æ³•**: Kruskalï¼ˆé€‚åˆç¨€ç–å›¾ï¼‰ã€Primï¼ˆé€‚åˆç¨ å¯†å›¾ï¼‰ã€BorÅ¯vkaï¼ˆé€‚åˆå¹¶è¡Œï¼‰
4. **åº”ç”¨é¢†åŸŸ**: ç½‘ç»œè®¾è®¡ã€èšç±»åˆ†æã€ç”µè·¯è®¾è®¡ã€å›¾åƒåˆ†å‰²ç­‰

### ç®—æ³•é€‰æ‹©æŒ‡å—

- **Kruskalç®—æ³•**: å®ç°ç®€å•ï¼Œé€‚åˆè¾¹æ•°ç›¸å¯¹è¾ƒå°‘çš„ç¨€ç–å›¾
- **Primç®—æ³•**: ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé€‚åˆè¾¹æ•°è¾ƒå¤šçš„ç¨ å¯†å›¾
- **BorÅ¯vkaç®—æ³•**: åˆ†è½®æ¬¡å¤„ç†ï¼Œå¤©ç„¶é€‚åˆå¹¶è¡ŒåŒ–å®ç°

### å®é™…åº”ç”¨è¦ç‚¹

- è€ƒè™‘ç½‘ç»œçš„å†—ä½™æ€§å’Œå¯é æ€§è®¾è®¡
- åœ¨èšç±»åˆ†æä¸­ç»“åˆè½®å»“ç³»æ•°ç­‰è¯„ä¼°æŒ‡æ ‡
- åŠ¨æ€å›¾ç¯å¢ƒä¸‹çš„MSTç»´æŠ¤ç­–ç•¥
- å¤§è§„æ¨¡å›¾å¤„ç†çš„ä¼˜åŒ–å’Œå¹¶è¡ŒåŒ–

## è¿›ä¸€æ­¥å­¦ä¹ 

### ç›¸å…³ç®—æ³•

- **Steineræ ‘é—®é¢˜**: å…è®¸æ·»åŠ é¢å¤–é¡¶ç‚¹çš„æœ€å°ç”Ÿæˆæ ‘
- **åº¦çº¦æŸæœ€å°ç”Ÿæˆæ ‘**: é™åˆ¶é¡¶ç‚¹åº¦æ•°çš„MSTå˜ç§
- **éšæœºæœ€å°ç”Ÿæˆæ ‘**: å¸¦éšæœºæ€§çš„MSTç®—æ³•
- **å¤šç»´MST**: å¤šç›®æ ‡ä¼˜åŒ–çš„æœ€å°ç”Ÿæˆæ ‘

### æ¨èèµ„æº

1. **ç®—æ³•å¯¼è®º** - ç¬¬23ç« ï¼šæœ€å°ç”Ÿæˆæ ‘
2. **ç½‘ç»œæµç†è®º** - ç›¸å…³ä¼˜åŒ–é—®é¢˜
3. **èšç±»åˆ†æ** - æ•°æ®æŒ–æ˜ä¸­çš„åº”ç”¨
4. **å¹¶è¡Œç®—æ³•è®¾è®¡** - å¤§è§„æ¨¡å›¾å¤„ç†æŠ€æœ¯

---

## è¯¾ç¨‹å¯¼èˆª

**ä¸Šä¸€è¯¾**: [L07 - æœ€çŸ­è·¯å¾„ç®—æ³•](/mit6006-algorithms/lectures/L07-shortest-path-algorithms)
**ä¸‹ä¸€è¯¾**: [L09 - åŠ¨æ€è§„åˆ’](/mit6006-algorithms/lectures/L09-dynamic-programming)
**è¯¾ç¨‹ä¸»é¡µ**: [MIT 6.006 ç®—æ³•å¯¼è®º](/mit6006-algorithms)