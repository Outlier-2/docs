---
title: "L02 - æ’åºç®—æ³•"
description: "æ·±å…¥ç†è§£å„ç§æ’åºç®—æ³•çš„åŸç†ã€å®ç°å’Œæ€§èƒ½åˆ†æ"
---

import { useState, useEffect } from 'react';
import { CodeBlock } from '@/src/components/algorithm';
import { AlgorithmVisualizer } from '@/src/components/algorithm';
import { ArrayVisualizer } from '@/src/components/algorithm';
import { ComplexityAnalyzer } from '@/src/components/algorithm';
import { ExerciseBlock } from '@/src/components/algorithm';

# L02 - æ’åºç®—æ³•

## ğŸ“š å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è®²ä¹‰åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ğŸ”„ **æŒæ¡æ’åºåŸç†**ï¼šç†è§£6ç§ç»å…¸æ’åºç®—æ³•çš„æ ¸å¿ƒæ€æƒ³
- âš¡ **åˆ†ææ€§èƒ½ç‰¹å¾**ï¼šè¯„ä¼°ä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
- ğŸ¯ **é€‰æ‹©æœ€ä¼˜ç®—æ³•**ï¼šæ ¹æ®æ•°æ®ç‰¹ç‚¹é€‰æ‹©æœ€é€‚åˆçš„æ’åºæ–¹æ³•
- ğŸ› ï¸ **å®ç°ä¼˜åŒ–ç­–ç•¥**ï¼šåº”ç”¨å„ç§ä¼˜åŒ–æŠ€æœ¯æå‡æ’åºæ€§èƒ½

## ğŸ¯ æ’åºç®—æ³•åˆ†ç±»

### æ¯”è¾ƒæ’åº vs éæ¯”è¾ƒæ’åº

| ç±»å‹ | ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç¨³å®šæ€§ | é€‚ç”¨åœºæ™¯ |
|------|------|------------|--------|----------|
| **æ¯”è¾ƒæ’åº** | æ’å…¥æ’åº | O(nÂ²) | âœ… ç¨³å®š | å°è§„æ¨¡/åŸºæœ¬æœ‰åº |
|  | å½’å¹¶æ’åº | O(n log n) | âœ… ç¨³å®š | å¤§è§„æ¨¡æ•°æ® |
|  | å¿«é€Ÿæ’åº | O(n log n) å¹³å‡ | âŒ ä¸ç¨³å®š | é€šç”¨æ’åº |
|  | å †æ’åº | O(n log n) | âŒ ä¸ç¨³å®š | å†…å­˜å—é™ |
| **éæ¯”è¾ƒæ’åº** | è®¡æ•°æ’åº | O(n+k) | âœ… ç¨³å®š | å°èŒƒå›´æ•´æ•° |
|  | åŸºæ•°æ’åº | O(d(n+k)) | âœ… ç¨³å®š | å›ºå®šé•¿åº¦æ•°æ® |

## ğŸ”§ æ¯”è¾ƒæ’åºç®—æ³•

### 1. æ’å…¥æ’åº (Insertion Sort)

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†å…ƒç´ é€ä¸ªæ’å…¥åˆ°å·²æ’åºéƒ¨åˆ†çš„æ­£ç¡®ä½ç½®

```python
def insertion_sort(arr: list) -> list:
    """
    æ’å…¥æ’åºç®—æ³•å®ç°
    æ—¶é—´å¤æ‚åº¦: O(nÂ²) æœ€åå’Œå¹³å‡æƒ…å†µ, O(n) æœ€å¥½æƒ…å†µ
    ç©ºé—´å¤æ‚åº¦: O(1) åŸåœ°æ’åº
    ç¨³å®šæ€§: ç¨³å®š
    é€‚ç”¨åœºæ™¯: å°è§„æ¨¡æ•°æ®æˆ–åŸºæœ¬æœ‰åºçš„æ•°æ®
    """
    for i in range(1, len(arr)):           # å¤–å±‚å¾ªç¯: n-1æ¬¡
        key = arr[i]                       # å½“å‰è¦æ’å…¥çš„å…ƒç´ 
        j = i - 1                          # å·²æ’åºéƒ¨åˆ†çš„æœ€åä¸€ä¸ªç´¢å¼•

        # å°†å¤§äºkeyçš„å…ƒç´ å‘åç§»åŠ¨
        while j >= 0 and arr[j] > key:     # å†…å±‚å¾ªç¯: æœ€å¤šiæ¬¡
            arr[j + 1] = arr[j]            # å…ƒç´ åç§»
            j -= 1                          # æŒ‡é’ˆå‰ç§»

        arr[j + 1] = key                   # æ’å…¥keyåˆ°æ­£ç¡®ä½ç½®

    return arr

# ä¼˜åŒ–ç‰ˆæœ¬ï¼šä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å‡å°‘æ¯”è¾ƒæ¬¡æ•°
def binary_insertion_sort(arr: list) -> list:
    """
    äºŒåˆ†æ’å…¥æ’åº - ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–æ’å…¥ä½ç½®æŸ¥æ‰¾
    æ¯”è¾ƒæ¬¡æ•°: O(n log n)ï¼Œç§»åŠ¨æ¬¡æ•°ä»ä¸º O(nÂ²)
    """
    for i in range(1, len(arr)):
        key = arr[i]

        # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°æ’å…¥ä½ç½®
        left, right = 0, i - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] <= key:
                left = mid + 1
            else:
                right = mid - 1

        # ç§»åŠ¨å…ƒç´ 
        for j in range(i - 1, left - 1, -1):
            arr[j + 1] = arr[j]

        arr[left] = key

    return arr
```

### 2. å½’å¹¶æ’åº (Merge Sort)

**æ ¸å¿ƒæ€æƒ³**ï¼šåˆ†æ²»ç­–ç•¥ - å…ˆåˆ†å‰²å†åˆå¹¶

```python
def merge_sort(arr: list) -> list:
    """
    å½’å¹¶æ’åº - åˆ†æ²»ç­–ç•¥çš„å…¸å‹åº”ç”¨
    æ—¶é—´å¤æ‚åº¦: O(n log n) æ‰€æœ‰æƒ…å†µ
    ç©ºé—´å¤æ‚åº¦: O(n) éœ€è¦é¢å¤–ç©ºé—´
    ç¨³å®šæ€§: âœ… ç¨³å®š
    """
    if len(arr) <= 1:
        return arr

    # åˆ†å‰²é˜¶æ®µ
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])      # é€’å½’æ’åºå·¦åŠéƒ¨åˆ†
    right = merge_sort(arr[mid:])     # é€’å½’æ’åºå³åŠéƒ¨åˆ†

    # åˆå¹¶é˜¶æ®µ
    return merge(left, right)

def merge(left: list, right: list) -> list:
    """
    åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„æ•°ç»„
    æ—¶é—´å¤æ‚åº¦: O(n)ï¼Œå…¶ä¸­n = len(left) + len(right)
    """
    result = []
    i = j = 0

    # æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å…ƒç´ 
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:       # ä¿æŒç¨³å®šæ€§
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # æ·»åŠ å‰©ä½™å…ƒç´ 
    result.extend(left[i:])           # å·¦æ•°ç»„å‰©ä½™å…ƒç´ 
    result.extend(right[j:])          # å³æ•°ç»„å‰©ä½™å…ƒç´ 

    return result

# åŸåœ°å½’å¹¶æ’åº - ç©ºé—´ä¼˜åŒ–ç‰ˆæœ¬
def in_place_merge_sort(arr: list) -> list:
    """
    åŸåœ°å½’å¹¶æ’åº - å‡å°‘ç©ºé—´å¤æ‚åº¦
    ä½†å®ç°å¤æ‚åº¦å¢åŠ ï¼Œå®é™…åº”ç”¨ä¸­è¾ƒå°‘ä½¿ç”¨
    """
    def merge_in_place(arr: list, start: int, mid: int, end: int):
        # åŸåœ°åˆå¹¶ç®—æ³•å®ç°è¾ƒä¸ºå¤æ‚
        # è¿™é‡Œä½¿ç”¨åŒæŒ‡é’ˆå’Œä¸´æ—¶æ•°ç»„
        temp = []
        left, right = start, mid + 1

        while left <= mid and right <= end:
            if arr[left] <= arr[right]:
                temp.append(arr[left])
                left += 1
            else:
                temp.append(arr[right])
                right += 1

        while left <= mid:
            temp.append(arr[left])
            left += 1

        while right <= end:
            temp.append(arr[right])
            right += 1

        for i, val in enumerate(temp):
            arr[start + i] = val

    def sort_helper(arr: list, start: int, end: int):
        if start < end:
            mid = (start + end) // 2
            sort_helper(arr, start, mid)
            sort_helper(arr, mid + 1, end)
            merge_in_place(arr, start, mid, end)

    sort_helper(arr, 0, len(arr) - 1)
    return arr
```

<ExerciseBlock
  title="å½’å¹¶æ’åºåˆ†æ"
  question="ä¸ºä»€ä¹ˆå½’å¹¶æ’åºçš„æ—¶é—´å¤æ‚åº¦æ€»æ˜¯O(n log n)ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "å› ä¸ºå®ƒä½¿ç”¨äº†åŸåœ°æ’åº",
      correct: false,
      explanation: "å½’å¹¶æ’åºéœ€è¦é¢å¤–ç©ºé—´ï¼Œä¸æ˜¯åŸåœ°æ’åº"
    },
    {
      id: "b",
      text: "å› ä¸ºæ¯æ¬¡é€’å½’éƒ½å°†æ•°ç»„åˆ†æˆä¸¤åŠï¼Œåˆå¹¶æ˜¯çº¿æ€§æ—¶é—´",
      correct: true,
      explanation: "æ­£ç¡®ï¼é€’å½’æ·±åº¦ä¸ºlog nï¼Œæ¯å±‚åˆå¹¶æ“ä½œä¸ºO(n)ï¼Œæ€»å¤æ‚åº¦ä¸ºO(n log n)"
    },
    {
      id: "c",
      text: "å› ä¸ºå®ƒä½¿ç”¨äº†äºŒåˆ†æŸ¥æ‰¾",
      correct: false,
      explanation: "å½’å¹¶æ’åºä¸ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾"
    },
    {
      id: "d",
      text: "å› ä¸ºå®ƒæ˜¯ç¨³å®šçš„æ’åºç®—æ³•",
      correct: false,
      explanation: "ç¨³å®šæ€§ä¸å½±å“æ—¶é—´å¤æ‚åº¦"
    }
  ]}
  hint="è€ƒè™‘é€’å½’æ ‘çš„ç»“æ„å’Œæ¯å±‚çš„æ“ä½œ"
/>

### 3. å¿«é€Ÿæ’åº (Quick Sort)

**æ ¸å¿ƒæ€æƒ³**ï¼šåˆ†åŒºç­–ç•¥ - é€‰æ‹©åŸºå‡†å…ƒç´ å°†æ•°ç»„åˆ†å‰²

```python
def quick_sort(arr: list) -> list:
    """
    å¿«é€Ÿæ’åº - åˆ†åŒºç­–ç•¥
    æ—¶é—´å¤æ‚åº¦: O(n log n) å¹³å‡æƒ…å†µ, O(nÂ²) æœ€åæƒ…å†µ
    ç©ºé—´å¤æ‚åº¦: O(log n) é€’å½’æ ˆç©ºé—´
    ç¨³å®šæ€§: âŒ ä¸ç¨³å®š
    """
    def partition(arr: list, low: int, high: int) -> int:
        """
        åˆ†åŒºå‡½æ•° - é€‰æ‹©åŸºå‡†å…ƒç´ å¹¶åˆ†å‰²æ•°ç»„
        è¿”å›åŸºå‡†å…ƒç´ çš„æœ€ç»ˆä½ç½®
        """
        pivot = arr[high]              # é€‰æ‹©æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†
        i = low - 1                    # å°äºåŸºå‡†çš„å…ƒç´ çš„è¾¹ç•Œ

        for j in range(low, high):
            if arr[j] <= pivot:        # å°†å°äºç­‰äºåŸºå‡†çš„å…ƒç´ ç§»åˆ°å·¦è¾¹
                i += 1
                arr[i], arr[j] = arr[j], arr[i]

        # å°†åŸºå‡†å…ƒç´ æ”¾åˆ°æ­£ç¡®ä½ç½®
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1

    def quick_sort_helper(arr: list, low: int, high: int):
        if low < high:
            # åˆ†åŒºæ“ä½œ
            pi = partition(arr, low, high)

            # é€’å½’æ’åºå·¦å³å­æ•°ç»„
            quick_sort_helper(arr, low, pi - 1)
            quick_sort_helper(arr, pi + 1, high)

    quick_sort_helper(arr, 0, len(arr) - 1)
    return arr

# ä¼˜åŒ–ç‰ˆæœ¬ï¼šä¸‰æ•°å–ä¸­æ³•
def quick_sort_optimized(arr: list) -> list:
    """
    ä¼˜åŒ–çš„å¿«é€Ÿæ’åº - ä½¿ç”¨ä¸‰æ•°å–ä¸­æ³•é€‰æ‹©åŸºå‡†
    é¿å…æœ€åæƒ…å†µçš„å‘ç”Ÿ
    """
    def median_of_three(arr: list, low: int, high: int) -> int:
        """
        ä¸‰æ•°å–ä¸­æ³•é€‰æ‹©åŸºå‡†å…ƒç´ 
        å‡å°‘æœ€åæƒ…å†µå‘ç”Ÿçš„æ¦‚ç‡
        """
        mid = (low + high) // 2

        # æ¯”è¾ƒä¸‰ä¸ªå…ƒç´ å¹¶è¿”å›ä¸­å€¼çš„ç´¢å¼•
        if arr[low] > arr[mid]:
            arr[low], arr[mid] = arr[mid], arr[low]
        if arr[low] > arr[high]:
            arr[low], arr[high] = arr[high], arr[low]
        if arr[mid] > arr[high]:
            arr[mid], arr[high] = arr[high], arr[mid]

        return mid

    def partition(arr: list, low: int, high: int) -> int:
        # ä½¿ç”¨ä¸‰æ•°å–ä¸­æ³•é€‰æ‹©åŸºå‡†
        median_idx = median_of_three(arr, low, high)
        arr[median_idx], arr[high] = arr[high], arr[median_idx]

        pivot = arr[high]
        i = low - 1

        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]

        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1

    def quick_sort_helper(arr: list, low: int, high: int):
        # å°æ•°ç»„ä½¿ç”¨æ’å…¥æ’åºä¼˜åŒ–
        if high - low + 1 <= 10:
            insertion_sort_range(arr, low, high)
            return

        if low < high:
            pi = partition(arr, low, high)
            quick_sort_helper(arr, low, pi - 1)
            quick_sort_helper(arr, pi + 1, high)

    def insertion_sort_range(arr: list, low: int, high: int):
        """å¯¹æŒ‡å®šèŒƒå›´å†…çš„æ•°ç»„è¿›è¡Œæ’å…¥æ’åº"""
        for i in range(low + 1, high + 1):
            key = arr[i]
            j = i - 1
            while j >= low and arr[j] > key:
                arr[j + 1] = arr[j]
                j -= 1
            arr[j + 1] = key

    quick_sort_helper(arr, 0, len(arr) - 1)
    return arr
```

### 4. å †æ’åº (Heap Sort)

**æ ¸å¿ƒæ€æƒ³**ï¼šåˆ©ç”¨å †æ•°æ®ç»“æ„çš„ç‰¹æ€§è¿›è¡Œæ’åº

```python
def heap_sort(arr: list) -> list:
    """
    å †æ’åº - ä½¿ç”¨äºŒå‰å †
    æ—¶é—´å¤æ‚åº¦: O(n log n) æ‰€æœ‰æƒ…å†µ
    ç©ºé—´å¤æ‚åº¦: O(1) åŸåœ°æ’åº
    ç¨³å®šæ€§: âŒ ä¸ç¨³å®š
    """
    def heapify(arr: list, n: int, i: int):
        """
        å †åŒ–å‡½æ•° - ç»´æŠ¤å †çš„æ€§è´¨
        æ—¶é—´å¤æ‚åº¦: O(log n)
        """
        largest = i                    # åˆå§‹åŒ–æœ€å¤§å…ƒç´ ä¸ºæ ¹èŠ‚ç‚¹
        left = 2 * i + 1               # å·¦å­èŠ‚ç‚¹
        right = 2 * i + 2              # å³å­èŠ‚ç‚¹

        # æ‰¾å‡ºæ ¹èŠ‚ç‚¹ã€å·¦å­èŠ‚ç‚¹ã€å³å­èŠ‚ç‚¹ä¸­çš„æœ€å¤§å€¼
        if left < n and arr[left] > arr[largest]:
            largest = left

        if right < n and arr[right] > arr[largest]:
            largest = right

        # å¦‚æœæœ€å¤§å€¼ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œäº¤æ¢å¹¶é€’å½’å †åŒ–
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    n = len(arr)

    # æ„å»ºæœ€å¤§å †
    # ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹å †åŒ–
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # é€ä¸ªæå–å…ƒç´ 
    for i in range(n - 1, 0, -1):
        # å°†å½“å‰æ ¹èŠ‚ç‚¹ï¼ˆæœ€å¤§å€¼ï¼‰ç§»åˆ°æ•°ç»„æœ«å°¾
        arr[0], arr[i] = arr[i], arr[0]

        # å¯¹å‰©ä½™å…ƒç´ é‡æ–°å †åŒ–
        heapify(arr, i, 0)

    return arr
```

## ğŸ¯ éæ¯”è¾ƒæ’åºç®—æ³•

### 1. è®¡æ•°æ’åº (Counting Sort)

**æ ¸å¿ƒæ€æƒ³**ï¼šç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åé‡å»ºæœ‰åºæ•°ç»„

```python
def counting_sort(arr: list) -> list:
    """
    è®¡æ•°æ’åº - é€‚ç”¨äºå°èŒƒå›´æ•´æ•°
    æ—¶é—´å¤æ‚åº¦: O(n + k)ï¼Œå…¶ä¸­kæ˜¯æ•°æ®èŒƒå›´
    ç©ºé—´å¤æ‚åº¦: O(n + k)
    ç¨³å®šæ€§: âœ… ç¨³å®š
    å±€é™æ€§: åªé€‚ç”¨äºæ•´æ•°ï¼Œä¸”kä¸èƒ½è¿‡å¤§
    """
    if not arr:
        return arr

    # æ‰¾å‡ºæœ€å¤§å€¼å’Œæœ€å°å€¼
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1

    # åˆå§‹åŒ–è®¡æ•°æ•°ç»„
    count = [0] * range_val

    # ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°
    for num in arr:
        count[num - min_val] += 1

    # è®¡ç®—ç´¯ç§¯è®¡æ•°
    for i in range(1, range_val):
        count[i] += count[i - 1]

    # æ„å»ºç»“æœæ•°ç»„ï¼ˆä»åå‘å‰ä¿æŒç¨³å®šæ€§ï¼‰
    result = [0] * len(arr)
    for num in reversed(arr):
        index = count[num - min_val] - 1
        result[index] = num
        count[num - min_val] -= 1

    return result

# ä¼˜åŒ–ç‰ˆæœ¬ï¼šå‡å°‘ç©ºé—´ä½¿ç”¨
def counting_sort_optimized(arr: list) -> list:
    """
    ä¼˜åŒ–çš„è®¡æ•°æ’åº - å‡å°‘ç©ºé—´å¤æ‚åº¦
    å½“çŸ¥é“æ•°æ®èŒƒå›´è¾ƒå°æ—¶ç‰¹åˆ«æœ‰æ•ˆ
    """
    if not arr:
        return arr

    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1

    # å¦‚æœæ•°æ®èŒƒå›´è¿‡å¤§ï¼Œé€€å›åˆ°å…¶ä»–æ’åºç®—æ³•
    if range_val > len(arr) * 2:
        return quick_sort_optimized(arr.copy())

    count = [0] * range_val

    # ç»Ÿè®¡é¢‘ç‡
    for num in arr:
        count[num - min_val] += 1

    # ç›´æ¥æ ¹æ®é¢‘ç‡é‡å»ºç»“æœæ•°ç»„
    result = []
    for i in range(range_val):
        result.extend([i + min_val] * count[i])

    return result
```

### 2. åŸºæ•°æ’åº (Radix Sort)

**æ ¸å¿ƒæ€æƒ³**ï¼šæŒ‰ä½æ’åºï¼Œä»ä½ä½åˆ°é«˜ä½æˆ–ä»é«˜ä½åˆ°ä½ä½

```python
def radix_sort(arr: list) -> list:
    """
    åŸºæ•°æ’åº - æŒ‰ä½æ’åº
    æ—¶é—´å¤æ‚åº¦: O(d(n + k))ï¼Œå…¶ä¸­dæ˜¯ä½æ•°ï¼Œkæ˜¯åŸºæ•°
    ç©ºé—´å¤æ‚åº¦: O(n + k)
    ç¨³å®šæ€§: âœ… ç¨³å®š
    é€‚ç”¨åœºæ™¯: å›ºå®šé•¿åº¦çš„æ•´æ•°æˆ–å­—ç¬¦ä¸²
    """
    if not arr:
        return arr

    # æ‰¾å‡ºæœ€å¤§å€¼ï¼Œç¡®å®šä½æ•°
    max_val = max(abs(num) for num in arr)

    # å¤„ç†è´Ÿæ•° - å°†æ‰€æœ‰æ•°è½¬æ¢ä¸ºéè´Ÿæ•°
    min_val = min(arr)
    if min_val < 0:
        offset = -min_val
        arr = [num + offset for num in arr]
        max_val += offset

    exp = 1
    while max_val // exp > 0:
        counting_sort_by_digit(arr, exp)
        exp *= 10

    # æ¢å¤åŸå§‹æ•°å€¼
    if min_val < 0:
        arr = [num - offset for num in arr]

    return arr

def counting_sort_by_digit(arr: list, exp: int):
    """
    æŒ‰æŒ‡å®šä½è¿›è¡Œè®¡æ•°æ’åº
    è¿™æ˜¯åŸºæ•°æ’åºçš„æ ¸å¿ƒè¾…åŠ©å‡½æ•°
    """
    n = len(arr)
    output = [0] * n
    count = [0] * 10  # åè¿›åˆ¶æ•°å­—0-9

    # ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°
    for i in range(n):
        digit = (arr[i] // exp) % 10
        count[digit] += 1

    # è®¡ç®—ç´¯ç§¯è®¡æ•°
    for i in range(1, 10):
        count[i] += count[i - 1]

    # æ„å»ºè¾“å‡ºæ•°ç»„
    for i in range(n - 1, -1, -1):
        digit = (arr[i] // exp) % 10
        output[count[digit] - 1] = arr[i]
        count[digit] -= 1

    # å¤åˆ¶å›åŸæ•°ç»„
    for i in range(n):
        arr[i] = output[i]
```

<ExerciseBlock
  title="ç®—æ³•é€‰æ‹©"
  question="å¯¹äºåŒ…å«100ä¸‡ä¸ªå…ƒç´ çš„éšæœºæ•´æ•°æ•°ç»„ï¼Œåº”è¯¥é€‰æ‹©å“ªç§æ’åºç®—æ³•ï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "æ’å…¥æ’åº",
      correct: false,
      explanation: "O(nÂ²)å¯¹äºå¤§æ•°æ®å¤ªæ…¢"
    },
    {
      id: "b",
      text: "å¿«é€Ÿæ’åº",
      correct: true,
      explanation: "æ­£ç¡®ï¼å¹³å‡O(n log n)ä¸”å¸¸æ•°å› å­è¾ƒå°ï¼Œæ˜¯é€šç”¨åœºæ™¯çš„æœ€ä½³é€‰æ‹©"
    },
    {
      id: "c",
      text: "å†’æ³¡æ’åº",
      correct: false,
      explanation: "O(nÂ²)å®Œå…¨ä¸é€‚åˆå¤§æ•°æ®"
    },
    {
      id: "d",
      text: "è®¡æ•°æ’åº",
      correct: false,
      explanation: "å¦‚æœæ•´æ•°èŒƒå›´å¾ˆå¤§ï¼Œè®¡æ•°æ’åºçš„kå€¼ä¼šè¿‡å¤§"
    }
  ]}
  hint="è€ƒè™‘æ•°æ®è§„æ¨¡å’Œç®—æ³•çš„å¹³å‡æ€§èƒ½"
/>

## ğŸ¯ äº¤äº’å¼æ’åºæ¼”ç¤º

<ArrayVisualizer
  array={[5, 3, 8, 4, 2, 7, 1, 6]}
  title="åŸå§‹æ•°ç»„"
/>

### æ’åºè¿‡ç¨‹å¯è§†åŒ–

```python
# ç”Ÿæˆæ’åºæ­¥éª¤çš„æ¼”ç¤ºæ•°æ®
def generate_sorting_steps(arr: list, algorithm: str = 'quick') -> list:
    """
    ç”Ÿæˆæ’åºè¿‡ç¨‹çš„æ­¥éª¤æ•°æ®ï¼Œç”¨äºå¯è§†åŒ–æ¼”ç¤º
    """
    steps = []
    arr_copy = arr.copy()

    def record_step(description: str, highlighted: list = None):
        steps.append({
            description: description,
            array: arr_copy.copy(),
            highlighted: highlighted or []
        })

    record_step("å¼€å§‹æ’åº")

    if algorithm == 'quick':
        def quick_sort_visual(arr: list, low: int, high: int):
            if low < high:
                # é€‰æ‹©åŸºå‡†å…ƒç´ 
                pivot = arr[high]
                record_step(f"é€‰æ‹©åŸºå‡†å…ƒç´  {pivot}", [high])

                # åˆ†åŒºè¿‡ç¨‹
                i = low - 1
                for j in range(low, high):
                    if arr[j] <= pivot:
                        i += 1
                        arr[i], arr[j] = arr[j], arr[i]
                        record_step(f"äº¤æ¢ {arr[j]} å’Œ {arr[i]}", [i, j])

                arr[i + 1], arr[high] = arr[high], arr[i + 1]
                record_step(f"å°†åŸºå‡†å…ƒç´ æ”¾åˆ°ä½ç½® {i + 1}", [i + 1])

                # é€’å½’æ’åº
                quick_sort_visual(arr, low, i)
                quick_sort_visual(arr, i + 2, high)

        quick_sort_visual(arr_copy, 0, len(arr_copy) - 1)

    record_step("æ’åºå®Œæˆ")
    return steps

# ç”Ÿæˆæ¼”ç¤ºæ­¥éª¤
demo_steps = generate_sorting_steps([5, 3, 8, 4, 2, 7, 1, 6], 'quick')
```

<AlgorithmVisualizer
  algorithm="å¿«é€Ÿæ’åºæ¼”ç¤º"
  steps={demo_steps}
  speed={800}
  customRenderer={(data, highlighted) => (
    <ArrayVisualizer
      array={data.array}
      highlightedIndices={highlighted}
      title={data.description}
    />
  )}
/>

## ğŸ“Š æ€§èƒ½å¯¹æ¯”åˆ†æ

### å¤æ‚åº¦æ€»ç»“

| ç®—æ³• | æœ€å¥½æƒ…å†µ | å¹³å‡æƒ…å†µ | æœ€åæƒ…å†µ | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ |
|------|----------|----------|----------|------------|--------|
| æ’å…¥æ’åº | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… |
| å½’å¹¶æ’åº | O(n log n) | O(n log n) | O(n log n) | O(n) | âœ… |
| å¿«é€Ÿæ’åº | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | âŒ |
| å †æ’åº | O(n log n) | O(n log n) | O(n log n) | O(1) | âŒ |
| è®¡æ•°æ’åº | O(n+k) | O(n+k) | O(n+k) | O(n+k) | âœ… |
| åŸºæ•°æ’åº | O(d(n+k)) | O(d(n+k)) | O(d(n+k)) | O(n+k) | âœ… |

### å®é™…æ€§èƒ½æµ‹è¯•æ•°æ®

```python
# æ€§èƒ½æµ‹è¯•å‡½æ•°
def performance_comparison():
    """
    ä¸åŒæ’åºç®—æ³•çš„æ€§èƒ½å¯¹æ¯”æµ‹è¯•
    """
    import time
    import random

    algorithms = {
        'æ’å…¥æ’åº': insertion_sort,
        'å½’å¹¶æ’åº': merge_sort,
        'å¿«é€Ÿæ’åº': quick_sort_optimized,
        'å †æ’åº': heap_sort,
        'è®¡æ•°æ’åº': counting_sort,
        'å†…ç½®æ’åº': sorted
    }

    test_sizes = [100, 1000, 5000, 10000]
    results = {}

    for size in test_sizes:
        # ç”Ÿæˆæµ‹è¯•æ•°æ®
        random_data = [random.randint(1, 1000) for _ in range(size)]
        sorted_data = sorted(random_data)
        reverse_data = sorted_data[::-1]

        results[size] = {}
        for name, func in algorithms.items():
            try:
                # æµ‹è¯•éšæœºæ•°æ®
                start = time.time()
                func(random_data.copy())
                random_time = time.time() - start

                results[size][name] = random_time
            except Exception as e:
                results[size][name] = f"Error: {e}"

    return results

# æ¨¡æ‹Ÿæ€§èƒ½æ•°æ®
performance_data = [
    {"n": 100, "time": 0.001, "algorithm": "å¿«é€Ÿæ’åº"},
    {"n": 1000, "time": 0.012, "algorithm": "å¿«é€Ÿæ’åº"},
    {"n": 5000, "time": 0.068, "algorithm": "å¿«é€Ÿæ’åº"},
    {"n": 10000, "time": 0.145, "algorithm": "å¿«é€Ÿæ’åº"}
]
```

<ComplexityAnalyzer
  title="å¿«é€Ÿæ’åºå®é™…æ€§èƒ½"
  algorithm="å¿«é€Ÿæ’åºä¼˜åŒ–ç‰ˆæœ¬"
  theoreticalComplexity="O(n log n)"
  data={performance_data}
  color="rgb(16, 185, 129)"
/>

## ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

### 1. æ•°æ®åº“æ’åºä¼˜åŒ–

```python
class DatabaseSorter:
    """
    æ•°æ®åº“ç³»ç»Ÿä¸­çš„æ’åºç­–ç•¥
    """
    def __init__(self):
        self.memory_limit = 1000000  # 1MBå†…å­˜é™åˆ¶
        self.disk_buffer = []

    def external_sort(self, large_dataset: list) -> list:
        """
        å¤–éƒ¨æ’åº - å¤„ç†è¶…å‡ºå†…å­˜é™åˆ¶çš„å¤§æ•°æ®é›†
        ä½¿ç”¨å½’å¹¶æ’åºçš„å˜ç§
        """
        chunk_size = self.memory_limit // 4  # å®‰å…¨è¾¹ç•Œ

        # åˆ†å—æ’åº
        chunks = []
        for i in range(0, len(large_dataset), chunk_size):
            chunk = large_dataset[i:i + chunk_size]
            sorted_chunk = quick_sort_optimized(chunk)
            chunks.append(sorted_chunk)

        # å¤šè·¯å½’å¹¶
        return self.k_way_merge(chunks)

    def k_way_merge(self, chunks: list) -> list:
        """Kè·¯å½’å¹¶ç®—æ³•"""
        import heapq

        # åˆå§‹åŒ–æœ€å°å †
        heap = []
        for i, chunk in enumerate(chunks):
            if chunk:
                heapq.heappush(heap, (chunk[0], i, 0))

        result = []
        while heap:
            val, chunk_idx, element_idx = heapq.heappop(heap)
            result.append(val)

            # ä»åŒä¸€ä¸ªå—ä¸­å–å‡ºä¸‹ä¸€ä¸ªå…ƒç´ 
            if element_idx + 1 < len(chunks[chunk_idx]):
                next_val = chunks[chunk_idx][element_idx + 1]
                heapq.heappush(heap, (next_val, chunk_idx, element_idx + 1))

        return result
```

### 2. å®æ—¶æ•°æ®æµæ’åº

```python
class StreamingSorter:
    """
    å®æ—¶æ•°æ®æµæ’åºå™¨
    é€‚ç”¨äºä¸èƒ½ä¸€æ¬¡æ€§è·å–æ‰€æœ‰æ•°æ®çš„åœºæ™¯
    """
    def __init__(self, window_size: int = 1000):
        self.window_size = window_size
        self.buffer = []

    def add_element(self, element):
        """
        æ·»åŠ æ–°å…ƒç´ å¹¶ç»´æŠ¤æ’åºçŠ¶æ€
        ä½¿ç”¨æ’å…¥æ’åºç­–ç•¥ç»´æŠ¤çª—å£çš„æœ‰åºæ€§
        """
        # æ‰¾åˆ°æ’å…¥ä½ç½®
        insert_pos = 0
        while insert_pos < len(self.buffer) and self.buffer[insert_pos] < element:
            insert_pos += 1

        # æ’å…¥å…ƒç´ 
        self.buffer.insert(insert_pos, element)

        # ç»´æŠ¤çª—å£å¤§å°
        if len(self.buffer) > self.window_size:
            self.buffer.pop(0)

    def get_sorted_elements(self, k: int = None) -> list:
        """
        è·å–æ’åºåçš„å‰kä¸ªå…ƒç´ 
        """
        if k is None:
            return self.buffer.copy()
        return self.buffer[:min(k, len(self.buffer))]
```

<ExerciseBlock
  title="ç»¼åˆåº”ç”¨"
  question="è®¾è®¡ä¸€ä¸ªç³»ç»Ÿæ¥å¤„ç†æ¯å¤©10äº¿æ¡ç”¨æˆ·è¡Œä¸ºæ—¥å¿—çš„æ’åºã€‚æ¯æ¡æ—¥å¿—åŒ…å«æ—¶é—´æˆ³ã€ç”¨æˆ·IDå’Œæ“ä½œç±»å‹ã€‚éœ€è¦æŒ‰æ—¶é—´æˆ³æ’åºï¼Œä½†å†…å­˜åªèƒ½å®¹çº³100ä¸‡æ¡è®°å½•ã€‚æœ€ä½³æ–¹æ¡ˆæ˜¯ï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "ä½¿ç”¨å¿«é€Ÿæ’åºä¸€æ¬¡æ€§æ’åºæ‰€æœ‰æ•°æ®",
      correct: false,
      explanation: "å†…å­˜ä¸è¶³ä»¥å®¹çº³æ‰€æœ‰æ•°æ®"
    },
    {
      id: "b",
      text: "ä½¿ç”¨å¤–éƒ¨æ’åºï¼šåˆ†å—æ’åº + å¤šè·¯å½’å¹¶",
      correct: true,
      explanation: "æ­£ç¡®ï¼å¤–éƒ¨æ’åºä¸“é—¨å¤„ç†è¶…å‡ºå†…å­˜çš„å¤§æ•°æ®é›†"
    },
    {
      id: "c",
      text: "ä½¿ç”¨è®¡æ•°æ’åºæŒ‰æ—¶é—´æˆ³æ’åº",
      correct: false,
      explanation: "æ—¶é—´æˆ³èŒƒå›´å¤ªå¤§ï¼Œä¸é€‚åˆè®¡æ•°æ’åº"
    },
    {
      id: "d",
      text: "ä½¿ç”¨æ’å…¥æ’åºé€æ¡å¤„ç†",
      correct: false,
      explanation: "æ•ˆç‡å¤ªä½ï¼ŒO(nÂ²)æ— æ³•å¤„ç†10äº¿æ•°æ®"
    }
  ]}
  hint="è€ƒè™‘å†…å­˜é™åˆ¶å’Œå¤§æ•°æ®å¤„ç†çš„ç»å…¸ç®—æ³•"
/>

## ğŸ“ æ€»ç»“ä¸æœ€ä½³å®è·µ

### ç®—æ³•é€‰æ‹©æŒ‡å—

1. **å°è§„æ¨¡æ•°æ®** (n < 100):
   - æ’å…¥æ’åºï¼šç®€å•é«˜æ•ˆï¼Œå¯¹äºåŸºæœ¬æœ‰åºçš„æ•°æ®è¡¨ç°ä¼˜ç§€

2. **ä¸­ç­‰è§„æ¨¡æ•°æ®** (100 < n < 100,000):
   - å¿«é€Ÿæ’åºï¼šå¹³å‡æ€§èƒ½æœ€ä½³ï¼Œå¸¸æ•°å› å­å°
   - å½’å¹¶æ’åºï¼šç¨³å®šæ€§è¦æ±‚é«˜æ—¶çš„é€‰æ‹©

3. **å¤§è§„æ¨¡æ•°æ®** (n > 100,000):
   - å¿«é€Ÿæ’åºæˆ–å½’å¹¶æ’åº
   - è€ƒè™‘å¹¶è¡ŒåŒ–ä¼˜åŒ–

4. **ç‰¹æ®Šæ•°æ®ç±»å‹**:
   - å°èŒƒå›´æ•´æ•°ï¼šè®¡æ•°æ’åº
   - å›ºå®šé•¿åº¦æ•°æ®ï¼šåŸºæ•°æ’åº
   - è¶…å¤§æ•°æ®é›†ï¼šå¤–éƒ¨æ’åº

### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```python
def hybrid_sort(arr: list) -> list:
    """
    æ··åˆæ’åºç­–ç•¥ - ç»“åˆå¤šç§ç®—æ³•çš„ä¼˜åŠ¿
    """
    n = len(arr)

    # å°æ•°ç»„ä½¿ç”¨æ’å…¥æ’åº
    if n <= 20:
        return insertion_sort(arr)

    # æ£€æŸ¥æ˜¯å¦åŸºæœ¬æœ‰åº
    is_nearly_sorted = all(arr[i] <= arr[i + 1] for i in range(n - 1))
    if is_nearly_sorted:
        return arr  # å·²ç»æ’åº

    # æ£€æŸ¥æ•°æ®ç±»å‹å’ŒèŒƒå›´
    if all(isinstance(x, int) for x in arr):
        data_range = max(arr) - min(arr)
        if data_range <= n * 2:
            return counting_sort_optimized(arr)

    # é»˜è®¤ä½¿ç”¨ä¼˜åŒ–çš„å¿«é€Ÿæ’åº
    return quick_sort_optimized(arr)

# å¹¶è¡Œæ’åºç¤ºä¾‹
def parallel_sort(arr: list) -> list:
    """
    å¹¶è¡Œæ’åº - åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨
    """
    import multiprocessing

    def parallel_quick_sort(arr):
        if len(arr) <= 1000:
            return quick_sort_optimized(arr)

        # åˆ†å‰²ä»»åŠ¡
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]

        # å¹¶è¡Œå¤„ç†
        with multiprocessing.Pool(2) as pool:
            sorted_left, sorted_right = pool.map(parallel_quick_sort, [left, right])

        return merge(sorted_left, sorted_right)

    return parallel_quick_sort(arr)
```

<ExerciseBlock
  title="ç« èŠ‚æµ‹éªŒ"
  question="ä»¥ä¸‹å“ªç§æ’åºç®—æ³•åœ¨æ•°æ®å·²ç»åŸºæœ¬æœ‰åºæ—¶è¡¨ç°æœ€å¥½ï¼Ÿ"
  type="multiple-choice"
  difficulty="easy"
  options={[
    {
      id: "a",
      text: "å¿«é€Ÿæ’åº",
      correct: false,
      explanation: "å¿«é€Ÿæ’åºåœ¨å·²æ’åºæ•°æ®ä¸Šå¯èƒ½é€€åŒ–ä¸ºO(nÂ²)"
    },
    {
      id: "b",
      text: "æ’å…¥æ’åº",
      correct: true,
      explanation: "æ­£ç¡®ï¼æ’å…¥æ’åºåœ¨åŸºæœ¬æœ‰åºæ•°æ®ä¸Šæ¥è¿‘O(n)"
    },
    {
      id: "c",
      text: "å †æ’åº",
      correct: false,
      explanation: "å †æ’åºåœ¨å·²æ’åºæ•°æ®ä¸Šä»ä¸ºO(n log n)"
    },
    {
      id: "d",
      text: "å½’å¹¶æ’åº",
      correct: false,
      explanation: "å½’å¹¶æ’åºç¨³å®šä½†éœ€è¦O(n log n)æ—¶é—´"
    }
  ]}
  hint="è€ƒè™‘ç®—æ³•åœ¨æœ€å¥½æƒ…å†µä¸‹çš„æ€§èƒ½"
/>

---

## ğŸš€ è¯¾åç»ƒä¹ 

1. **åŸºç¡€ç»ƒä¹ **ï¼šå®ç°æ‰€æœ‰æ’åºç®—æ³•å¹¶å¯¹æ¯”æ€§èƒ½
2. **è¿›é˜¶ç»ƒä¹ **ï¼šä¸ºç‰¹å®šæ•°æ®ç‰¹å¾ä¼˜åŒ–æ’åºç®—æ³•
3. **å®æˆ˜ç»ƒä¹ **ï¼šå¤„ç†å¤§è§„æ¨¡æ•°æ®é›†çš„å¤–éƒ¨æ’åº
4. **é¡¹ç›®ç»ƒä¹ **ï¼šè®¾è®¡ä¸€ä¸ªè‡ªé€‚åº”æ’åºç³»ç»Ÿ

**è®°ä½**ï¼šæ²¡æœ‰æœ€å¥½çš„æ’åºç®—æ³•ï¼Œåªæœ‰æœ€é€‚åˆçš„ï¼ç†è§£æ¯ç§ç®—æ³•çš„ç‰¹æ€§å’Œé€‚ç”¨åœºæ™¯æ˜¯æˆä¸ºä¼˜ç§€å·¥ç¨‹å¸ˆçš„å…³é”®ã€‚ğŸ¯