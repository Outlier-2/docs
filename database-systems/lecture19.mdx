---
title: 'Lecture 19: Logging & Recovery I'
description: '深入探讨数据库日志系统的基础概念，包括日志记录格式、预写日志协议、检查点机制和恢复算法'
date: '2024-02-19'
tags: ['数据库系统', '日志与恢复', 'CMU 15-445']
---

# Lecture 19: Logging & Recovery I

## 概述

日志与恢复是数据库系统的核心机制，确保数据在系统故障后的完整性和一致性。本讲将深入探讨日志系统的基础概念、预写日志协议、检查点机制以及基本的恢复算法。

## 日志系统基础

### 1. 日志记录格式

```cpp
// 日志记录类型
enum class LogRecordType {
    BEGIN,           // 事务开始
    COMMIT,          // 事务提交
    ABORT,           // 事务终止
    UPDATE,          // 更新操作
    CHECKPOINT,      // 检查点
    COMPENSATION,    // 补偿日志
    END              // 事务结束
};

// 日志记录基类
class LogRecord {
public:
    virtual ~LogRecord() = default;

    // 序列化日志记录
    virtual std::vector<char> Serialize() const = 0;

    // 反序列化日志记录
    virtual void Deserialize(const std::vector<char>& data) = 0;

    // 获取日志记录类型
    virtual LogRecordType GetType() const = 0;

    // 获取日志记录大小
    virtual size_t GetSize() const = 0;

    // 获取日志记录的LSN（日志序列号）
    LSN GetLSN() const { return lsn_; }

    // 设置日志记录的LSN
    void SetLSN(LSN lsn) { lsn_ = lsn; }

    // 获取事务ID
    TransactionId GetTransactionId() const { return txn_id_; }

    // 设置事务ID
    void SetTransactionId(TransactionId txn_id) { txn_id_ = txn_id; }

protected:
    LSN lsn_ = INVALID_LSN;           // 日志序列号
    TransactionId txn_id_ = INVALID_TXN_ID;  // 事务ID
    uint64_t timestamp_ = 0;          // 时间戳
};

// 更新日志记录
class UpdateLogRecord : public LogRecord {
public:
    UpdateLogRecord(
        TransactionId txn_id,
        const Key& key,
        const Value& old_value,
        const Value& new_value,
        const std::string& table_name
    ) : key_(key), old_value_(old_value), new_value_(new_value),
        table_name_(table_name) {
        SetTransactionId(txn_id);
    }

    LogRecordType GetType() const override {
        return LogRecordType::UPDATE;
    }

    std::vector<char> Serialize() const override {
        std::vector<char> data;
        size_t offset = 0;

        // 记录类型
        uint32_t type = static_cast<uint32_t>(GetType());
        data.insert(data.end(), reinterpret_cast<const char*>(&type),
                   reinterpret_cast<const char*>(&type) + sizeof(type));
        offset += sizeof(type);

        // LSN
        data.insert(data.end(), reinterpret_cast<const char*>(&lsn_),
                   reinterpret_cast<const char*>(&lsn_) + sizeof(lsn_));
        offset += sizeof(lsn_);

        // 事务ID
        data.insert(data.end(), reinterpret_cast<const char*>(&txn_id_),
                   reinterpret_cast<const char*>(&txn_id_) + sizeof(txn_id_));
        offset += sizeof(txn_id_);

        // 时间戳
        data.insert(data.end(), reinterpret_cast<const char*>(&timestamp_),
                   reinterpret_cast<const char*>(&timestamp_) + sizeof(timestamp_));
        offset += sizeof(timestamp_);

        // 键长度和键数据
        uint32_t key_length = static_cast<uint32_t>(key_.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&key_length),
                   reinterpret_cast<const char*>(&key_length) + sizeof(key_length));
        offset += sizeof(key_length);
        data.insert(data.end(), key_.begin(), key_.end());
        offset += key_.size();

        // 旧值长度和旧值数据
        uint32_t old_value_length = static_cast<uint32_t>(old_value_.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&old_value_length),
                   reinterpret_cast<const char*>(&old_value_length) + sizeof(old_value_length));
        offset += sizeof(old_value_length);
        data.insert(data.end(), old_value_.begin(), old_value_.end());
        offset += old_value_.size();

        // 新值长度和新值数据
        uint32_t new_value_length = static_cast<uint32_t>(new_value_.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&new_value_length),
                   reinterpret_cast<const char*>(&new_value_length) + sizeof(new_value_length));
        offset += sizeof(new_value_length);
        data.insert(data.end(), new_value_.begin(), new_value_.end());
        offset += new_value_.size();

        // 表名长度和表名数据
        uint32_t table_name_length = static_cast<uint32_t>(table_name_.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&table_name_length),
                   reinterpret_cast<const char*>(&table_name_length) + sizeof(table_name_length));
        offset += sizeof(table_name_length);
        data.insert(data.end(), table_name_.begin(), table_name_.end());
        offset += table_name_.size();

        return data;
    }

    void Deserialize(const std::vector<char>& data) override {
        size_t offset = 0;

        // 读取记录类型
        uint32_t type;
        std::memcpy(&type, data.data() + offset, sizeof(type));
        offset += sizeof(type);

        // 读取LSN
        std::memcpy(&lsn_, data.data() + offset, sizeof(lsn_));
        offset += sizeof(lsn_);

        // 读取事务ID
        std::memcpy(&txn_id_, data.data() + offset, sizeof(txn_id_));
        offset += sizeof(txn_id_);

        // 读取时间戳
        std::memcpy(&timestamp_, data.data() + offset, sizeof(timestamp_));
        offset += sizeof(timestamp_);

        // 读取键
        uint32_t key_length;
        std::memcpy(&key_length, data.data() + offset, sizeof(key_length));
        offset += sizeof(key_length);
        key_.assign(data.data() + offset, data.data() + offset + key_length);
        offset += key_length;

        // 读取旧值
        uint32_t old_value_length;
        std::memcpy(&old_value_length, data.data() + offset, sizeof(old_value_length));
        offset += sizeof(old_value_length);
        old_value_.assign(data.data() + offset, data.data() + offset + old_value_length);
        offset += old_value_length;

        // 读取新值
        uint32_t new_value_length;
        std::memcpy(&new_value_length, data.data() + offset, sizeof(new_value_length));
        offset += sizeof(new_value_length);
        new_value_.assign(data.data() + offset, data.data() + offset + new_value_length);
        offset += new_value_length;

        // 读取表名
        uint32_t table_name_length;
        std::memcpy(&table_name_length, data.data() + offset, sizeof(table_name_length));
        offset += sizeof(table_name_length);
        table_name_.assign(data.data() + offset, data.data() + offset + table_name_length);
    }

    size_t GetSize() const override {
        return sizeof(uint32_t) +  // 类型
               sizeof(LSN) +      // LSN
               sizeof(TransactionId) +  // 事务ID
               sizeof(uint64_t) +  // 时间戳
               sizeof(uint32_t) + key_.size() +  // 键
               sizeof(uint32_t) + old_value_.size() +  // 旧值
               sizeof(uint32_t) + new_value_.size() +  // 新值
               sizeof(uint32_t) + table_name_.size();  // 表名
    }

    // 访问器方法
    const Key& GetKey() const { return key_; }
    const Value& GetOldValue() const { return old_value_; }
    const Value& GetNewValue() const { return new_value_; }
    const std::string& GetTableName() const { return table_name_; }

private:
    Key key_;
    Value old_value_;
    Value new_value_;
    std::string table_name_;
};

// 事务控制日志记录
class TransactionLogRecord : public LogRecord {
public:
    TransactionLogRecord(LogRecordType type, TransactionId txn_id) {
        SetTransactionId(txn_id);
    }

    LogRecordType GetType() const override {
        return type_;
    }

    std::vector<char> Serialize() const override {
        std::vector<char> data;

        // 记录类型
        uint32_t type = static_cast<uint32_t>(GetType());
        data.insert(data.end(), reinterpret_cast<const char*>(&type),
                   reinterpret_cast<const char*>(&type) + sizeof(type));

        // LSN
        data.insert(data.end(), reinterpret_cast<const char*>(&lsn_),
                   reinterpret_cast<const char*>(&lsn_) + sizeof(lsn_));

        // 事务ID
        data.insert(data.end(), reinterpret_cast<const char*>(&txn_id_),
                   reinterpret_cast<const char*>(&txn_id_) + sizeof(txn_id_));

        // 时间戳
        data.insert(data.end(), reinterpret_cast<const char*>(&timestamp_),
                   reinterpret_cast<const char*>(&timestamp_) + sizeof(timestamp_));

        return data;
    }

    void Deserialize(const std::vector<char>& data) override {
        size_t offset = 0;

        // 读取记录类型
        uint32_t type;
        std::memcpy(&type, data.data() + offset, sizeof(type));
        type_ = static_cast<LogRecordType>(type);
        offset += sizeof(type);

        // 读取LSN
        std::memcpy(&lsn_, data.data() + offset, sizeof(lsn_));
        offset += sizeof(lsn_);

        // 读取事务ID
        std::memcpy(&txn_id_, data.data() + offset, sizeof(txn_id_));
        offset += sizeof(txn_id_);

        // 读取时间戳
        std::memcpy(&timestamp_, data.data() + offset, sizeof(timestamp_));
    }

    size_t GetSize() const override {
        return sizeof(uint32_t) +  // 类型
               sizeof(LSN) +      // LSN
               sizeof(TransactionId) +  // 事务ID
               sizeof(uint64_t);   // 时间戳
    }

private:
    LogRecordType type_;
};
```

### 2. 日志管理器

```cpp
// 日志管理器
class LogManager {
public:
    // 配置
    struct Config {
        std::string log_file_path = "db.log";
        size_t buffer_size = 1024 * 1024;  // 1MB
        size_t max_log_size = 1024 * 1024 * 1024;  // 1GB
        bool enable_compression = false;
        bool enable_checksum = true;
        uint32_t flush_interval_ms = 100;  // 100ms
    };

    LogManager(const Config& config = Config{})
        : config_(config), running_(false), next_lsn_(1) {
        InitializeLogFile();
        StartFlushThread();
    }

    ~LogManager() {
        StopFlushThread();
        Flush();
    }

    // 记录事务开始
    LSN LogBegin(TransactionId txn_id) {
        auto record = std::make_unique<TransactionLogRecord>(
            LogRecordType::BEGIN, txn_id
        );
        return AppendLogRecord(std::move(record));
    }

    // 记录事务提交
    LSN LogCommit(TransactionId txn_id) {
        auto record = std::make_unique<TransactionLogRecord>(
            LogRecordType::COMMIT, txn_id
        );
        return AppendLogRecord(std::move(record));
    }

    // 记录事务终止
    LSN LogAbort(TransactionId txn_id) {
        auto record = std::make_unique<TransactionLogRecord>(
            LogRecordType::ABORT, txn_id
        );
        return AppendLogRecord(std::move(record));
    }

    // 记录更新操作
    LSN LogUpdate(
        TransactionId txn_id,
        const Key& key,
        const Value& old_value,
        const Value& new_value,
        const std::string& table_name
    ) {
        auto record = std::make_unique<UpdateLogRecord>(
            txn_id, key, old_value, new_value, table_name
        );
        return AppendLogRecord(std::move(record));
    }

    // 记录检查点
    LSN LogCheckpoint() {
        auto record = std::make_unique<TransactionLogRecord>(
            LogRecordType::CHECKPOINT, INVALID_TXN_ID
        );
        return AppendLogRecord(std::move(record));
    }

    // 强制刷新日志到磁盘
    void Flush() {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        if (!log_buffer_.empty()) {
            WriteToDisk(log_buffer_);
            log_buffer_.clear();
        }
        fsync(log_file_fd_);
    }

    // 获取持久化的LSN
    LSN GetPersistentLSN() const {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        return persistent_lsn_;
    }

    // 设置持久化的LSN
    void SetPersistentLSN(LSN lsn) {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        persistent_lsn_ = lsn;
    }

private:
    Config config_;
    int log_file_fd_ = -1;
    std::vector<char> log_buffer_;
    std::mutex buffer_mutex_;
    std::atomic<LSN> next_lsn_;
    std::atomic<LSN> persistent_lsn_{0};
    std::atomic<bool> running_;
    std::unique_ptr<std::thread> flush_thread_;
    std::condition_variable flush_cv_;
    std::mutex flush_mutex_;

    // 初始化日志文件
    void InitializeLogFile() {
        log_file_fd_ = open(config_.log_file_path.c_str(),
                           O_WRONLY | O_CREAT | O_APPEND, 0644);
        if (log_file_fd_ == -1) {
            throw std::runtime_error("Failed to open log file: " + config_.log_file_path);
        }
    }

    // 追加日志记录
    LSN AppendLogRecord(std::unique_ptr<LogRecord> record) {
        std::lock_guard<std::mutex> lock(buffer_mutex_);

        // 分配LSN
        LSN lsn = next_lsn_.fetch_add(1);
        record->SetLSN(lsn);

        // 序列化记录
        auto serialized_data = record->Serialize();

        // 添加长度前缀
        uint32_t length = static_cast<uint32_t>(serialized_data.size());
        log_buffer_.insert(log_buffer_.end(),
                          reinterpret_cast<const char*>(&length),
                          reinterpret_cast<const char*>(&length) + sizeof(length));
        log_buffer_.insert(log_buffer_.end(),
                          serialized_data.begin(),
                          serialized_data.end());

        // 如果缓冲区已满，刷新到磁盘
        if (log_buffer_.size() >= config_.buffer_size) {
            WriteToDisk(log_buffer_);
            log_buffer_.clear();
        }

        return lsn;
    }

    // 写入磁盘
    void WriteToDisk(const std::vector<char>& data) {
        if (data.empty()) {
            return;
        }

        ssize_t bytes_written = write(log_file_fd_, data.data(), data.size());
        if (bytes_written == -1) {
            throw std::runtime_error("Failed to write to log file");
        }

        if (static_cast<size_t>(bytes_written) != data.size()) {
            throw std::runtime_error("Incomplete write to log file");
        }

        // 更新持久化LSN
        // 这里需要解析最后一个记录的LSN
        persistent_lsn_.store(next_lsn_.load() - 1);
    }

    // 启动刷新线程
    void StartFlushThread() {
        running_ = true;
        flush_thread_ = std::make_unique<std::thread>([this]() {
            FlushThreadWorker();
        });
    }

    // 停止刷新线程
    void StopFlushThread() {
        running_ = false;
        flush_cv_.notify_all();
        if (flush_thread_ && flush_thread_->joinable()) {
            flush_thread_->join();
        }
    }

    // 刷新线程工作函数
    void FlushThreadWorker() {
        while (running_) {
            std::unique_lock<std::mutex> lock(flush_mutex_);
            if (flush_cv_.wait_for(lock,
                                 std::chrono::milliseconds(config_.flush_interval_ms),
                                 [this]() { return !running_; })) {
                break;
            }

            if (running_) {
                Flush();
            }
        }
    }
};
```

## 预写日志协议（WAL）

### 1. WAL协议实现

```cpp
// 预写日志协议管理器
class WriteAheadLogManager {
public:
    // WAL配置
    struct WALConfig {
        size_t log_buffer_size = 1024 * 1024;  // 1MB
        size_t page_size = 8192;              // 8KB
        uint32_t group_commit_size = 10;       // 组提交大小
        uint32_t group_commit_timeout_ms = 5;  // 组提交超时
        bool enable_group_commit = true;       // 启用组提交
    };

    // 页面状态
    struct PageState {
        bool dirty = false;          // 页面是否被修改
        LSN last_lsn = INVALID_LSN;  // 最后修改的LSN
        uint32_t pin_count = 0;      // 引用计数
    };

    WriteAheadLogManager(const WALConfig& config = WALConfig{})
        : config_(config), log_manager_(LogManager::Config{}) {
        Initialize();
    }

    // 开始事务
    TransactionId BeginTransaction() {
        auto txn_id = GenerateTransactionId();
        auto lsn = log_manager_.LogBegin(txn_id);

        // 记录事务状态
        TransactionState state;
        state.txn_id = txn_id;
        state.first_lsn = lsn;
        state.last_lsn = lsn;
        state.status = TransactionStatus::ACTIVE;

        std::lock_guard<std::mutex> lock(txn_mutex_);
        transaction_states_[txn_id] = state;

        return txn_id;
    }

    // 更新页面
    bool UpdatePage(
        TransactionId txn_id,
        PageId page_id,
        uint32_t offset,
        const std::vector<char>& data
    ) {
        // 获取页面状态
        auto page_state = GetPageState(page_id);
        if (!page_state) {
            return false;
        }

        // 检查页面是否被锁定
        if (page_state->pin_count == 0) {
            return false;
        }

        // 记录更新前的数据
        std::vector<char> old_data(data.size());
        std::memcpy(old_data.data(), GetPageData(page_id) + offset, data.size());

        // 创建更新日志记录
        Key key = GenerateUpdateKey(page_id, offset);
        Value old_value(old_data.begin(), old_data.end());
        Value new_value(data.begin(), data.end());

        auto lsn = log_manager_.LogUpdate(txn_id, key, old_value, new_value, "table");

        // 应用更新到页面
        std::memcpy(GetPageData(page_id) + offset, data.data(), data.size());

        // 更新页面状态
        page_state->dirty = true;
        page_state->last_lsn = lsn;

        // 更新事务状态
        UpdateTransactionState(txn_id, lsn);

        return true;
    }

    // 提交事务
    bool CommitTransaction(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(txn_mutex_);

        auto it = transaction_states_.find(txn_id);
        if (it == transaction_states_.end()) {
            return false;
        }

        auto& state = it->second;
        if (state.status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 记录提交日志
        auto lsn = log_manager_.LogCommit(txn_id);

        // 更新事务状态
        state.status = TransactionStatus::COMMITTED;
        state.last_lsn = lsn;

        // 确保日志持久化
        LogCommit(lsn);

        return true;
    }

    // 终止事务
    bool AbortTransaction(TransactionId txn_id) {
        std::lock_guard<std::mutex> lock(txn_mutex_);

        auto it = transaction_states_.find(txn_id);
        if (it == transaction_states_.end()) {
            return false;
        }

        auto& state = it->second;
        if (state.status != TransactionStatus::ACTIVE) {
            return false;
        }

        // 记录终止日志
        auto lsn = log_manager_.LogAbort(txn_id);

        // 更新事务状态
        state.status = TransactionStatus::ABORTED;
        state.last_lsn = lsn;

        return true;
    }

    // 锁定页面
    bool PinPage(PageId page_id) {
        auto page_state = GetOrCreatePageState(page_id);
        page_state->pin_count++;
        return true;
    }

    // 解锁页面
    bool UnpinPage(PageId page_id) {
        auto page_state = GetPageState(page_id);
        if (!page_state) {
            return false;
        }

        if (page_state->pin_count > 0) {
            page_state->pin_count--;
        }

        return true;
    }

    // 强制写入脏页面
    void FlushDirtyPages(LSN up_to_lsn) {
        std::lock_guard<std::mutex> lock(page_mutex_);

        for (auto& [page_id, page_state] : page_states_) {
            if (page_state.dirty && page_state.last_lsn <= up_to_lsn) {
                // 写入页面到磁盘
                WritePageToDisk(page_id);
                page_state.dirty = false;
            }
        }
    }

    // 获取持久化LSN
    LSN GetPersistentLSN() const {
        return log_manager_.GetPersistentLSN();
    }

private:
    WALConfig config_;
    LogManager log_manager_;
    std::unordered_map<TransactionId, TransactionState> transaction_states_;
    std::unordered_map<PageId, PageState> page_states_;
    std::unordered_map<PageId, std::vector<char>> page_data_;
    std::mutex txn_mutex_;
    std::mutex page_mutex_;
    std::atomic<TransactionId> next_txn_id_{1};

    // 事务状态
    struct TransactionState {
        TransactionId txn_id;
        LSN first_lsn;
        LSN last_lsn;
        TransactionStatus status;
    };

    // 初始化
    void Initialize() {
        // 初始化页面状态和页面数据
    }

    // 生成事务ID
    TransactionId GenerateTransactionId() {
        return next_txn_id_.fetch_add(1);
    }

    // 获取页面状态
    PageState* GetPageState(PageId page_id) {
        auto it = page_states_.find(page_id);
        if (it != page_states_.end()) {
            return &it->second;
        }
        return nullptr;
    }

    // 获取或创建页面状态
    PageState* GetOrCreatePageState(PageId page_id) {
        std::lock_guard<std::mutex> lock(page_mutex_);
        return &page_states_[page_id];
    }

    // 获取页面数据
    char* GetPageData(PageId page_id) {
        auto it = page_data_.find(page_id);
        if (it == page_data_.end()) {
            // 分配新页面
            page_data_[page_id].resize(config_.page_size);
        }
        return page_data_[page_id].data();
    }

    // 生成更新键
    Key GenerateUpdateKey(PageId page_id, uint32_t offset) {
        return std::to_string(page_id) + "_" + std::to_string(offset);
    }

    // 更新事务状态
    void UpdateTransactionState(TransactionId txn_id, LSN lsn) {
        std::lock_guard<std::mutex> lock(txn_mutex_);

        auto it = transaction_states_.find(txn_id);
        if (it != transaction_states_.end()) {
            it->second.last_lsn = lsn;
        }
    }

    // 记录提交（支持组提交）
    void LogCommit(LSN lsn) {
        if (config_.enable_group_commit) {
            // 组提交逻辑
            GroupCommitManager::GetInstance().AddCommit(lsn);
        } else {
            // 立即刷新
            log_manager_.Flush();
        }
    }

    // 写入页面到磁盘
    void WritePageToDisk(PageId page_id) {
        // 实现页面写入磁盘的逻辑
        // 这里需要访问存储管理器
    }
};

// 组提交管理器（单例模式）
class GroupCommitManager {
public:
    static GroupCommitManager& GetInstance() {
        static GroupCommitManager instance;
        return instance;
    }

    // 添加提交请求
    void AddCommit(LSN lsn) {
        std::lock_guard<std::mutex> lock(mutex_);
        pending_commits_.push_back(lsn);

        if (pending_commits_.size() >= group_commit_size_) {
            cv_.notify_one();
        }
    }

    // 启动组提交线程
    void Start() {
        running_ = true;
        thread_ = std::make_unique<std::thread>([this]() {
            GroupCommitWorker();
        });
    }

    // 停止组提交线程
    void Stop() {
        running_ = false;
        cv_.notify_all();
        if (thread_ && thread_->joinable()) {
            thread_->join();
        }
    }

private:
    GroupCommitManager() = default;
    ~GroupCommitManager() {
        Stop();
    }

    std::mutex mutex_;
    std::condition_variable cv_;
    std::vector<LSN> pending_commits_;
    std::atomic<bool> running_{false};
    std::unique_ptr<std::thread> thread_;
    static constexpr size_t group_commit_size_ = 10;

    // 组提交工作线程
    void GroupCommitWorker() {
        while (running_) {
            std::vector<LSN> commits_to_flush;

            {
                std::unique_lock<std::mutex> lock(mutex_);
                if (cv_.wait_for(lock, std::chrono::milliseconds(5),
                               [this]() { return !pending_commits_.empty() || !running_; })) {
                    if (!running_) break;
                }

                if (!pending_commits_.empty()) {
                    commits_to_flush.swap(pending_commits_);
                }
            }

            if (!commits_to_flush.empty()) {
                // 批量刷新日志
                FlushCommits(commits_to_flush);
            }
        }
    }

    // 刷新提交的日志
    void FlushCommits(const std::vector<LSN>& commits) {
        // 这里需要调用日志管理器的刷新方法
        // LogManager::GetInstance().Flush();
    }
};
```

### 2. WAL优化技术

```cpp
// WAL优化管理器
class WALOptimizationManager {
public:
    // WAL优化配置
    struct OptimizationConfig {
        bool enable_log_buffering = true;        // 启用日志缓冲
        bool enable_group_commit = true;         // 启用组提交
        bool enable_log_compression = true;      // 启用日志压缩
        bool enable_checksum = true;             // 启用校验和
        size_t max_buffer_size = 1024 * 1024;    // 最大缓冲区大小
        uint32_t compression_threshold = 1024;  // 压缩阈值
        uint32_t group_commit_threshold = 10;    // 组提交阈值
    };

    WALOptimizationManager(const OptimizationConfig& config = OptimizationConfig{})
        : config_(config) {}

    // 优化的日志记录
    class OptimizedLogRecord : public LogRecord {
    public:
        OptimizedLogRecord(LogRecordType type, TransactionId txn_id)
            : type_(type) {
            SetTransactionId(txn_id);
        }

        LogRecordType GetType() const override { return type_; }

        // 压缩序列化
        std::vector<char> Serialize() const override {
            auto uncompressed = SerializeUncompressed();

            if (config_.enable_log_compression && uncompressed.size() > config_.compression_threshold) {
                return CompressData(uncompressed);
            }

            return uncompressed;
        }

        // 带校验和的反序列化
        void Deserialize(const std::vector<char>& data) override {
            if (config_.enable_checksum) {
                if (!VerifyChecksum(data)) {
                    throw std::runtime_error("Log record checksum verification failed");
                }
            }

            auto decompressed = data;
            if (IsCompressed(data)) {
                decompressed = DecompressData(data);
            }

            DeserializeInternal(decompressed);
        }

        size_t GetSize() const override {
            auto data = Serialize();
            return data.size();
        }

    private:
        LogRecordType type_;
        OptimizationConfig config_;

        std::vector<char> SerializeUncompressed() const {
            // 实现未压缩的序列化
            return std::vector<char>();
        }

        void DeserializeInternal(const std::vector<char>& data) {
            // 实现内部反序列化
        }

        std::vector<char> CompressData(const std::vector<char>& data) const {
            // 实现数据压缩
            // 可以使用zlib、lz4等压缩库
            std::vector<char> compressed;
            // 压缩逻辑
            return compressed;
        }

        std::vector<char> DecompressData(const std::vector<char>& data) const {
            // 实现数据解压缩
            std::vector<char> decompressed;
            // 解压缩逻辑
            return decompressed;
        }

        bool IsCompressed(const std::vector<char>& data) const {
            // 检查数据是否被压缩
            return false;
        }

        bool VerifyChecksum(const std::vector<char>& data) const {
            // 验证校验和
            return true;
        }
    };

    // 批量日志记录
    class BatchLogRecords {
    public:
        void AddRecord(std::unique_ptr<LogRecord> record) {
            records_.push_back(std::move(record));
        }

        std::vector<char> SerializeBatch() const {
            std::vector<char> batch_data;

            // 批量头部
            BatchHeader header;
            header.record_count = records_.size();
            header.total_size = 0;
            header.timestamp = GetTickCount();

            // 计算总大小
            for (const auto& record : records_) {
                header.total_size += record->GetSize();
            }

            // 序列化头部
            auto header_data = SerializeHeader(header);
            batch_data.insert(batch_data.end(), header_data.begin(), header_data.end());

            // 序列化记录
            for (const auto& record : records_) {
                auto record_data = record->Serialize();
                batch_data.insert(batch_data.end(), record_data.begin(), record_data.end());
            }

            return batch_data;
        }

        size_t GetBatchSize() const {
            size_t total_size = sizeof(BatchHeader);
            for (const auto& record : records_) {
                total_size += record->GetSize();
            }
            return total_size;
        }

    private:
        struct BatchHeader {
            uint32_t record_count;
            uint32_t total_size;
            uint64_t timestamp;
        };

        std::vector<std::unique_ptr<LogRecord>> records_;

        std::vector<char> SerializeHeader(const BatchHeader& header) const {
            std::vector<char> data;
            data.insert(data.end(), reinterpret_cast<const char*>(&header),
                       reinterpret_cast<const char*>(&header) + sizeof(header));
            return data;
        }
    };

    // 异步日志写入器
    class AsyncLogWriter {
    public:
        AsyncLogWriter(size_t queue_size = 1000) : queue_size_(queue_size), running_(false) {}

        void Start() {
            running_ = true;
            writer_thread_ = std::make_unique<std::thread>([this]() {
                WriterWorker();
            });
        }

        void Stop() {
            running_ = false;
            queue_cv_.notify_all();
            if (writer_thread_ && writer_thread_->joinable()) {
                writer_thread_->join();
            }
        }

        bool WriteAsync(std::vector<char> data) {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (write_queue_.size() >= queue_size_) {
                return false;  // 队列已满
            }

            write_queue_.push(std::move(data));
            queue_cv_.notify_one();
            return true;
        }

    private:
        size_t queue_size_;
        std::queue<std::vector<char>> write_queue_;
        std::mutex queue_mutex_;
        std::condition_variable queue_cv_;
        std::atomic<bool> running_;
        std::unique_ptr<std::thread> writer_thread_;

        void WriterWorker() {
            while (running_) {
                std::vector<char> data_to_write;

                {
                    std::unique_lock<std::mutex> lock(queue_mutex_);
                    if (queue_cv_.wait_for(lock, std::chrono::milliseconds(100),
                                           [this]() { return !write_queue_.empty() || !running_; })) {
                        if (!running_) break;
                    }

                    if (!write_queue_.empty()) {
                        data_to_write = std::move(write_queue_.front());
                        write_queue_.pop();
                    }
                }

                if (!data_to_write.empty()) {
                    WriteToDisk(data_to_write);
                }
            }
        }

        void WriteToDisk(const std::vector<char>& data) {
            // 实现磁盘写入逻辑
        }
    };

    // 内存优化
    class MemoryOptimizedLogBuffer {
    public:
        MemoryOptimizedLogBuffer(size_t capacity) : capacity_(capacity) {}

        bool Append(const std::vector<char>& data) {
            std::lock_guard<std::mutex> lock(mutex_);

            if (buffer_.size() + data.size() > capacity_) {
                return false;
            }

            buffer_.insert(buffer_.end(), data.begin(), data.end());
            return true;
        }

        std::vector<char> Flush() {
            std::lock_guard<std::mutex> lock(mutex_);
            std::vector<char> flushed;
            flushed.swap(buffer_);
            return flushed;
        }

        size_t GetSize() const {
            std::lock_guard<std::mutex> lock(mutex_);
            return buffer_.size();
        }

        size_t GetCapacity() const { return capacity_; }

    private:
        size_t capacity_;
        std::vector<char> buffer_;
        std::mutex mutex_;
    };

private:
    OptimizationConfig config_;
    std::unique_ptr<AsyncLogWriter> async_writer_;
    std::unique_ptr<MemoryOptimizedLogBuffer> log_buffer_;
};
```

## 检查点机制

### 1. 检查点算法

```cpp
// 检查点管理器
class CheckpointManager {
public:
    // 检查点类型
    enum class CheckpointType {
        FUZZY,           // 模糊检查点
        SHARP,           // 精确检查点
        CONSISTENT       // 一致性检查点
    };

    // 检查点记录
    struct CheckpointRecord {
        LSN checkpoint_lsn;
        uint64_t timestamp;
        CheckpointType type;
        std::vector<TransactionId> active_transactions;
        std::vector<std::pair<TransactionId, LSN>> transaction_lsns;
        std::vector<PageId> dirty_pages;
    };

    // 检查点配置
    struct CheckpointConfig {
        CheckpointType type = CheckpointType::FUZZY;
        uint64_t interval_ms = 60000;    // 60秒
        uint64_t timeout_ms = 5000;      // 5秒
        bool enable_background = true;   // 启用后台检查点
        size_t max_dirty_pages = 1000;   // 最大脏页面数
        double memory_threshold = 0.8;   // 内存阈值
    };

    CheckpointManager(
        LogManager* log_manager,
        WriteAheadLogManager* wal_manager,
        const CheckpointConfig& config = CheckpointConfig{}
    ) : log_manager_(log_manager), wal_manager_(wal_manager), config_(config) {
        if (config_.enable_background) {
            StartBackgroundCheckpoint();
        }
    }

    ~CheckpointManager() {
        StopBackgroundCheckpoint();
    }

    // 执行检查点
    LSN ExecuteCheckpoint() {
        switch (config_.type) {
            case CheckpointType::FUZZY:
                return ExecuteFuzzyCheckpoint();
            case CheckpointType::SHARP:
                return ExecuteSharpCheckpoint();
            case CheckpointType::CONSISTENT:
                return ExecuteConsistentCheckpoint();
            default:
                return ExecuteFuzzyCheckpoint();
        }
    }

    // 获取最近的检查点LSN
    LSN GetLastCheckpointLSN() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return last_checkpoint_lsn_;
    }

    // 设置检查点回调
    void SetCheckpointCallback(std::function<void(LSN)> callback) {
        checkpoint_callback_ = callback;
    }

private:
    LogManager* log_manager_;
    WriteAheadLogManager* wal_manager_;
    CheckpointConfig config_;
    std::atomic<LSN> last_checkpoint_lsn_{0};
    std::atomic<bool> running_;
    std::unique_ptr<std::thread> checkpoint_thread_;
    std::mutex mutex_;
    std::function<void(LSN)> checkpoint_callback_;

    // 执行模糊检查点
    LSN ExecuteFuzzyCheckpoint() {
        auto start_time = std::chrono::steady_clock::now();

        // 1. 记录检查点开始日志
        auto checkpoint_start_lsn = log_manager_->LogCheckpoint();

        // 2. 获取当前活动事务状态
        auto active_txns = GetActiveTransactions();

        // 3. 获取脏页面信息
        auto dirty_pages = GetDirtyPages();

        // 4. 创建检查点记录
        CheckpointRecord record;
        record.checkpoint_lsn = checkpoint_start_lsn;
        record.timestamp = GetTickCount();
        record.type = CheckpointType::FUZZY;
        record.active_transactions = active_txns.first;
        record.transaction_lsns = active_txns.second;
        record.dirty_pages = dirty_pages;

        // 5. 写入检查点记录到控制文件
        WriteCheckpointRecord(record);

        // 6. 异步刷新脏页面
        std::thread flush_thread([this, dirty_pages]() {
            FlushDirtyPages(dirty_pages);
        });
        flush_thread.detach();

        // 7. 记录检查点完成日志
        auto checkpoint_end_lsn = log_manager_->LogCheckpoint();

        // 8. 更新最后检查点LSN
        last_checkpoint_lsn_.store(checkpoint_end_lsn);

        auto end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end_time - start_time).count();

        std::cout << "Fuzzy checkpoint completed in " << duration << " ms" << std::endl;

        // 调用回调
        if (checkpoint_callback_) {
            checkpoint_callback_(checkpoint_end_lsn);
        }

        return checkpoint_end_lsn;
    }

    // 执行精确检查点
    LSN ExecuteSharpCheckpoint() {
        auto start_time = std::chrono::steady_clock::now();

        // 1. 记录检查点开始日志
        auto checkpoint_start_lsn = log_manager_->LogCheckpoint();

        // 2. 暂停所有事务
        PauseAllTransactions();

        // 3. 刷新所有脏页面到磁盘
        FlushAllDirtyPages();

        // 4. 记录检查点完成日志
        auto checkpoint_end_lsn = log_manager_->LogCheckpoint();

        // 5. 恢复所有事务
        ResumeAllTransactions();

        // 6. 创建检查点记录
        CheckpointRecord record;
        record.checkpoint_lsn = checkpoint_end_lsn;
        record.timestamp = GetTickCount();
        record.type = CheckpointType::SHARP;
        // 精确检查点不需要记录活动事务，因为所有页面都已刷新

        // 7. 写入检查点记录
        WriteCheckpointRecord(record);

        // 8. 更新最后检查点LSN
        last_checkpoint_lsn_.store(checkpoint_end_lsn);

        auto end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end_time - start_time).count();

        std::cout << "Sharp checkpoint completed in " << duration << " ms" << std::endl;

        // 调用回调
        if (checkpoint_callback_) {
            checkpoint_callback_(checkpoint_end_lsn);
        }

        return checkpoint_end_lsn;
    }

    // 执行一致性检查点
    LSN ExecuteConsistentCheckpoint() {
        // 一致性检查点是精确检查点的变体，确保数据库处于一致状态
        return ExecuteSharpCheckpoint();
    }

    // 获取活动事务
    std::pair<std::vector<TransactionId>, std::vector<std::pair<TransactionId, LSN>>>
    GetActiveTransactions() {
        // 需要与事务管理器协作获取活动事务信息
        std::vector<TransactionId> active_txns;
        std::vector<std::pair<TransactionId, LSN>> txn_lsns;

        // 这里应该调用事务管理器的接口
        // 简化实现
        return {active_txns, txn_lsns};
    }

    // 获取脏页面
    std::vector<PageId> GetDirtyPages() {
        // 需要与缓冲池管理器协作获取脏页面信息
        std::vector<PageId> dirty_pages;

        // 这里应该调用缓冲池管理器的接口
        // 简化实现
        return dirty_pages;
    }

    // 写入检查点记录
    void WriteCheckpointRecord(const CheckpointRecord& record) {
        // 序列化检查点记录并写入控制文件
        auto serialized = SerializeCheckpointRecord(record);

        // 写入到检查点控制文件
        std::ofstream checkpoint_file("checkpoint.ctl", std::ios::binary);
        if (checkpoint_file) {
            checkpoint_file.write(serialized.data(), serialized.size());
        }
    }

    // 序列化检查点记录
    std::vector<char> SerializeCheckpointRecord(const CheckpointRecord& record) {
        std::vector<char> data;
        size_t offset = 0;

        // 检查点LSN
        data.insert(data.end(), reinterpret_cast<const char*>(&record.checkpoint_lsn),
                   reinterpret_cast<const char*>(&record.checkpoint_lsn) + sizeof(record.checkpoint_lsn));
        offset += sizeof(record.checkpoint_lsn);

        // 时间戳
        data.insert(data.end(), reinterpret_cast<const char*>(&record.timestamp),
                   reinterpret_cast<const char*>(&record.timestamp) + sizeof(record.timestamp));
        offset += sizeof(record.timestamp);

        // 检查点类型
        uint32_t type = static_cast<uint32_t>(record.type);
        data.insert(data.end(), reinterpret_cast<const char*>(&type),
                   reinterpret_cast<const char*>(&type) + sizeof(type));
        offset += sizeof(type);

        // 活动事务数量
        uint32_t active_count = static_cast<uint32_t>(record.active_transactions.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&active_count),
                   reinterpret_cast<const char*>(&active_count) + sizeof(active_count));
        offset += sizeof(active_count);

        // 活动事务
        for (auto txn_id : record.active_transactions) {
            data.insert(data.end(), reinterpret_cast<const char*>(&txn_id),
                       reinterpret_cast<const char*>(&txn_id) + sizeof(txn_id));
        }

        // 事务LSN数量
        uint32_t txn_lsn_count = static_cast<uint32_t>(record.transaction_lsns.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&txn_lsn_count),
                   reinterpret_cast<const char*>(&txn_lsn_count) + sizeof(txn_lsn_count));

        // 事务LSN
        for (const auto& [txn_id, lsn] : record.transaction_lsns) {
            data.insert(data.end(), reinterpret_cast<const char*>(&txn_id),
                       reinterpret_cast<const char*>(&txn_id) + sizeof(txn_id));
            data.insert(data.end(), reinterpret_cast<const char*>(&lsn),
                       reinterpret_cast<const char*>(&lsn) + sizeof(lsn));
        }

        // 脏页面数量
        uint32_t dirty_count = static_cast<uint32_t>(record.dirty_pages.size());
        data.insert(data.end(), reinterpret_cast<const char*>(&dirty_count),
                   reinterpret_cast<const char*>(&dirty_count) + sizeof(dirty_count));

        // 脏页面
        for (auto page_id : record.dirty_pages) {
            data.insert(data.end(), reinterpret_cast<const char*>(&page_id),
                       reinterpret_cast<const char*>(&page_id) + sizeof(page_id));
        }

        return data;
    }

    // 刷新脏页面
    void FlushDirtyPages(const std::vector<PageId>& dirty_pages) {
        // 异步刷新脏页面到磁盘
        for (auto page_id : dirty_pages) {
            // 调用缓冲池管理器的刷新接口
            // BufferPoolManager::GetInstance().FlushPage(page_id);
        }
    }

    // 刷新所有脏页面
    void FlushAllDirtyPages() {
        // 刷新所有脏页面到磁盘
        // 调用缓冲池管理器的刷新接口
        // BufferPoolManager::GetInstance().FlushAllDirtyPages();
    }

    // 暂停所有事务
    void PauseAllTransactions() {
        // 通知事务管理器暂停新事务
        // TransactionManager::GetInstance().Pause();
    }

    // 恢复所有事务
    void ResumeAllTransactions() {
        // 通知事务管理器恢复事务
        // TransactionManager::GetInstance().Resume();
    }

    // 启动后台检查点
    void StartBackgroundCheckpoint() {
        running_ = true;
        checkpoint_thread_ = std::make_unique<std::thread>([this]() {
            BackgroundCheckpointWorker();
        });
    }

    // 停止后台检查点
    void StopBackgroundCheckpoint() {
        running_ = false;
        if (checkpoint_thread_ && checkpoint_thread_->joinable()) {
            checkpoint_thread_->join();
        }
    }

    // 后台检查点工作线程
    void BackgroundCheckpointWorker() {
        while (running_) {
            // 等待检查点间隔或触发条件
            if (ShouldExecuteCheckpoint()) {
                ExecuteCheckpoint();
            }

            // 等待下一次检查
            std::this_thread::sleep_for(std::chrono::milliseconds(config_.interval_ms));
        }
    }

    // 检查是否应该执行检查点
    bool ShouldExecuteCheckpoint() {
        // 基于时间间隔
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            now - last_checkpoint_time_).count();

        if (elapsed >= config_.interval_ms) {
            return true;
        }

        // 基于脏页面数量
        auto dirty_page_count = GetDirtyPages().size();
        if (dirty_page_count >= config_.max_dirty_pages) {
            return true;
        }

        // 基于内存使用
        double memory_usage = GetMemoryUsage();
        if (memory_usage >= config_.memory_threshold) {
            return true;
        }

        return false;
    }

    // 获取内存使用率
    double GetMemoryUsage() {
        // 获取当前内存使用率
        return 0.5;  // 简化实现
    }

    uint64_t GetTickCount() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }

    std::chrono::steady_clock::time_point last_checkpoint_time_ =
        std::chrono::steady_clock::now();
};
```

## 实践练习

### 练习1：实现基本日志系统

```cpp
// 练习：实现基本日志系统
class BasicLogSystem {
public:
    bool LogBegin(TransactionId txn_id) {
        // 学生需要实现事务开始日志记录
        // 1. 创建日志记录
        // 2. 序列化数据
        // 3. 写入日志文件
        return false;
    }

    bool LogUpdate(
        TransactionId txn_id,
        const Key& key,
        const Value& old_value,
        const Value& new_value
    ) {
        // 学生需要实现更新日志记录
        // 1. 创建更新记录
        // 2. 记录前后镜像
        // 3. 写入日志
        return false;
    }

    bool LogCommit(TransactionId txn_id) {
        // 学生需要实现提交日志记录
        // 1. 创建提交记录
        // 2. 确保日志持久化
        // 3. 更新事务状态
        return false;
    }

    bool Recover() {
        // 学生需要实现基本恢复逻辑
        // 1. 重做已提交事务
        // 2. 撤销未提交事务
        // 3. 恢复数据库状态
        return false;
    }

private:
    // 学生需要定义必要的数据结构
};
```

### 练习2：实现预写日志协议

```cpp
// 练习：实现预写日志协议
class WALProtocolImplementation {
public:
    bool BeginTransaction(TransactionId txn_id) {
        // 学生需要实现WAL事务开始
        // 1. 记录BEGIN日志
        // 2. 分配事务空间
        // 3. 初始化事务状态
        return false;
    }

    bool UpdatePage(
        TransactionId txn_id,
        PageId page_id,
        const std::vector<char>& data
    ) {
        // 学生需要实现WAL页面更新
        // 1. 记录UNDO日志
        // 2. 记录REDO日志
        // 3. 应用页面修改
        return false;
    }

    bool CommitTransaction(TransactionId txn_id) {
        // 学生需要实现WAL事务提交
        // 1. 记录COMMIT日志
        // 2. 确保日志持久化
        // 3. 释放事务资源
        return false;
    }

    bool AbortTransaction(TransactionId txn_id) {
        // 学生需要实现WAL事务终止
        // 1. 记录ABORT日志
        // 2. 执行UNDO操作
        // 3. 释放事务资源
        return false;
    }

private:
    // 学生需要定义必要的数据结构
};
```

### 练习3：实现检查点机制

```cpp
// 练习：实现检查点机制
class CheckpointImplementation {
public:
    bool ExecuteCheckpoint() {
        // 学生需要实现检查点执行
        // 1. 获取活动事务状态
        // 2. 记录检查点日志
        // 3. 刷新脏页面
        // 4. 保存检查点信息
        return false;
    }

    bool LoadCheckpoint() {
        // 学生需要实现检查点加载
        // 1. 读取检查点记录
        // 2. 恢复系统状态
        // 3. 准备恢复过程
        return false;
    }

    bool PerformRecovery() {
        // 学生需要实现基于检查点的恢复
        // 1. 从检查点开始扫描日志
        // 2. 重做已提交事务
        // 3. 撤销未提交事务
        return false;
    }

    void SetCheckpointInterval(uint64_t interval_ms) {
        // 学生需要实现检查点间隔设置
        // 1. 更新配置
        // 2. 重启定时器
    }

private:
    // 学生需要定义必要的数据结构
};
```

## 总结

日志与恢复是数据库系统的核心机制，通过本讲的学习，我们掌握了：

1. **日志记录格式**：理解了各种日志记录的结构和序列化方法
2. **预写日志协议**：掌握了WAL协议的原理和实现
3. **日志管理器**：学会了高效的日志记录管理和优化技术
4. **检查点机制**：理解了不同类型检查点的实现和优化
5. **WAL优化**：了解了组提交、日志压缩等性能优化技术

日志系统确保了数据库的ACID特性中的持久性，通过预写日志协议保证了即使在系统故障情况下数据的一致性和完整性。检查点机制则显著减少了恢复时间，提高了系统的可用性。

在下一讲中，我们将深入探讨恢复算法，包括ARIES算法等先进的恢复技术。

## 进一步学习

- [ARIES: A Transaction Recovery Method](https://dl.acm.org/doi/10.1145/170036.170072)
- [Write-Ahead Logging](https://en.wikipedia.org/wiki/Write-ahead_logging)
- [Database Recovery Techniques](https://www.db-book.com/)
- [PostgreSQL WAL Documentation](https://www.postgresql.org/docs/current/wal.html)
- [Oracle Redo Log Documentation](https://docs.oracle.com/en/database/oracle/oracle-database/21/admin/managing-the-redo-log.html)