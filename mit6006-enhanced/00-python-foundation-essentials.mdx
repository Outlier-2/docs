---
title: "Python基础 essentials与函数式编程核心库"
description: "深入理解Python语言基础、核心类库和函数式编程工具包"
category: "Python基础"
tags: ["Python基础", "核心库", "函数式工具", "数据结构"]
difficulty: "初级到中级"
---

# Python基础 essentials与函数式编程核心库

## 概念概览

在深入学习函数式编程和高级算法之前，我们需要牢固掌握Python语言的基础知识和核心类库。本章将从函数式编程的角度重新审视Python基础，重点介绍那些对函数式编程至关重要的语言特性和库函数。

## Python语言基础回顾

### 1. Python的数据类型系统

#### 1.1 基本数据类型的函数式特性

```python
# 数字类型 - 不可变，支持函数式操作
numbers = [1, 2, 3, 4, 5]

# 函数式数字处理
def process_numbers(nums):
    """使用函数式方式处理数字"""
    return list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, nums)))

print(process_numbers(numbers))  # [4, 16]

# 字符串 - 不可变，天然适合函数式编程
text = "hello functional programming"

# 函数式字符串处理
def process_text(text):
    """函数式文本处理"""
    return (
        text.split()                    # 分词
        |> map(str.upper)              # 转大写
        |> filter(lambda x: len(x) > 4)  # 过滤长词
        |> list                        # 转换为列表
    )

# 模拟管道操作符
def pipeline(data, *operations):
    result = data
    for operation in operations:
        result = operation(result)
    return result

result = pipeline(
    text.split(),
    lambda x: map(str.upper, x),
    lambda x: filter(lambda word: len(word) > 4, x),
    list
)
print(result)  # ['HELLO', 'FUNCTIONAL', 'PROGRAMMING']
```

#### 1.2 容器类型的函数式操作

```python
from typing import List, Dict, Set, Tuple
from functools import reduce

# 列表推导式 - 函数式编程的精髓
def list_comprehensions_demo():
    """列表推导式的各种用法"""
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # 基本推导式
    squares = [x ** 2 for x in numbers]
    print(f"Squares: {squares}")

    # 带条件的推导式
    even_squares = [x ** 2 for x in numbers if x % 2 == 0]
    print(f"Even squares: {even_squares}")

    # 多重推导式
    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    flattened = [num for row in matrix for num in row if num % 2 == 0]
    print(f"Flattened evens: {flattened}")

    # 字典推导式
    word_lengths = {word: len(word) for word in text.split()}
    print(f"Word lengths: {word_lengths}")

    # 集合推导式
    unique_lengths = {len(word) for word in text.split()}
    print(f"Unique lengths: {unique_lengths}")

list_comprehensions_demo()
```

### 2. 函数定义和作用域

#### 2.1 函数的深入理解

```python
from typing import Callable, Any, List
from functools import wraps
import inspect

def function_basics():
    """函数基础概念的深入理解"""

    # 函数是一等公民
    def greet(name: str) -> str:
        return f"Hello, {name}!"

    # 函数可以作为变量
    greeting = greet
    print(greeting("Alice"))  # Hello, Alice!

    # 函数可以作为参数
    def apply_operation(func: Callable, x: Any, y: Any) -> Any:
        return func(x, y)

    def add(a: int, b: int) -> int:
        return a + b

    def multiply(a: int, b: int) -> int:
        return a * b

    print(apply_operation(add, 5, 3))      # 8
    print(apply_operation(multiply, 5, 3)) # 15

    # 函数可以作为返回值
    def make_multiplier(n: int) -> Callable[[int], int]:
        """制造乘法器的工厂函数"""
        def multiplier(x: int) -> int:
            return x * n
        return multiplier

    double = make_multiplier(2)
    triple = make_multiplier(3)
    print(double(5))  # 10
    print(triple(5))  # 15

    # 函数的元数据
    print(f"Function name: {greet.__name__}")
    print(f"Function doc: {greet.__doc__}")
    print(f"Function annotations: {greet.__annotations__}")

function_basics()
```

#### 2.2 闭包和作用域

```python
def closures_and_scopes():
    """闭包和作用域的深入理解"""

    # 闭包：函数可以记住其定义时的环境
    def create_counter():
        """创建计数器的工厂函数"""
        count = 0

        def increment():
            nonlocal count
            count += 1
            return count

        def reset():
            nonlocal count
            count = 0
            return count

        return increment, reset

    inc1, reset1 = create_counter()
    inc2, reset2 = create_counter()

    print(inc1())  # 1
    print(inc1())  # 2
    print(inc2())  # 1 (独立的闭包)

    reset1()
    print(inc1())  # 1

    # 闭包的实际应用：配置函数
    def create_data_processor(config: Dict[str, Any]):
        """创建数据处理器的工厂函数"""
        def process_data(data: List[Any]) -> List[Any]:
            result = data.copy()

            # 应用配置中的转换
            if config.get('uppercase', False):
                result = [str(item).upper() for item in result]

            if config.get('filter_empty', True):
                result = [item for item in result if item]

            if config.get('max_length'):
                result = result[:config['max_length']]

            return result

        return process_data

    # 创建不同的处理器
    strict_processor = create_data_processor({
        'uppercase': True,
        'filter_empty': True,
        'max_length': 5
    })

    lenient_processor = create_data_processor({
        'uppercase': False,
        'filter_empty': False
    })

    data = ['hello', '', 'world', 'python', 'functional']
    print(strict_processor(data))  # ['HELLO', 'WORLD', 'PYTHON', 'FUNCTIONAL']
    print(lenient_processor(data))  # ['hello', '', 'world', 'python', 'functional']

closures_and_scopes()
```

### 3. 装饰器和元编程

#### 3.1 装饰器的深入应用

```python
def decorators_deep_dive():
    """装饰器的深入理解和应用"""

    # 基础装饰器
    def timing_decorator(func):
        """计时装饰器"""
        import time

        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            print(f"{func.__name__} took {end_time - start_time:.6f} seconds")
            return result

        return wrapper

    # 带参数的装饰器
    def retry(max_attempts: int = 3, delay: float = 1.0):
        """重试装饰器"""
        def decorator(func):
            import time

            @wraps(func)
            def wrapper(*args, **kwargs):
                for attempt in range(max_attempts):
                    try:
                        return func(*args, **kwargs)
                    except Exception as e:
                        if attempt == max_attempts - 1:
                            raise e
                        print(f"Attempt {attempt + 1} failed: {e}. Retrying...")
                        time.sleep(delay)
                return None
            return wrapper
        return decorator

    # 缓存装饰器
    def memoize(func):
        """记忆化装饰器"""
        cache = {}

        @wraps(func)
        def wrapper(*args, **kwargs):
            # 创建缓存键
            key = str(args) + str(kwargs)
            if key not in cache:
                cache[key] = func(*args, **kwargs)
            return cache[key]

        wrapper.cache_info = lambda: f"Cache size: {len(cache)}"
        return wrapper

    # 应用装饰器
    @timing_decorator
    @retry(max_attempts=3, delay=0.1)
    def expensive_computation(n: int) -> int:
        """昂贵的计算"""
        import time
        time.sleep(0.1)
        if n < 0:
            raise ValueError("Negative number not allowed")
        return sum(i ** 2 for i in range(n))

    @memoize
    def fibonacci(n: int) -> int:
        """斐波那契数列"""
        if n <= 1:
            return n
        return fibonacci(n - 1) + fibonacci(n - 2)

    # 测试装饰器
    print("Testing timing and retry decorators:")
    result = expensive_computation(10)
    print(f"Result: {result}")

    print("\nTesting memoization:")
    print(f"Fibonacci(35): {fibonacci(35)}")
    print(f"Cache info: {fibonacci.cache_info()}")

decorators_deep_dive()
```

#### 3.2 类装饰器和元类

```python
def class_decorators_and_metaclasses():
    """类装饰器和元类的深入理解"""

    # 类装饰器
    def add_class_attributes(cls):
        """添加类属性的装饰器"""
        cls.class_version = "1.0"
        cls.created_at = "2024-01-01"
        return cls

    def singleton(cls):
        """单例模式装饰器"""
        instances = {}

        def get_instance(*args, **kwargs):
            if cls not in instances:
                instances[cls] = cls(*args, **kwargs)
            return instances[cls]

        return get_instance

    # 元类
    class ValidationMeta(type):
        """验证元类：确保类包含特定方法"""

        def __new__(metacls, name, bases, namespace):
            # 检查是否包含必要的方法
            required_methods = ['validate', 'process']

            for method in required_methods:
                if method not in namespace:
                    raise TypeError(f"Class {name} must implement {method} method")

            return super().__new__(metacls, name, bases, namespace)

    # 使用类装饰器
    @add_class_attributes
    @singleton
    class DataProcessor:
        """数据处理器类"""

        def __init__(self, name: str):
            self.name = name

        def process(self, data: List[Any]) -> List[Any]:
            return [item * 2 for item in data]

    # 使用元类
    class ValidatedProcessor(metaclass=ValidationMeta):
        """经过验证的处理器"""

        def validate(self, data: List[Any]) -> bool:
            """验证数据"""
            return all(isinstance(item, (int, float)) for item in data)

        def process(self, data: List[Any]) -> List[Any]:
            """处理数据"""
            if not self.validate(data):
                raise ValueError("Invalid data")
            return [item ** 2 for item in data]

    # 测试
    processor1 = DataProcessor("Processor1")
    processor2 = DataProcessor("Processor2")
    print(f"Same instance: {processor1 is processor2}")  # True
    print(f"Class version: {DataProcessor.class_version}")

    validated_proc = ValidatedProcessor()
    try:
        result = validated_proc.process([1, 2, 3])
        print(f"Validated result: {result}")
    except ValueError as e:
        print(f"Error: {e}")

class_decorators_and_metaclasses()
```

## Python函数式编程核心库

### 1. functools模块

#### 1.1 高阶函数工具

```python
from functools import partial, reduce, wraps, lru_cache, cmp_to_key
import operator

def functools_deep_dive():
    """functools模块的深入应用"""

    # partial函数：部分参数应用
    def power(base: float, exponent: float) -> float:
        return base ** exponent

    square = partial(power, exponent=2)
    cube = partial(power, exponent=3)
    sqrt = partial(power, exponent=0.5)

    print(f"Square of 4: {square(4)}")    # 16.0
    print(f"Cube of 3: {cube(3)}")        # 27.0
    print(f"Square root of 16: {sqrt(16)}") # 4.0

    # reduce函数：归约操作
    numbers = [1, 2, 3, 4, 5]

    sum_result = reduce(operator.add, numbers, 0)
    product_result = reduce(operator.mul, numbers, 1)
    max_result = reduce(lambda a, b: a if a > b else b, numbers)

    print(f"Sum: {sum_result}")        # 15
    print(f"Product: {product_result}") # 120
    print(f"Max: {max_result}")        # 5

    # lru_cache：最近最少使用缓存
    @lru_cache(maxsize=128)
    def expensive_function(x: int, y: int) -> int:
        """昂贵的函数"""
        import time
        time.sleep(0.1)
        return x * y

    # 第一次调用会计算
    print("First call:")
    result1 = expensive_function(10, 20)

    # 第二次调用会从缓存获取
    print("Second call (cached):")
    result2 = expensive_function(10, 20)

    print(f"Results: {result1}, {result2}")
    print(f"Cache info: {expensive_function.cache_info()}")

    # cmp_to_key：将比较函数转换为键函数
    def custom_compare(a, b):
        """自定义比较函数"""
        if a[1] > b[1]:
            return 1
        elif a[1] < b[1]:
            return -1
        else:
            return 0

    students = [('Alice', 85), ('Bob', 92), ('Charlie', 78)]
    sorted_students = sorted(students, key=cmp_to_key(custom_compare))
    print(f"Sorted students: {sorted_students}")

functools_deep_dive()
```

#### 1.2 装饰器和函数工具

```python
def advanced_functional_tools():
    """高级函数式工具"""

    # 自定义lru_cache实现
    def custom_lru_cache(maxsize=128):
        """自定义LRU缓存装饰器"""
        def decorator(func):
            cache = {}
            usage_order = []

            @wraps(func)
            def wrapper(*args, **kwargs):
                # 创建缓存键
                key = str(args) + str(sorted(kwargs.items()))

                if key in cache:
                    # 更新使用顺序
                    usage_order.remove(key)
                    usage_order.append(key)
                    return cache[key]

                # 计算新值
                result = func(*args, **kwargs)

                # 缓存结果
                cache[key] = result
                usage_order.append(key)

                # 如果缓存满了，移除最久使用的项
                if len(cache) > maxsize:
                    oldest_key = usage_order.pop(0)
                    del cache[oldest_key]

                return result

            wrapper.cache_info = lambda: {
                'hits': len(usage_order),
                'size': len(cache),
                'maxsize': maxsize
            }

            return wrapper
        return decorator

    # 自定义partial实现
    def custom_partial(func, *args, **kwargs):
        """自定义partial函数"""
        def wrapped(*more_args, **more_kwargs):
            combined_args = args + more_args
            combined_kwargs = {**kwargs, **more_kwargs}
            return func(*combined_args, **combined_kwargs)
        return wrapped

    # 应用自定义工具
    @custom_lru_cache(maxsize=3)
    def api_call(endpoint: str, params: Dict = None) -> str:
        """模拟API调用"""
        import time
        time.sleep(0.05)
        return f"Response from {endpoint} with params {params}"

    # 测试缓存
    print("Testing custom LRU cache:")
    result1 = api_call('/users', {'page': 1})
    result2 = api_call('/users', {'page': 1})  # 缓存命中
    result3 = api_call('/posts', {'page': 1})  # 新缓存
    result4 = api_call('/users', {'page': 2})  # 新缓存

    cache_info = api_call.cache_info()
    print(f"Cache info: {cache_info}")

    # 测试自定义partial
    add_numbers = lambda a, b, c: a + b + c
    add_two_and_three = custom_partial(add_numbers, 2, 3)
    result = add_two_and_three(10)  # 2 + 3 + 10 = 15
    print(f"Partial result: {result}")

advanced_functional_tools()
```

### 2. itertools模块

#### 2.1 无限迭代器和组合工具

```python
from itertools import count, cycle, repeat, chain, combinations, permutations
from itertools import islice, takewhile, dropwhile, groupby

def itertools_demonstration():
    """itertools模块的全面演示"""

    # 无限迭代器
    print("=== Infinite Iterators ===")

    # count: 无限计数器
    counter = count(10, 2)  # 从10开始，步长为2
    first_5 = list(islice(counter, 5))
    print(f"Count (10, +2): {first_5}")  # [10, 12, 14, 16, 18]

    # cycle: 无限循环
    colors = cycle(['red', 'green', 'blue'])
    first_6_colors = list(islice(colors, 6))
    print(f"Cycle colors: {first_6_colors}")  # ['red', 'green', 'blue', 'red', 'green', 'blue']

    # repeat: 无限重复
    repeated = repeat('hello', 3)
    print(f"Repeat: {list(repeated)}")  # ['hello', 'hello', 'hello']

    # 组合工具
    print("\n=== Combination Tools ===")

    # combinations: 组合（顺序不重要）
    items = ['A', 'B', 'C']
    combos = list(combinations(items, 2))
    print(f"Combinations of 2: {combos}")  # [('A', 'B'), ('A', 'C'), ('B', 'C')]

    # permutations: 排列（顺序重要）
    perms = list(permutations(items, 2))
    print(f"Permutations of 2: {perms}")  # [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]

    # product: 笛卡尔积
    from itertools import product
    cartesian = list(product([1, 2], ['A', 'B']))
    print(f"Cartesian product: {cartesian}")  # [(1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]

    # 过滤工具
    print("\n=== Filtering Tools ===")

    numbers = [1, 4, 6, 8, 9, 10, 12, 15]

    # takewhile: 满足条件时取元素
    take_while_even = list(takewhile(lambda x: x % 2 == 0, numbers))
    print(f"Take while even: {take_while_even}")  # [4, 6, 8]

    # dropwhile: 满足条件时跳过元素
    drop_while_even = list(dropwhile(lambda x: x % 2 == 0, numbers))
    print(f"Drop while even: {drop_while_even}")  # [9, 10, 12, 15]

    # groupby: 分组
    data = [
        {'name': 'Alice', 'department': 'Engineering'},
        {'name': 'Bob', 'department': 'Marketing'},
        {'name': 'Charlie', 'department': 'Engineering'},
        {'name': 'David', 'department': 'Marketing'}
    ]

    # 按部门分组
    sorted_data = sorted(data, key=lambda x: x['department'])
    grouped = groupby(sorted_data, key=lambda x: x['department'])

    print("Grouped by department:")
    for department, group in grouped:
        print(f"{department}: {[person['name'] for person in group]}")

    # 链式操作
    print("\n=== Chaining ===")

    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    list3 = [7, 8, 9]

    # chain: 链接多个迭代器
    chained = list(chain(list1, list2, list3))
    print(f"Chained lists: {chained}")  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

    # 复杂的函数式数据处理管道
    def functional_data_processing():
        """函数式数据处理管道示例"""

        # 生成测试数据
        data = range(1, 101)  # 1到100的数字

        # 处理管道
        result = (
            data
            |> filter(lambda x: x % 2 == 0)     # 过滤偶数
            |> map(lambda x: x ** 2)            # 平方
            |> filter(lambda x: x > 1000)       # 过滤大于1000
            |> takewhile(lambda x: x < 5000)   # 取小于5000
            |> list                           # 转换为列表
        )

        print(f"Processing pipeline result: {result}")

    functional_data_processing()

itertools_demonstration()
```

### 3. operator模块

#### 3.1 函数式操作符

```python
import operator
from functools import reduce

def operator_module_demo():
    """operator模块的函数式应用"""

    # 算术操作符
    numbers = [1, 2, 3, 4, 5]

    sum_result = reduce(operator.add, numbers, 0)
    product_result = reduce(operator.mul, numbers, 1)
    max_result = reduce(operator.max, numbers)

    print(f"Sum: {sum_result}")
    print(f"Product: {product_result}")
    print(f"Max: {max_result}")

    # 比较操作符
    students = [('Alice', 85), ('Bob', 92), ('Charlie', 78)]
    sorted_by_score = sorted(students, key=operator.itemgetter(1))
    print(f"Sorted by score: {sorted_by_score}")

    # 逻辑操作符
    values = [True, False, True, False]
    all_true = reduce(operator.and_, values, True)
    any_true = reduce(operator.or_, values, False)

    print(f"All true: {all_true}")
    print(f"Any true: {any_true}")

    # 属性访问和项目获取
    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age

    people = [Person('Alice', 25), Person('Bob', 30), Person('Charlie', 35)]

    # 使用operator.attrgetter获取属性
    names = list(map(operator.attrgetter('name'), people))
    ages = list(map(operator.attrgetter('age'), people))

    print(f"Names: {names}")
    print(f"Ages: {ages}")

    # 使用operator.itemgetter获取字典项
    data = [
        {'name': 'Alice', 'score': 85},
        {'name': 'Bob', 'score': 92},
        {'name': 'Charlie', 'score': 78}
    ]

    names = list(map(operator.itemgetter('name'), data))
    scores = list(map(operator.itemgetter('score'), data))

    print(f"Data names: {names}")
    print(f"Data scores: {scores}")

    # 方法调用
    strings = ['hello', 'world', 'python']
    upper_strings = list(map(operator.methodcaller('upper'), strings))
    print(f"Uppercase strings: {upper_strings}")

operator_module_demo()
```

## Python函数式编程最佳实践

### 1. 性能优化策略

#### 1.1 惰性求值和生成器

```python
def performance_optimization():
    """函数式编程的性能优化"""

    # 生成器 vs 列表
    def create_large_list(n):
        """创建大列表（内存密集）"""
        return [i ** 2 for i in range(n)]

    def create_large_generator(n):
        """创建大生成器（内存高效）"""
        return (i ** 2 for i in range(n))

    # 内存使用对比
    import sys

    large_list = create_large_list(1000000)
    large_generator = create_large_generator(1000000)

    print(f"List size: {sys.getsizeof(large_list)} bytes")
    print(f"Generator size: {sys.getsizeof(large_generator)} bytes")

    # 处理大数据时的性能差异
    def process_data_list(data):
        """使用列表处理数据"""
        return [item for item in data if item > 1000]

    def process_data_generator(data):
        """使用生成器处理数据"""
        return (item for item in data if item > 1000)

    # 测试处理时间
    import time

    start_time = time.time()
    list_result = process_data_list(large_list)
    list_time = time.time() - start_time

    start_time = time.time()
    gen_result = list(process_data_generator(large_generator))
    gen_time = time.time() - start_time

    print(f"List processing time: {list_time:.4f} seconds")
    print(f"Generator processing time: {gen_time:.4f} seconds")

performance_optimization()
```

#### 1.2 并行处理

```python
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import multiprocessing

def parallel_processing():
    """函数式并行处理"""

    # 数据
    numbers = list(range(1, 1000001))

    # 串行处理
    def square_numbers(numbers):
        return [n ** 2 for n in numbers]

    # 并行处理
    def parallel_square_numbers(numbers, workers=None):
        if workers is None:
            workers = multiprocessing.cpu_count()

        with ThreadPoolExecutor(max_workers=workers) as executor:
            # 分块处理
            chunk_size = len(numbers) // workers
            chunks = [numbers[i:i + chunk_size] for i in range(0, len(numbers), chunk_size)]

            results = list(executor.map(
                lambda chunk: [n ** 2 for n in chunk],
                chunks
            ))

            # 合并结果
            return [item for chunk in results for item in chunk]

    # 性能对比
    import time

    start_time = time.time()
    serial_result = square_numbers(numbers)
    serial_time = time.time() - start_time

    start_time = time.time()
    parallel_result = parallel_square_numbers(numbers)
    parallel_time = time.time() - start_time

    print(f"Serial processing time: {serial_time:.4f} seconds")
    print(f"Parallel processing time: {parallel_time:.4f} seconds")
    print(f"Speedup: {serial_time / parallel_time:.2f}x")

    # 验证结果正确性
    print(f"Results match: {serial_result == parallel_result}")

parallel_processing()
```

### 2. 调试和测试

#### 2.1 函数式代码调试

```python
def functional_debugging():
    """函数式代码的调试技巧"""

    # 使用纯函数便于调试
    def pure_function(x, y):
        """纯函数：容易调试和测试"""
        result = x + y
        print(f"Debug: pure_function({x}, {y}) = {result}")
        return result

    # 使用高阶函数进行调试
    def debug_map(func, iterable):
        """带调试信息的map函数"""
        print(f"Debug: Applying function {func.__name__} to iterable")
        result = []
        for i, item in enumerate(iterable):
            mapped = func(item)
            print(f"Debug: item[{i}] {item} -> {mapped}")
            result.append(mapped)
        return result

    # 使用装饰器进行调试
    def debug_decorator(func):
        """调试装饰器"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(f"Debug: Calling {func.__name__} with args={args}, kwargs={kwargs}")
            result = func(*args, **kwargs)
            print(f"Debug: {func.__name__} returned {result}")
            return result
        return wrapper

    # 测试调试工具
    numbers = [1, 2, 3, 4, 5]

    # 调试map
    debug_result = debug_map(lambda x: x ** 2, numbers)
    print(f"Debug map result: {debug_result}")

    # 调试装饰器
    @debug_decorator
    def complex_calculation(x, y, z):
        return x * y + z

    result = complex_calculation(2, 3, 4)

functional_debugging()
```

#### 2.2 函数式代码测试

```python
import unittest
from typing import Callable, Any

def functional_testing():
    """函数式代码的测试策略"""

    # 纯函数测试
    def test_pure_functions():
        """测试纯函数"""
        def add(a, b):
            return a + b

        def multiply(a, b):
            return a * b

        # 单元测试
        assert add(2, 3) == 5
        assert add(-1, 1) == 0
        assert multiply(3, 4) == 12
        assert multiply(0, 5) == 0

        print("Pure function tests passed")

    # 高阶函数测试
    def test_higher_order_functions():
        """测试高阶函数"""
        def apply_twice(func, x):
            return func(func(x))

        def increment(x):
            return x + 1

        def double(x):
            return x * 2

        assert apply_twice(increment, 5) == 7  # increment(increment(5)) = increment(6) = 7
        assert apply_twice(double, 3) == 12    # double(double(3)) = double(6) = 12

        print("Higher-order function tests passed")

    # 函数组合测试
    def test_function_composition():
        """测试函数组合"""
        def compose(f, g):
            return lambda x: f(g(x))

        def square(x):
            return x ** 2

        def increment(x):
            return x + 1

        square_then_increment = compose(increment, square)
        increment_then_square = compose(square, increment)

        assert square_then_increment(3) == 10   # increment(square(3)) = increment(9) = 10
        assert increment_then_square(3) == 16   # square(increment(3)) = square(4) = 16

        print("Function composition tests passed")

    # 测试运行
    test_pure_functions()
    test_higher_order_functions()
    test_function_composition()

functional_testing()
```

## 实际应用案例

### 1. 函数式数据分析

```python
import pandas as pd
import numpy as np

def functional_data_analysis():
    """函数式数据分析示例"""

    # 创建示例数据
    data = {
        'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
        'age': [25, 30, 35, 28, 32],
        'salary': [50000, 60000, 70000, 55000, 65000],
        'department': ['Engineering', 'Marketing', 'Engineering', 'Marketing', 'Engineering']
    }

    df = pd.DataFrame(data)

    # 函数式数据转换
    def transform_salary(salary):
        """转换薪资"""
        return salary * 1.1  # 加薪10%

    def is_high_earner(row):
        """判断是否高收入者"""
        return row['salary'] > 60000

    def age_group(age):
        """年龄分组"""
        if age < 30:
            return 'Young'
        elif age < 35:
            return 'Middle'
        else:
            return 'Senior'

    # 函数式数据处理管道
    processed_data = (
        df.copy()
        .assign(salary=lambda x: x['salary'].apply(transform_salary))
        .assign(age_group=lambda x: x['age'].apply(age_group))
        .assign(high_earner=lambda x: x.apply(is_high_earner, axis=1))
    )

    print("Processed data:")
    print(processed_data)

    # 函数式聚合
    department_stats = (
        processed_data
        .groupby('department')
        .agg({
            'salary': ['mean', 'median', 'std'],
            'age': 'mean',
            'high_earner': 'sum'
        })
    )

    print("\nDepartment statistics:")
    print(department_stats)

functional_data_analysis()
```

### 2. 函数式Web API客户端

```python
import requests
from typing import Dict, List, Any, Optional
from functools import lru_cache

class FunctionalAPIClient:
    """函数式Web API客户端"""

    def __init__(self, base_url: str):
        self.base_url = base_url

    def _make_request(self, endpoint: str, params: Dict = None) -> Dict:
        """发起HTTP请求"""
        url = f"{self.base_url}/{endpoint}"
        response = requests.get(url, params=params)
        response.raise_for_status()
        return response.json()

    @lru_cache(maxsize=100)
    def get_user(self, user_id: int) -> Optional[Dict]:
        """获取用户信息（带缓存）"""
        try:
            return self._make_request(f"users/{user_id}")
        except requests.RequestException:
            return None

    def get_users(self, **filters) -> List[Dict]:
        """获取用户列表"""
        return self._make_request("users", params=filters)

    def filter_users(self, users: List[Dict], **criteria) -> List[Dict]:
        """过滤用户"""
        def matches(user):
            for key, value in criteria.items():
                if key not in user or user[key] != value:
                    return False
            return True

        return list(filter(matches, users))

    def transform_users(self, users: List[Dict], transformations: Dict[str, Callable]) -> List[Dict]:
        """转换用户数据"""
        def transform_user(user):
            result = user.copy()
            for field, transformer in transformations.items():
                if field in result:
                    result[field] = transformer(result[field])
            return result

        return list(map(transform_user, users))

    def aggregate_users(self, users: List[Dict], aggregations: Dict[str, Callable]) -> Dict:
        """聚合用户数据"""
        result = {}
        for field, aggregator in aggregations.items():
            values = [user[field] for user in users if field in user]
            if values:
                result[field] = aggregator(values)
        return result

# 使用示例
def api_client_demo():
    """API客户端演示"""
    # 注意：这里使用模拟数据，实际使用时需要真实的API端点
    client = FunctionalAPIClient("https://jsonplaceholder.typicode.com")

    # 模拟用户数据
    mock_users = [
        {'id': 1, 'name': 'Alice', 'age': 25, 'salary': 50000},
        {'id': 2, 'name': 'Bob', 'age': 30, 'salary': 60000},
        {'id': 3, 'name': 'Charlie', 'age': 35, 'salary': 70000}
    ]

    # 过滤用户
    filtered_users = client.filter_users(mock_users, age=30)
    print(f"Users aged 30: {filtered_users}")

    # 转换用户
    transformations = {
        'salary': lambda x: x * 1.1,
        'name': lambda x: x.upper()
    }
    transformed_users = client.transform_users(mock_users, transformations)
    print(f"Transformed users: {transformed_users}")

    # 聚合用户
    aggregations = {
        'age': lambda x: sum(x) / len(x),
        'salary': lambda x: max(x)
    }
    aggregated = client.aggregate_users(mock_users, aggregations)
    print(f"Aggregated data: {aggregated}")

api_client_demo()
```

## 总结

本章深入探讨了Python语言基础和函数式编程核心库：

### Python基础要点：

1. **数据类型系统**：理解Python中哪些类型适合函数式编程
2. **函数定义**：深入理解函数作为一等公民的概念
3. **闭包和作用域**：掌握闭包在函数式编程中的应用
4. **装饰器和元编程**：使用装饰器增强函数功能

### 核心函数式库：

1. **functools**：高阶函数工具，包括partial、reduce、lru_cache等
2. **itertools**：无限迭代器、组合工具、过滤工具等
3. **operator**：函数式操作符，便于函数组合

### 最佳实践：

1. **性能优化**：惰性求值、生成器、并行处理
2. **调试技巧**：纯函数调试、高阶函数调试
3. **测试策略**：纯函数测试、高阶函数测试

### 实际应用：

1. **数据分析**：使用函数式编程处理数据分析任务
2. **Web API客户端**：构建函数式的API客户端
3. **并发处理**：使用函数式编程实现并行处理

通过掌握这些基础知识和工具，学员可以为后续的函数式算法学习奠定坚实的基础，并在实际项目中应用这些技术构建高效、可维护的软件系统。