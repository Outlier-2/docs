---
title: "L05 - å“ˆå¸Œè¡¨"
description: "æ·±å…¥ç†è§£å“ˆå¸Œè¡¨åŸç†ã€å†²çªè§£å†³ç­–ç•¥å’Œé«˜çº§åº”ç”¨"
---

import { useState, useEffect } from 'react';
import { CodeBlock } from '@/src/components/algorithm';
import { AlgorithmVisualizer } from '@/src/components/algorithm';
import { ArrayVisualizer } from '@/src/components/algorithm';
import { ComplexityAnalyzer } from '@/src/components/algorithm';
import { ExerciseBlock } from '@/src/components/algorithm';

# L05 - å“ˆå¸Œè¡¨

## ğŸ“š å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è®²ä¹‰åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ğŸ” **ç†è§£å“ˆå¸ŒåŸç†**ï¼šæŒæ¡å“ˆå¸Œå‡½æ•°çš„è®¾è®¡å’Œè¯„ä¼°æ–¹æ³•
- âš¡ **è§£å†³å†²çª**ï¼šç²¾é€šå¼€æ”¾å¯»å€æ³•å’Œé“¾åœ°å€æ³•
- ğŸ¯ **ä¼˜åŒ–æ€§èƒ½**ï¼šè®¾è®¡é«˜æ•ˆçš„å“ˆå¸Œè¡¨å®ç°
- ğŸŒ **åº”ç”¨é«˜çº§æ¦‚å¿µ**ï¼šå®ç°å¸ƒéš†è¿‡æ»¤å™¨å’Œä¸€è‡´æ€§å“ˆå¸Œ

## ğŸ¯ å“ˆå¸Œè¡¨åŸºç¡€

### å“ˆå¸Œè¡¨çš„æ ¸å¿ƒæ¦‚å¿µ

å“ˆå¸Œè¡¨æ˜¯ä¸€ç§åŸºäºé”®å€¼å¯¹çš„æ•°æ®ç»“æ„ï¼Œé€šè¿‡å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•ï¼Œå®ç°O(1)å¹³å‡æ—¶é—´å¤æ‚åº¦çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚

**æ ¸å¿ƒç»„æˆ**ï¼š
- **å“ˆå¸Œå‡½æ•°**ï¼šå°†é”®è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•
- **å­˜å‚¨æ•°ç»„**ï¼šå®é™…å­˜å‚¨æ•°æ®çš„åº•å±‚æ•°ç»„
- **å†²çªè§£å†³**ï¼šå¤„ç†å¤šä¸ªé”®æ˜ å°„åˆ°åŒä¸€ç´¢å¼•çš„æƒ…å†µ

### ç†æƒ³çš„å“ˆå¸Œå‡½æ•°ç‰¹æ€§

```python
def hash_function_properties():
    """
    ç†æƒ³å“ˆå¸Œå‡½æ•°çš„å…³é”®ç‰¹æ€§
    """
    properties = {
        "ç¡®å®šæ€§": "ç›¸åŒçš„è¾“å…¥æ€»æ˜¯äº§ç”Ÿç›¸åŒçš„è¾“å‡º",
        "é«˜æ•ˆæ€§": "è®¡ç®—å“ˆå¸Œå€¼åº”è¯¥å¾ˆå¿«",
        "å‡åŒ€æ€§": "é”®å€¼åº”è¯¥å‡åŒ€åˆ†å¸ƒåœ¨æ‰€æœ‰å¯èƒ½çš„æ¡¶ä¸­",
        "ä½å†²çªç‡": "ä¸åŒçš„é”®å¾ˆå°‘äº§ç”Ÿç›¸åŒçš„å“ˆå¸Œå€¼",
        "é›ªå´©æ•ˆåº”": "è¾“å…¥çš„å¾®å°å˜åŒ–ä¼šå¯¼è‡´è¾“å‡ºçš„æ˜¾è‘—å˜åŒ–"
    }

    print("ç†æƒ³å“ˆå¸Œå‡½æ•°ç‰¹æ€§ï¼š")
    for prop, desc in properties.items():
        print(f"â€¢ {prop}: {desc}")

# å“ˆå¸Œå‡½æ•°ç¤ºä¾‹
def simple_hash(key, table_size):
    """ç®€å•çš„å“ˆå¸Œå‡½æ•°"""
    if isinstance(key, str):
        # å­—ç¬¦ä¸²å“ˆå¸Œ
        hash_value = 0
        for char in key:
            hash_value = (hash_value * 31 + ord(char)) % table_size
        return hash_value
    elif isinstance(key, int):
        # æ•´æ•°å“ˆå¸Œ
        return key % table_size
    else:
        # å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
        return simple_hash(str(key), table_size)
```

## ğŸ”§ å“ˆå¸Œå‡½æ•°è®¾è®¡

### 1. é™¤æ³•å“ˆå¸Œ

```python
def division_hash(key, table_size):
    """
    é™¤æ³•å“ˆå¸Œ - æœ€ç®€å•çš„å“ˆå¸Œæ–¹æ³•
    æ—¶é—´å¤æ‚åº¦: O(1)
    """
    return key % table_size

# é€‰æ‹©å¥½çš„è¡¨å¤§å°ï¼ˆç´ æ•°ï¼‰
GOOD_PRIMES = [7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381]

def get_next_prime(n):
    """è·å–å¤§äºç­‰äºnçš„æœ€å°ç´ æ•°"""
    for prime in GOOD_PRIMES:
        if prime >= n:
            return prime
    # å¦‚æœé¢„å®šä¹‰çš„ç´ æ•°ä¸å¤Ÿï¼ŒåŠ¨æ€è®¡ç®—
    return _find_next_prime(n)

def _find_next_prime(n):
    """åŠ¨æ€å¯»æ‰¾ä¸‹ä¸€ä¸ªç´ æ•°"""
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    candidate = n
    while not is_prime(candidate):
        candidate += 1
    return candidate
```

### 2. ä¹˜æ³•å“ˆå¸Œ

```python
def multiplication_hash(key, table_size):
    """
    ä¹˜æ³•å“ˆå¸Œ - Knuthçš„ä¹˜æ³•å“ˆå¸Œæ–¹æ³•
    æ—¶é—´å¤æ‚åº¦: O(1)
    """
    # é»„é‡‘æ¯”ä¾‹ä¹˜æ•°
    A = (5 ** 0.5 - 1) / 2  # â‰ˆ 0.618033988749895
    frac = key * A - int(key * A)
    return int(table_size * frac)

def universal_hashing(a, b, p, m, key):
    """
    å…¨åŸŸå“ˆå¸Œ - éšæœºé€‰æ‹©çš„å“ˆå¸Œå‡½æ•°æ—
    é™ä½æ¶æ„æ”»å‡»å¯¼è‡´çš„æœ€åæƒ…å†µ
    """
    return ((a * key + b) % p) % m

# éšæœºé€‰æ‹©å“ˆå¸Œå‡½æ•°
import random

class UniversalHashFamily:
    """å…¨åŸŸå“ˆå¸Œå‡½æ•°æ—"""
    def __init__(self, table_size):
        self.table_size = table_size
        self.p = self._get_large_prime()
        self.a = random.randint(1, self.p - 1)
        self.b = random.randint(0, self.p - 1)

    def _get_large_prime(self):
        """è·å–ä¸€ä¸ªå¤§çš„ç´ æ•°"""
        return 2147483647  # 2^31 - 1ï¼Œæ˜¯ä¸€ä¸ªå¤§çš„æ¢…æ£®ç´ æ•°

    def hash(self, key):
        return universal_hashing(self.a, self.b, self.p, self.table_size, key)
```

### 3. å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°

```python
def polynomial_rolling_hash(key, table_size, base=31, mod=2**32):
    """
    å¤šé¡¹å¼æ»šåŠ¨å“ˆå¸Œ - é€‚åˆå­—ç¬¦ä¸²
    æ—¶é—´å¤æ‚åº¦: O(len(key))
    """
    hash_value = 0
    power = 1

    for char in key:
        hash_value = (hash_value + (ord(char) * power)) % mod
        power = (power * base) % mod

    return hash_value % table_size

def djb2_hash(key, table_size):
    """
    DJB2å“ˆå¸Œ - å¹¿æ³›ä½¿ç”¨çš„å­—ç¬¦ä¸²å“ˆå¸Œç®—æ³•
    """
    hash_value = 5381
    for char in key:
        hash_value = ((hash_value << 5) + hash_value) + ord(char)
    return hash_value % table_size

def sdbm_hash(key, table_size):
    """
    SDBMå“ˆå¸Œ - å¦ä¸€ä¸ªé«˜æ•ˆçš„å­—ç¬¦ä¸²å“ˆå¸Œç®—æ³•
    """
    hash_value = 0
    for char in key:
        hash_value = ord(char) + (hash_value << 6) + (hash_value << 16) - hash_value
    return hash_value % table_size
```

## âš¡ å†²çªè§£å†³ç­–ç•¥

### 1. é“¾åœ°å€æ³• (Separate Chaining)

```python
class ListNode:
    """é“¾è¡¨èŠ‚ç‚¹"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

class ChainedHashTable:
    """
    ä½¿ç”¨é“¾åœ°å€æ³•çš„å“ˆå¸Œè¡¨
    æ—¶é—´å¤æ‚åº¦:
    - å¹³å‡: O(1 + Î±)ï¼Œå…¶ä¸­Î±æ˜¯è´Ÿè½½å› å­
    - æœ€å: O(n)
    """
    def __init__(self, capacity=11):
        self.capacity = capacity
        self.size = 0
        self.table = [None] * capacity

    def _hash(self, key):
        """å“ˆå¸Œå‡½æ•°"""
        return simple_hash(key, self.capacity)

    def insert(self, key, value):
        """æ’å…¥é”®å€¼å¯¹"""
        index = self._hash(key)

        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥é”®
        current = self.table[index]
        while current:
            if current.key == key:
                current.value = value  # æ›´æ–°å€¼
                return
            current = current.next

        # åˆ›å»ºæ–°èŠ‚ç‚¹
        new_node = ListNode(key, value)
        new_node.next = self.table[index]
        self.table[index] = new_node
        self.size += 1

        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if self.load_factor() > 0.75:
            self._resize(2 * self.capacity)

    def get(self, key):
        """è·å–å€¼"""
        index = self._hash(key)
        current = self.table[index]

        while current:
            if current.key == key:
                return current.value
            current = current.next

        raise KeyError(f"Key '{key}' not found")

    def remove(self, key):
        """åˆ é™¤é”®å€¼å¯¹"""
        index = self._hash(key)
        current = self.table[index]
        prev = None

        while current:
            if current.key == key:
                if prev:
                    prev.next = current.next
                else:
                    self.table[index] = current.next
                self.size -= 1
                return
            prev = current
            current = current.next

        raise KeyError(f"Key '{key}' not found")

    def load_factor(self):
        """è®¡ç®—è´Ÿè½½å› å­"""
        return self.size / self.capacity

    def _resize(self, new_capacity):
        """è°ƒæ•´å“ˆå¸Œè¡¨å¤§å°"""
        old_table = self.table
        self.capacity = new_capacity
        self.table = [None] * new_capacity
        self.size = 0

        # é‡æ–°æ’å…¥æ‰€æœ‰å…ƒç´ 
        for bucket in old_table:
            current = bucket
            while current:
                self.insert(current.key, current.value)
                current = current.next

    def __str__(self):
        result = []
        for i, bucket in enumerate(self.table):
            if bucket:
                items = []
                current = bucket
                while current:
                    items.append(f"{current.key}: {current.value}")
                    current = current.next
                result.append(f"[{i}]: {' -> '.join(items)}")
        return '\n'.join(result)
```

### 2. å¼€æ”¾å¯»å€æ³• (Open Addressing)

#### çº¿æ€§æ¢æµ‹

```python
class LinearProbingHashTable:
    """
    çº¿æ€§æ¢æµ‹å“ˆå¸Œè¡¨
    æ—¶é—´å¤æ‚åº¦:
    - å¹³å‡: O(1/(1-Î±)) å½“Î±<1æ—¶
    - æœ€å: O(n)
    """
    def __init__(self, capacity=11):
        self.capacity = capacity
        self.size = 0
        self.keys = [None] * capacity
        self.values = [None] * capacity
        self.DELETED = object()  # åˆ é™¤æ ‡è®°

    def _hash(self, key):
        return simple_hash(key, self.capacity)

    def _probe(self, key, i):
        """çº¿æ€§æ¢æµ‹å‡½æ•°"""
        return (self._hash(key) + i) % self.capacity

    def insert(self, key, value):
        """æ’å…¥é”®å€¼å¯¹"""
        if self.load_factor() > 0.7:
            self._resize(2 * self.capacity)

        for i in range(self.capacity):
            index = self._probe(key, i)

            if self.keys[index] is None or self.keys[index] is self.DELETED:
                self.keys[index] = key
                self.values[index] = value
                self.size += 1
                return
            elif self.keys[index] == key:
                self.values[index] = value  # æ›´æ–°
                return

        raise Exception("Hash table is full")

    def get(self, key):
        """è·å–å€¼"""
        for i in range(self.capacity):
            index = self._probe(key, i)

            if self.keys[index] is None:
                break
            elif self.keys[index] == key:
                return self.values[index]

        raise KeyError(f"Key '{key}' not found")

    def remove(self, key):
        """åˆ é™¤é”®å€¼å¯¹"""
        for i in range(self.capacity):
            index = self._probe(key, i)

            if self.keys[index] is None:
                break
            elif self.keys[index] == key:
                self.keys[index] = self.DELETED
                self.values[index] = None
                self.size -= 1
                return

        raise KeyError(f"Key '{key}' not found")

    def load_factor(self):
        return self.size / self.capacity

    def _resize(self, new_capacity):
        """è°ƒæ•´å¤§å°"""
        old_keys = self.keys
        old_values = self.values

        self.capacity = new_capacity
        self.keys = [None] * new_capacity
        self.values = [None] * new_capacity
        self.size = 0

        for i in range(len(old_keys)):
            if old_keys[i] is not None and old_keys[i] is not self.DELETED:
                self.insert(old_keys[i], old_values[i])
```

#### äºŒæ¬¡æ¢æµ‹

```python
class QuadraticProbingHashTable:
    """
    äºŒæ¬¡æ¢æµ‹å“ˆå¸Œè¡¨
    æ¢æµ‹åºåˆ—: h(k), h(k)+1, h(k)+4, h(k)+9, ...
    """
    def __init__(self, capacity=11):
        self.capacity = capacity
        self.size = 0
        self.keys = [None] * capacity
        self.values = [None] * capacity
        self.DELETED = object()

    def _hash(self, key):
        return simple_hash(key, self.capacity)

    def _probe(self, key, i):
        """äºŒæ¬¡æ¢æµ‹å‡½æ•°"""
        return (self._hash(key) + i * i) % self.capacity

    def insert(self, key, value):
        if self.load_factor() > 0.5:  # äºŒæ¬¡æ¢æµ‹éœ€è¦æ›´ä½çš„è´Ÿè½½å› å­
            self._resize(2 * self.capacity)

        for i in range(self.capacity):
            index = self._probe(key, i)

            if self.keys[index] is None or self.keys[index] is self.DELETED:
                self.keys[index] = key
                self.values[index] = value
                self.size += 1
                return
            elif self.keys[index] == key:
                self.values[index] = value
                return

        raise Exception("Hash table is full")

    # å…¶ä»–æ–¹æ³•ä¸çº¿æ€§æ¢æµ‹ç±»ä¼¼...

class DoubleHashTable:
    """
    åŒé‡å“ˆå¸Œè¡¨
    ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å“ˆå¸Œå‡½æ•°
    """
    def __init__(self, capacity=11):
        self.capacity = capacity
        self.size = 0
        self.keys = [None] * capacity
        self.values = [None] * capacity
        self.DELETED = object()

    def _hash1(self, key):
        """ç¬¬ä¸€ä¸ªå“ˆå¸Œå‡½æ•°"""
        return simple_hash(key, self.capacity)

    def _hash2(self, key):
        """ç¬¬äºŒä¸ªå“ˆå¸Œå‡½æ•°ï¼ˆå¿…é¡»è¿”å›ä¸capacityäº’è´¨çš„æ•°ï¼‰"""
        hash_val = simple_hash(key, self.capacity - 1)
        return 1 + hash_val  # ç¡®ä¿è¿”å›å€¼ >= 1

    def _probe(self, key, i):
        """åŒé‡å“ˆå¸Œæ¢æµ‹"""
        return (self._hash1(key) + i * self._hash2(key)) % self.capacity

    # æ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤æ–¹æ³•ä¸å…¶ä»–å¼€æ”¾å¯»å€æ³•ç±»ä¼¼...
```

<ExerciseBlock
  title="å†²çªè§£å†³æ¯”è¾ƒ"
  question:"é“¾åœ°å€æ³•å’Œå¼€æ”¾å¯»å€æ³•çš„ä¸»è¦ä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "é“¾åœ°å€æ³•å†…å­˜æ•ˆç‡æ›´é«˜ï¼Œå¼€æ”¾å¯»å€æ³•é€Ÿåº¦æ›´å¿«",
      correct: false,
      explanation: "å¼€æ”¾å¯»å€æ³•é€šå¸¸å†…å­˜æ•ˆç‡æ›´é«˜"
    },
    {
      id: "b",
      text: "é“¾åœ°å€æ³•åœ¨è´Ÿè½½å› å­é«˜æ—¶æ€§èƒ½è¾ƒå¥½ï¼Œå¼€æ”¾å¯»å€æ³•ç¼“å­˜æ€§èƒ½æ›´å¥½",
      correct: true,
      explanation: "æ­£ç¡®ï¼é“¾åœ°å€æ³•åœ¨é«˜è´Ÿè½½æ—¶ä»èƒ½ä¿æŒæ€§èƒ½ï¼Œå¼€æ”¾å¯»å€æ³•æœ‰æ›´å¥½çš„ç¼“å­˜å±€éƒ¨æ€§"
    },
    {
      id: "c",
      text: "å¼€æ”¾å¯»å€æ³•å®ç°æ›´ç®€å•ï¼Œé“¾åœ°å€æ³•æ›´å¤æ‚",
      correct: false,
      explanation: "ä¸¤è€…å®ç°å¤æ‚åº¦ç›¸å½“"
    },
    {
      id: "d",
      text: "ä¸¤è€…åœ¨æ‰€æœ‰æ–¹é¢æ€§èƒ½å®Œå…¨ç›¸åŒ",
      correct: false,
      explanation: "åœ¨ä¸åŒåœºæ™¯ä¸‹å„æœ‰ä¼˜åŠ£"
    }
  ]}
  hint="è€ƒè™‘å†…å­˜ä½¿ç”¨ã€ç¼“å­˜æ•ˆåº”ã€è´Ÿè½½å› å­çš„å½±å“"
/>

## ğŸ¯ é«˜çº§å“ˆå¸ŒæŠ€æœ¯

### 1. åŠ¨æ€æ‰©å®¹ç­–ç•¥

```python
class DynamicHashTable:
    """
    åŠ¨æ€æ‰©å®¹çš„å“ˆå¸Œè¡¨
    æ”¯æŒå¢é‡å¼æ‰©å®¹ï¼Œé¿å…ä¸€æ¬¡æ€§é‡å»ºçš„ä»£ä»·
    """
    def __init__(self, initial_capacity=11):
        self.old_table = None
        self.new_table = [None] * initial_capacity
        self.old_capacity = 0
        self.new_capacity = initial_capacity
        self.size = 0
        self.migration_index = 0
        self.threshold = 0.75

    def _hash(self, key, capacity):
        return simple_hash(key, capacity)

    def insert(self, key, value):
        """æ’å…¥æ“ä½œ"""
        # é¦–å…ˆå¤„ç†è¿ç§»
        self._migrate_if_needed()

        # åœ¨æ–°è¡¨ä¸­æ’å…¥
        index = self._hash(key, self.new_capacity)
        bucket = self.new_table[index]

        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        current = bucket
        while current:
            if current.key == key:
                current.value = value
                return
            current = current.next

        # åˆ›å»ºæ–°èŠ‚ç‚¹
        new_node = ListNode(key, value)
        new_node.next = bucket
        self.new_table[index] = new_node
        self.size += 1

        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if self.load_factor() > self.threshold:
            self._start_migration()

    def get(self, key):
        """è·å–æ“ä½œ"""
        self._migrate_if_needed()

        # åœ¨æ–°è¡¨ä¸­æŸ¥æ‰¾
        index = self._hash(key, self.new_capacity)
        current = self.new_table[index]

        while current:
            if current.key == key:
                return current.value
            current = current.next

        # å¦‚æœæ­£åœ¨è¿ç§»ï¼Œä¹Ÿåœ¨æ—§è¡¨ä¸­æŸ¥æ‰¾
        if self.old_table:
            old_index = self._hash(key, self.old_capacity)
            current = self.old_table[old_index]

            while current:
                if current.key == key:
                    return current.value
                current = current.next

        raise KeyError(f"Key '{key}' not found")

    def _start_migration(self):
        """å¼€å§‹å¢é‡è¿ç§»"""
        self.old_table = self.new_table
        self.old_capacity = self.new_capacity
        self.new_capacity = 2 * self.old_capacity
        self.new_table = [None] * self.new_capacity
        self.migration_index = 0

    def _migrate_if_needed(self):
        """è¿ç§»ä¸€äº›å…ƒç´ """
        if self.old_table is None:
            return

        # æ¯æ¬¡æ“ä½œè¿ç§»ä¸€å®šæ•°é‡çš„å…ƒç´ 
        migrations_per_operation = 5
        migrated = 0

        while migrated < migrations_per_operation and self.migration_index < self.old_capacity:
            if self.old_table[self.migration_index]:
                current = self.old_table[self.migration_index]
                while current:
                    # å°†å…ƒç´ è¿ç§»åˆ°æ–°è¡¨
                    new_index = self._hash(current.key, self.new_capacity)
                    new_node = ListNode(current.key, current.value)
                    new_node.next = self.new_table[new_index]
                    self.new_table[new_index] = new_node
                    current = current.next

            self.migration_index += 1
            migrated += 1

        # æ£€æŸ¥è¿ç§»æ˜¯å¦å®Œæˆ
        if self.migration_index >= self.old_capacity:
            self.old_table = None
            self.old_capacity = 0

    def load_factor(self):
        return self.size / self.new_capacity
```

### 2. å¸ƒéš†è¿‡æ»¤å™¨ (Bloom Filter)

```python
import mmh3  # MurmurHash3ï¼Œéœ€è¦å®‰è£…

class BloomFilter:
    """
    å¸ƒéš†è¿‡æ»¤å™¨ - æ¦‚ç‡æ€§æ•°æ®ç»“æ„
    ç”¨äºåˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­ï¼Œå¯èƒ½æœ‰è¯¯æŠ¥ï¼Œä½†ä¸ä¼šæœ‰æ¼æŠ¥
    """
    def __init__(self, capacity, error_rate=0.01):
        self.capacity = capacity
        self.error_rate = error_rate

        # è®¡ç®—æœ€ä¼˜çš„bitæ•°å’Œå“ˆå¸Œå‡½æ•°æ•°
        self.bit_size = self._calculate_bit_size(capacity, error_rate)
        self.hash_count = self._calculate_hash_count(self.bit_size, capacity)

        # åˆå§‹åŒ–ä½æ•°ç»„
        self.bit_array = [0] * self.bit_size

    def _calculate_bit_size(self, n, p):
        """è®¡ç®—éœ€è¦çš„bitæ•°"""
        m = -(n * math.log(p)) / (math.log(2) ** 2)
        return int(m)

    def _calculate_hash_count(self, m, n):
        """è®¡ç®—éœ€è¦çš„å“ˆå¸Œå‡½æ•°æ•°"""
        k = (m / n) * math.log(2)
        return int(k)

    def add(self, item):
        """æ·»åŠ å…ƒç´ """
        for i in range(self.hash_count):
            # ä½¿ç”¨ä¸åŒçš„ç§å­å€¼åˆ›å»ºå¤šä¸ªå“ˆå¸Œå‡½æ•°
            hash_val = mmh3.hash(str(item), i) % self.bit_size
            self.bit_array[hash_val] = 1

    def __contains__(self, item):
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯èƒ½å­˜åœ¨"""
        for i in range(self.hash_count):
            hash_val = mmh3.hash(str(item), i) % self.bit_size
            if self.bit_array[hash_val] == 0:
                return False
        return True

    def false_positive_rate(self):
        """è®¡ç®—å½“å‰çš„è¯¯æŠ¥ç‡"""
        n = sum(self.bit_array)  # å®é™…è®¾ç½®çš„bitæ•°
        return (1 - math.exp(-self.hash_count * n / self.bit_size)) ** self.hash_count

# ä½¿ç”¨ç¤ºä¾‹
bf = BloomFilter(1000000, 0.001)  # 100ä¸‡å…ƒç´ ï¼Œ0.1%è¯¯æŠ¥ç‡
bf.add("hello")
bf.add("world")

print("hello" in bf)  # True
print("python" in bf)  # Falseï¼ˆå¯èƒ½è¯¯æŠ¥ä¸ºTrueï¼‰
```

### 3. ä¸€è‡´æ€§å“ˆå¸Œ (Consistent Hashing)

```python
import hashlib

class ConsistentHashRing:
    """
    ä¸€è‡´æ€§å“ˆå¸Œç¯
    ç”¨äºåˆ†å¸ƒå¼ç³»ç»Ÿä¸­å‡å°‘èŠ‚ç‚¹å˜åŒ–æ—¶çš„æ•°æ®è¿ç§»
    """
    def __init__(self, virtual_nodes=100):
        self.ring = {}
        self.sorted_keys = []
        self.virtual_nodes = virtual_nodes

    def _hash(self, key):
        """ä½¿ç”¨SHA256å“ˆå¸Œ"""
        return int(hashlib.sha256(key.encode()).hexdigest(), 16)

    def add_node(self, node):
        """æ·»åŠ èŠ‚ç‚¹"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_val = self._hash(virtual_key)
            self.ring[hash_val] = node
            self.sorted_keys.append(hash_val)

        self.sorted_keys.sort()

    def remove_node(self, node):
        """ç§»é™¤èŠ‚ç‚¹"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_val = self._hash(virtual_key)
            if hash_val in self.ring:
                del self.ring[hash_val]
                self.sorted_keys.remove(hash_val)

    def get_node(self, key):
        """è·å–è´Ÿè´£è¯¥keyçš„èŠ‚ç‚¹"""
        if not self.ring:
            return None

        hash_val = self._hash(str(key))

        # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhash_valçš„èŠ‚ç‚¹
        left, right = 0, len(self.sorted_keys)
        while left < right:
            mid = (left + right) // 2
            if self.sorted_keys[mid] < hash_val:
                left = mid + 1
            else:
                right = mid

        if left == len(self.sorted_keys):
            left = 0

        return self.ring[self.sorted_keys[left]]

    def get_nodes(self, key, replication=3):
        """è·å–keyçš„å¤šä¸ªå‰¯æœ¬èŠ‚ç‚¹"""
        if not self.ring:
            return []

        hash_val = self._hash(str(key))
        nodes = []
        start_index = 0

        # æ‰¾åˆ°èµ·å§‹ä½ç½®
        left, right = 0, len(self.sorted_keys)
        while left < right:
            mid = (left + right) // 2
            if self.sorted_keys[mid] < hash_val:
                left = mid + 1
            else:
                right = mid

        if left == len(self.sorted_keys):
            left = 0

        # æ”¶é›†replicationä¸ªä¸åŒçš„èŠ‚ç‚¹
        while len(nodes) < replication and len(nodes) < len(set(self.ring.values())):
            node = self.ring[self.sorted_keys[left]]
            if node not in nodes:
                nodes.append(node)
            left = (left + 1) % len(self.sorted_keys)

        return nodes

class DistributedCache:
    """
    åˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿç¤ºä¾‹
    ä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œåˆ†é…æ•°æ®
    """
    def __init__(self, nodes):
        self.hash_ring = ConsistentHashRing()
        self.local_caches = {node: {} for node in nodes}

        for node in nodes:
            self.hash_ring.add_node(node)

    def set(self, key, value):
        """è®¾ç½®é”®å€¼å¯¹"""
        nodes = self.hash_ring.get_nodes(key, replication=3)
        for node in nodes:
            self.local_caches[node][key] = value

    def get(self, key):
        """è·å–å€¼"""
        nodes = self.hash_ring.get_nodes(key, replication=3)
        for node in nodes:
            if key in self.local_caches[node]:
                return self.local_caches[node][key]
        return None

    def add_node(self, node):
        """æ·»åŠ ç¼“å­˜èŠ‚ç‚¹"""
        self.hash_ring.add_node(node)
        self.local_caches[node] = {}

        # æ•°æ®è¿ç§»ï¼ˆç®€åŒ–ç‰ˆï¼‰
        for existing_node in self.local_caches:
            if existing_node != node:
                for key, value in self.local_caches[existing_node].items():
                    responsible_nodes = self.hash_ring.get_nodes(key, replication=3)
                    if node in responsible_nodes:
                        self.local_caches[node][key] = value

    def remove_node(self, node):
        """ç§»é™¤ç¼“å­˜èŠ‚ç‚¹"""
        self.hash_ring.remove_node(node)
        del self.local_caches[node]
```

<ExerciseBlock
  title="é«˜çº§å“ˆå¸Œåº”ç”¨"
  question:"åœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨è€Œä¸æ˜¯å“ˆå¸Œè¡¨ï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "å½“éœ€è¦å­˜å‚¨å’Œæ£€ç´¢å®Œæ•´çš„é”®å€¼å¯¹æ—¶",
      correct: false,
      explanation: "å¸ƒéš†è¿‡æ»¤å™¨ä¸å­˜å‚¨å®é™…å€¼ï¼Œåªæ”¯æŒå­˜åœ¨æ€§æ£€æŸ¥"
    },
    {
      id: "b",
      text: "å½“å†…å­˜éå¸¸æœ‰é™ä¸”å…è®¸ä¸€å®šè¯¯æŠ¥æ—¶",
      correct: true,
      explanation: "æ­£ç¡®ï¼å¸ƒéš†è¿‡æ»¤å™¨å†…å­˜æ•ˆç‡æé«˜ï¼Œé€‚åˆå­˜åœ¨æ€§æ£€æŸ¥"
    },
    {
      id: "c",
      text: "å½“éœ€è¦ç²¾ç¡®çš„æŸ¥æ‰¾ç»“æœæ—¶",
      correct: false,
      explanation: "å¸ƒéš†è¿‡æ»¤å™¨æœ‰è¯¯æŠ¥å¯èƒ½ï¼Œä¸é€‚åˆç²¾ç¡®æŸ¥æ‰¾"
    },
    {
      id: "d",
      text: "å½“æ•°æ®é‡å¾ˆå°æ—¶",
      correct: false,
      explanation: "å°æ•°æ®é‡å¯ä»¥ç›´æ¥ä½¿ç”¨å“ˆå¸Œè¡¨"
    }
  ]}
  hint="è€ƒè™‘å¸ƒéš†è¿‡æ»¤å™¨çš„ç‰¹æ€§å’Œé€‚ç”¨åœºæ™¯"
/>

## ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

### 1. Pythonå­—å…¸å†…éƒ¨å®ç°

```python
class PyDictLike:
    """
    æ¨¡æ‹ŸPythonå­—å…¸çš„å®ç°
    Python 3.6+ ä½¿ç”¨å¼€æ”¾å¯»å€æ³•çš„å˜ç§
    """
    def __init__(self):
        self.indices = None   # ç´¢å¼•æ•°ç»„
        self.entries = []     # æ¡ç›®æ•°ç»„
        self.filled = 0       # å·²ä½¿ç”¨çš„æ¡ç›®æ•°
        self.used = 0         # æ€»æ¡ç›®æ•°ï¼ˆåŒ…æ‹¬å·²åˆ é™¤çš„ï¼‰

    def _lookup(self, key):
        """æŸ¥æ‰¾keyçš„ä½ç½®"""
        if not self.indices:
            return -1

        # è®¡ç®—å“ˆå¸Œå€¼
        hash_val = hash(key)
        mask = len(self.indices) - 1
        index = hash_val & mask
        perturb = hash_val

        while True:
            entry_index = self.indices[index]
            if entry_index == -1:
                return -1  # æœªæ‰¾åˆ°

            entry = self.entries[entry_index]
            if entry.key == key and not entry.deleted:
                return entry_index

            # å†²çªå¤„ç†
            perturb = perturb >> 5
            index = (index * 5 + perturb + 1) & mask

    def __setitem__(self, key, value):
        """è®¾ç½®é”®å€¼å¯¹"""
        if self.used * 3 > len(self.entries) * 2:
            self._resize()

        entry_index = self._lookup(key)

        if entry_index != -1:
            # é”®å·²å­˜åœ¨ï¼Œæ›´æ–°å€¼
            self.entries[entry_index].value = value
            return

        # æ·»åŠ æ–°æ¡ç›®
        entry_index = self.used
        self.entries.append(_DictEntry(key, value))
        self.used += 1

        # æ›´æ–°ç´¢å¼•
        if self.indices is None:
            self.indices = [-1] * 8
            mask = len(self.indices) - 1
        else:
            mask = len(self.indices) - 1

        hash_val = hash(key)
        index = hash_val & mask
        perturb = hash_val

        while True:
            if self.indices[index] == -1:
                self.indices[index] = entry_index
                self.filled += 1
                break

            # å†²çªå¤„ç†
            perturb = perturb >> 5
            index = (index * 5 + perturb + 1) & mask

    def __getitem__(self, key):
        """è·å–å€¼"""
        entry_index = self._lookup(key)
        if entry_index == -1:
            raise KeyError(key)
        return self.entries[entry_index].value

    def _resize(self):
        """è°ƒæ•´å¤§å°"""
        old_indices = self.indices
        old_entries = self.entries

        # è®¡ç®—æ–°å¤§å°
        new_size = max(8, len(old_entries) * 2)
        self.indices = [-1] * new_size
        self.entries = []
        self.filled = 0

        # é‡æ–°æ’å…¥æ‰€æœ‰æ¡ç›®
        for entry in old_entries:
            if not entry.deleted:
                self.entries.append(_DictEntry(entry.key, entry.value))

        # é‡å»ºç´¢å¼•
        mask = len(self.indices) - 1
        for entry_index, entry in enumerate(self.entries):
            hash_val = hash(entry.key)
            index = hash_val & mask
            perturb = hash_val

            while True:
                if self.indices[index] == -1:
                    self.indices[index] = entry_index
                    self.filled += 1
                    break

                perturb = perturb >> 5
                index = (index * 5 + perturb + 1) & mask

class _DictEntry:
    """å­—å…¸æ¡ç›®"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.deleted = False
```

### 2. LRUç¼“å­˜å®ç°

```python
from collections import OrderedDict

class LRUCache:
    """
    LRU (Least Recently Used) ç¼“å­˜
    ä½¿ç”¨å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨å®ç°
    """
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.order = OrderedDict()  # ç»´æŠ¤è®¿é—®é¡ºåº

    def get(self, key):
        """è·å–å€¼"""
        if key not in self.cache:
            return -1

        # ç§»åŠ¨åˆ°æœ€å‰é¢ï¼ˆè¡¨ç¤ºæœ€è¿‘ä½¿ç”¨ï¼‰
        self.order.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        """è®¾ç½®å€¼"""
        if key in self.cache:
            # æ›´æ–°å€¼å¹¶ç§»åŠ¨åˆ°æœ€å‰é¢
            self.cache[key] = value
            self.order.move_to_end(key)
            return

        if len(self.cache) >= self.capacity:
            # åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„é¡¹
            oldest_key = next(iter(self.order))
            del self.cache[oldest_key]
            del self.order[oldest_key]

        # æ·»åŠ æ–°é¡¹
        self.cache[key] = value
        self.order[key] = None  # å€¼ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯é¡ºåº

class LFUCache:
    """
    LFU (Least Frequently Used) ç¼“å­˜
    ä½¿ç”¨å“ˆå¸Œè¡¨ + é¢‘ç‡å­—å…¸å®ç°
    """
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> (value, frequency)
        self.freq_map = {}  # frequency -> OrderedDict
        self.min_freq = 0

    def get(self, key):
        if key not in self.cache:
            return -1

        value, freq = self.cache[key]
        self._update_frequency(key, value, freq + 1)
        return value

    def put(self, key, value):
        if self.capacity <= 0:
            return

        if key in self.cache:
            _, freq = self.cache[key]
            self._update_frequency(key, value, freq + 1)
            return

        if len(self.cache) >= self.capacity:
            # åˆ é™¤é¢‘ç‡æœ€ä½çš„é¡¹
            min_freq_keys = self.freq_map[self.min_freq]
            oldest_key = next(iter(min_freq_keys))
            del min_freq_keys[oldest_key]
            del self.cache[oldest_key]

        self.cache[key] = (value, 1)
        self.min_freq = 1
        if 1 not in self.freq_map:
            self.freq_map[1] = OrderedDict()
        self.freq_map[1][key] = None

    def _update_frequency(self, key, value, new_freq):
        # ä»æ—§é¢‘ç‡ä¸­ç§»é™¤
        old_freq = new_freq - 1
        old_freq_map = self.freq_map[old_freq]
        del old_freq_map[key]

        if not old_freq_map and old_freq == self.min_freq:
            self.min_freq = new_freq

        # æ·»åŠ åˆ°æ–°é¢‘ç‡
        if new_freq not in self.freq_map:
            self.freq_map[new_freq] = OrderedDict()
        self.freq_map[new_freq][key] = None

        # æ›´æ–°ç¼“å­˜
        self.cache[key] = (value, new_freq)
```

### 3. åˆ†å¸ƒå¼é”æœåŠ¡

```python
import time
import uuid
import threading

class DistributedLock:
    """
    åˆ†å¸ƒå¼é”å®ç°
    ä½¿ç”¨Redisæˆ–ç±»ä¼¼çš„é”®å€¼å­˜å‚¨
    """
    def __init__(self, redis_client, lock_name, timeout=30):
        self.redis = redis_client
        self.lock_name = lock_name
        self.timeout = timeout
        self.identifier = str(uuid.uuid4())
        self._lock = threading.Lock()

    def acquire(self):
        """è·å–é”"""
        end_time = time.time() + self.timeout

        while time.time() < end_time:
            # ä½¿ç”¨SETå‘½ä»¤çš„åŸå­æ€§
            result = self.redis.set(
                self.lock_name,
                self.identifier,
                nx=True,
                ex=self.timeout
            )

            if result:
                return True

            time.sleep(0.001)  # é¿å…CPUè¿‡åº¦ä½¿ç”¨

        return False

    def release(self):
        """é‡Šæ”¾é”"""
        # ä½¿ç”¨Luaè„šæœ¬ç¡®ä¿åŸå­æ€§
        lua_script = """
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
        """

        result = self.redis.eval(
            lua_script,
            1,
            self.lock_name,
            self.identifier
        )

        return result == 1

    def __enter__(self):
        """ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ”¯æŒ"""
        self.acquire()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ”¯æŒ"""
        self.release()

class RateLimiter:
    """
    ä»¤ç‰Œæ¡¶é™æµå™¨
    ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨ç”¨æˆ·çŠ¶æ€
    """
    def __init__(self, redis_client, capacity, refill_rate):
        self.redis = redis_client
        self.capacity = capacity
        self.refill_rate = refill_rate  # æ¯ç§’è¡¥å……çš„ä»¤ç‰Œæ•°

    def is_allowed(self, user_id):
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…è®¸è®¿é—®"""
        key = f"rate_limit:{user_id}"
        current_time = time.time()

        # ä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§
        lua_script = """
        local key = KEYS[1]
        local current_time = tonumber(ARGV[1])
        local capacity = tonumber(ARGV[2])
        local refill_rate = tonumber(ARGV[3])

        local bucket = redis.call("HMGET", key, "tokens", "last_refill")
        local tokens = tonumber(bucket[1]) or capacity
        local last_refill = tonumber(bucket[2]) or current_time

        -- è®¡ç®—è¡¥å……çš„ä»¤ç‰Œæ•°
        local time_passed = current_time - last_refill
        local tokens_to_add = time_passed * refill_rate
        tokens = math.min(tokens + tokens_to_add, capacity)

        if tokens >= 1 then
            -- æ¶ˆè´¹ä¸€ä¸ªä»¤ç‰Œ
            tokens = tokens - 1
            redis.call("HMSET", key, "tokens", tokens, "last_refill", current_time)
            redis.call("EXPIRE", key, 60)  # 60ç§’è¿‡æœŸ
            return 1
        else
            redis.call("HMSET", key, "tokens", tokens, "last_refill", current_time)
            redis.call("EXPIRE", key, 60)
            return 0
        end
        """

        result = self.redis.eval(
            lua_script,
            1,
            key,
            current_time,
            self.capacity,
            self.refill_rate
        )

        return result == 1
```

## ğŸ“Š æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### å“ˆå¸Œè¡¨æ€§èƒ½æŒ‡æ ‡

```python
def analyze_hash_table_performance():
    """
    å“ˆå¸Œè¡¨æ€§èƒ½åˆ†æ
    """
    import random
    import time

    def test_performance(hash_table_class, operations, data_size):
        # ç”Ÿæˆæµ‹è¯•æ•°æ®
        keys = [f"key_{i}" for i in range(data_size)]
        values = [f"value_{i}" for i in range(data_size)]

        # æ’å…¥æµ‹è¯•
        start_time = time.time()
        hash_table = hash_table_class()
        for key, value in zip(keys, values):
            hash_table.insert(key, value)
        insert_time = time.time() - start_time

        # æŸ¥æ‰¾æµ‹è¯•
        search_times = []
        for _ in range(1000):
            key = random.choice(keys)
            start_time = time.time()
            hash_table.get(key)
            search_times.append(time.time() - start_time)

        avg_search_time = sum(search_times) / len(search_times)

        return {
            "insert_time": insert_time,
            "avg_search_time": avg_search_time,
            "operations": operations
        }

    # æµ‹è¯•ä¸åŒçš„å®ç°
    implementations = {
        "ChainedHashTable": ChainedHashTable,
        "LinearProbingHashTable": LinearProbingHashTable,
        "DynamicHashTable": DynamicHashTable
    }

    results = {}
    for name, impl_class in implementations.items():
        results[name] = test_performance(impl_class, ["insert", "search"], 10000)

    return results

# æ€§èƒ½æ•°æ®ç¤ºä¾‹
performance_data = [
    {"n": 1000, "time": 0.001, "implementation": "ChainedHashTable"},
    {"n": 10000, "time": 0.003, "implementation": "ChainedHashTable"},
    {"n": 100000, "time": 0.008, "implementation": "ChainedHashTable"},
    {"n": 1000000, "time": 0.025, "implementation": "ChainedHashTable"}
]
```

<ComplexityAnalyzer
  title="å“ˆå¸Œè¡¨æ’å…¥æ€§èƒ½åˆ†æ"
  algorithm="é“¾åœ°å€æ³•å“ˆå¸Œè¡¨"
  theoreticalComplexity="O(1) å¹³å‡"
  data={performance_data}
  color="rgb(168, 85, 247)"
/>

<ExerciseBlock
  title="æ€§èƒ½ä¼˜åŒ–"
  question:"å¦‚ä½•ä¼˜åŒ–å“ˆå¸Œè¡¨ä»¥å‡å°‘å“ˆå¸Œå†²çªï¼Ÿ"
  type="multiple-choice"
  difficulty="medium"
  options={[
    {
      id: "a",
      text: "ä½¿ç”¨æ›´å¥½çš„å“ˆå¸Œå‡½æ•°å’Œé€‚å½“çš„è¡¨å¤§å°",
      correct: true,
      explanation: "æ­£ç¡®ï¼å¥½çš„å“ˆå¸Œå‡½æ•°å’Œåˆé€‚çš„è¡¨å¤§å°èƒ½æœ‰æ•ˆå‡å°‘å†²çª"
    },
    {
      id: "b",
      text: "æ€»æ˜¯ä½¿ç”¨çº¿æ€§æ¢æµ‹æ³•",
      correct: false,
      explanation: "ä¸åŒåœºæ™¯é€‚åˆä¸åŒçš„å†²çªè§£å†³æ–¹æ³•"
    },
    {
      id: "c",
      text: "ä½¿ç”¨å¾ˆå°çš„è¡¨å¤§å°ä»¥èŠ‚çœå†…å­˜",
      correct: false,
      explanation: "è¡¨å¤ªå°ä¼šå¢åŠ å†²çªæ¦‚ç‡"
    },
    {
      id: "d",
      text: "é¿å…ä½¿ç”¨å“ˆå¸Œè¡¨ï¼Œä½¿ç”¨å…¶ä»–æ•°æ®ç»“æ„",
      correct: false,
      explanation: "å“ˆå¸Œè¡¨åœ¨æ­£ç¡®ä½¿ç”¨æ—¶æ€§èƒ½å¾ˆå¥½"
    }
  ]}
  hint="è€ƒè™‘å“ˆå¸Œå‡½æ•°è´¨é‡å’Œè´Ÿè½½å› å­çš„å½±å“"
/>

## ğŸ¯ é«˜çº§ä¸»é¢˜

### 1. å¯æ‰©å±•å“ˆå¸Œ

```python
class ExtendibleHashing:
    """
    å¯æ‰©å±•å“ˆå¸Œ - åŠ¨æ€è°ƒæ•´å“ˆå¸Œè¡¨ç»“æ„
    é€‚åˆå¤„ç†å¤§è§„æ¨¡æ•°æ®
    """
    def __init__(self, bucket_size=4):
        self.global_depth = 1
        self.bucket_size = bucket_size
        self.directory = [None] * (2 ** self.global_depth)
        self.buckets = []

    def _hash(self, key):
        """è®¡ç®—å“ˆå¸Œå€¼"""
        return hash(key)

    def _get_index(self, key):
        """è·å–ç›®å½•ç´¢å¼•"""
        hash_val = self._hash(key)
        return hash_val & ((1 << self.global_depth) - 1)

    def insert(self, key, value):
        """æ’å…¥é”®å€¼å¯¹"""
        index = self._get_index(key)

        if self.directory[index] is None:
            bucket = Bucket(self.bucket_size)
            self.directory[index] = bucket
            self.buckets.append(bucket)

        bucket = self.directory[index]

        if not bucket.is_full():
            bucket.insert(key, value)
        else:
            # æ¡¶å·²æ»¡ï¼Œéœ€è¦åˆ†è£‚
            if bucket.local_depth < self.global_depth:
                self._split_bucket(bucket, index)
                self.insert(key, value)  # é‡æ–°æ’å…¥
            else:
                self._expand_directory()
                self.insert(key, value)  # é‡æ–°æ’å…¥

    def _split_bucket(self, bucket, old_index):
        """åˆ†è£‚æ¡¶"""
        bucket.local_depth += 1
        new_bucket = Bucket(self.bucket_size)
        new_bucket.local_depth = bucket.local_depth
        self.buckets.append(new_bucket)

        # é‡æ–°åˆ†é…å…ƒç´ 
        keys_to_move = []
        for item in bucket.items:
            new_index = self._get_index(item.key)
            if new_index != old_index:
                keys_to_move.append(item)

        for item in keys_to_move:
            bucket.items.remove(item)
            new_bucket.insert(item.key, item.value)

        # æ›´æ–°ç›®å½•
        mask = 1 << (bucket.local_depth - 1)
        for i in range(len(self.directory)):
            if (i & mask) == (old_index & mask):
                if (i >> (bucket.local_depth - 1)) & 1:
                    self.directory[i] = new_bucket

    def _expand_directory(self):
        """æ‰©å±•ç›®å½•"""
        self.global_depth += 1
        new_directory = [None] * (2 ** self.global_depth)

        # å¤åˆ¶ç°æœ‰ç›®å½•
        for i in range(len(self.directory)):
            new_directory[i] = self.directory[i]
            new_directory[i + len(self.directory)] = self.directory[i]

        self.directory = new_directory

class Bucket:
    """å¯æ‰©å±•å“ˆå¸Œçš„æ¡¶"""
    def __init__(self, size):
        self.size = size
        self.items = []
        self.local_depth = 1

    def insert(self, key, value):
        self.items.append(HashItem(key, value))

    def is_full(self):
        return len(self.items) >= self.size

class HashItem:
    """å“ˆå¸Œé¡¹"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
```

### 2. å“ˆå¸Œè¡¨çš„å¹¶è¡ŒåŒ–

```python
import threading
from concurrent.futures import ThreadPoolExecutor

class ConcurrentHashTable:
    """
    çº¿ç¨‹å®‰å…¨çš„å“ˆå¸Œè¡¨
    ä½¿ç”¨åˆ†æ®µé”æé«˜å¹¶å‘æ€§èƒ½
    """
    def __init__(self, capacity=16, segments=16):
        self.capacity = capacity
        self.segments = segments
        self.segment_mask = segments - 1
        self.segment_size = capacity // segments

        # åˆ›å»ºåˆ†æ®µ
        self.segments = [Segment(self.segment_size) for _ in range(segments)]

    def _get_segment(self, key):
        """è·å–é”®å¯¹åº”çš„åˆ†æ®µ"""
        hash_val = hash(key)
        return self.segments[hash_val & self.segment_mask]

    def put(self, key, value):
        """æ’å…¥é”®å€¼å¯¹"""
        segment = self._get_segment(key)
        with segment.lock:
            return segment.put(key, value)

    def get(self, key):
        """è·å–å€¼"""
        segment = self._get_segment(key)
        with segment.lock:
            return segment.get(key)

    def remove(self, key):
        """åˆ é™¤é”®å€¼å¯¹"""
        segment = self._get_segment(key)
        with segment.lock:
            return segment.remove(key)

class Segment:
    """å“ˆå¸Œè¡¨åˆ†æ®µ"""
    def __init__(self, capacity):
        self.capacity = capacity
        self.table = [None] * capacity
        self.lock = threading.Lock()
        self.size = 0

    def put(self, key, value):
        index = hash(key) % self.capacity

        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        current = self.table[index]
        while current:
            if current.key == key:
                current.value = value
                return
            current = current.next

        # æ’å…¥æ–°èŠ‚ç‚¹
        new_node = ListNode(key, value)
        new_node.next = self.table[index]
        self.table[index] = new_node
        self.size += 1

    def get(self, key):
        index = hash(key) % self.capacity
        current = self.table[index]

        while current:
            if current.key == key:
                return current.value
            current = current.next

        raise KeyError(key)

    def remove(self, key):
        index = hash(key) % self.capacity
        current = self.table[index]
        prev = None

        while current:
            if current.key == key:
                if prev:
                    prev.next = current.next
                else:
                    self.table[index] = current.next
                self.size -= 1
                return
            prev = current
            current = current.next

        raise KeyError(key)
```

<ExerciseBlock
  title="ç»¼åˆåº”ç”¨"
  question:"è®¾è®¡ä¸€ä¸ªåˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿï¼Œéœ€è¦æ”¯æŒé«˜å¹¶å‘è¯»å†™ã€æ•°æ®åˆ†ç‰‡ã€æ•…éšœè½¬ç§»ã€‚åº”è¯¥å¦‚ä½•è®¾è®¡ï¼Ÿ"
  type="multiple-choice"
  difficulty="hard"
  options={[
    {
      id: "a",
      text: "ä½¿ç”¨å•ä¸ªRediså®ä¾‹å¤„ç†æ‰€æœ‰è¯·æ±‚",
      correct: false,
      explanation: "å•ç‚¹æ•…éšœï¼Œæ— æ³•æ‰©å±•"
    },
    {
      id: "b",
      text: "ä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œè¿›è¡Œæ•°æ®åˆ†ç‰‡ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç‹¬ç«‹å¤„ç†",
      correct: true,
      explanation: "æ­£ç¡®ï¼ä¸€è‡´æ€§å“ˆå¸Œæ”¯æŒåŠ¨æ€æ‰©ç¼©å®¹å’Œæ•…éšœè½¬ç§»"
    },
    {
      id: "c",
      text: "ä½¿ç”¨è½®è¯¢ç®—æ³•åœ¨å¤šä¸ªèŠ‚ç‚¹é—´åˆ†é…è¯·æ±‚",
      correct: false,
      explanation: "è½®è¯¢ä¸è€ƒè™‘æ•°æ®ä¸€è‡´æ€§"
    },
    {
      id: "d",
      text: "æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å®Œæ•´çš„æ•°æ®å‰¯æœ¬",
      correct: false,
      explanation: "å­˜å‚¨æ•ˆç‡ä½ï¼Œæ‰©å±•æ€§å·®"
    }
  ]}
  hint="è€ƒè™‘åˆ†å¸ƒå¼ç³»ç»Ÿçš„CAPç†è®ºå’Œæ•°æ®ä¸€è‡´æ€§"
/>

## ğŸ“ æ€»ç»“ä¸æœ€ä½³å®è·µ

### å…³é”®è¦ç‚¹

1. **å“ˆå¸Œå‡½æ•°é€‰æ‹©**ï¼š
   - è®¡ç®—å¿«é€Ÿï¼Œåˆ†å¸ƒå‡åŒ€
   - æ ¹æ®æ•°æ®ç±»å‹é€‰æ‹©åˆé€‚çš„å“ˆå¸Œç®—æ³•
   - è€ƒè™‘ä½¿ç”¨å…¨åŸŸå“ˆå¸Œé¿å…æœ€åæƒ…å†µ

2. **å†²çªè§£å†³ç­–ç•¥**ï¼š
   - é“¾åœ°å€æ³•ï¼šé€‚åˆè´Ÿè½½å› å­å˜åŒ–å¤§çš„åœºæ™¯
   - å¼€æ”¾å¯»å€æ³•ï¼šç¼“å­˜å‹å¥½ï¼Œå†…å­˜æ•ˆç‡é«˜
   - æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„ç­–ç•¥

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - åŠ¨æ€è°ƒæ•´è¡¨å¤§å°
   - é€‰æ‹©åˆé€‚çš„è´Ÿè½½å› å­é˜ˆå€¼
   - è€ƒè™‘ä½¿ç”¨å¢é‡æ‰©å®¹å‡å°‘æš‚åœæ—¶é—´

### å®é™…åº”ç”¨å»ºè®®

```python
def hash_table_recommendation(use_case: str) -> str:
    """
    æ ¹æ®åº”ç”¨åœºæ™¯æ¨èå“ˆå¸Œè¡¨å®ç°
    """
    recommendations = {
        "general_purpose": "æ ‡å‡†å“ˆå¸Œè¡¨ï¼ˆé“¾åœ°å€æ³•ï¼‰",
        "memory_constrained": "å¼€æ”¾å¯»å€æ³•",
        "high_concurrency": "åˆ†æ®µé”å“ˆå¸Œè¡¨",
        "distributed_system": "ä¸€è‡´æ€§å“ˆå¸Œ",
        "existence_check": "å¸ƒéš†è¿‡æ»¤å™¨",
        "cache_system": "LRU/LFUç¼“å­˜",
        "database_index": "å¯æ‰©å±•å“ˆå¸Œ",
        "real_time_system": "å®Œç¾å“ˆå¸Œï¼ˆç¼–è¯‘æ—¶å·²çŸ¥é”®é›†åˆï¼‰"
    }

    return recommendations.get(use_case, "æ ¹æ®å…·ä½“éœ€æ±‚åˆ†æ")
```

### æ€§èƒ½ç›‘æ§æŒ‡æ ‡

```python
class HashTableMonitor:
    """å“ˆå¸Œè¡¨æ€§èƒ½ç›‘æ§"""
    def __init__(self, hash_table):
        self.hash_table = hash_table

    def get_metrics(self):
        """è·å–æ€§èƒ½æŒ‡æ ‡"""
        metrics = {
            "size": self.hash_table.size,
            "capacity": self.hash_table.capacity,
            "load_factor": self.hash_table.load_factor(),
            "collision_rate": self._calculate_collision_rate(),
            "average_chain_length": self._calculate_average_chain_length(),
            "memory_usage": self._calculate_memory_usage()
        }
        return metrics

    def _calculate_collision_rate(self):
        """è®¡ç®—å†²çªç‡"""
        total_buckets = self.hash_table.capacity
        non_empty_buckets = sum(1 for bucket in self.hash_table.table if bucket)
        return non_empty_buckets / total_buckets

    def _calculate_average_chain_length(self):
        """è®¡ç®—å¹³å‡é“¾é•¿"""
        if isinstance(self.hash_table, ChainedHashTable):
            total_length = sum(self._count_chain_length(bucket)
                             for bucket in self.hash_table.table if bucket)
            non_empty_buckets = sum(1 for bucket in self.hash_table.table if bucket)
            return total_length / non_empty_buckets if non_empty_buckets > 0 else 0
        return 0

    def _count_chain_length(self, bucket):
        """è®¡ç®—é“¾é•¿"""
        length = 0
        current = bucket
        while current:
            length += 1
            current = current.next
        return length

    def _calculate_memory_usage(self):
        """è®¡ç®—å†…å­˜ä½¿ç”¨"""
        # ç®€åŒ–çš„å†…å­˜è®¡ç®—
        base_memory = self.hash_table.capacity * 8  # æŒ‡é’ˆæ•°ç»„
        if isinstance(self.hash_table, ChainedHashTable):
            node_count = self.hash_table.size
            node_size = 48  # æ¯ä¸ªèŠ‚ç‚¹å¤§çº¦48å­—èŠ‚ï¼ˆPythonï¼‰
            return base_memory + node_count * node_size
        return base_memory
```

<ExerciseBlock
  title="ç« èŠ‚æµ‹éªŒ"
  question:"å½“å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­æ¥è¿‘1æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ"
  type="multiple-choice"
  difficulty="easy"
  options={[
    {
      id: "a",
      text: "å“ˆå¸Œè¡¨æ€§èƒ½ä¼šæ˜¾è‘—ä¸‹é™",
      correct: true,
      explanation: "æ­£ç¡®ï¼é«˜è´Ÿè½½å› å­ä¼šå¯¼è‡´å¤§é‡å†²çªï¼Œæ“ä½œæ—¶é—´æ¥è¿‘O(n)"
    },
    {
      id: "b",
      text: "å“ˆå¸Œè¡¨æ€§èƒ½ä¼šæé«˜",
      correct: false,
      explanation: "é«˜è´Ÿè½½å› å­ä¼šé™ä½æ€§èƒ½"
    },
    {
      id: "c",
      text: "å†…å­˜ä½¿ç”¨ä¼šå‡å°‘",
      correct: false,
      explanation: "é«˜è´Ÿè½½å› å­æ—¶å†…å­˜åˆ©ç”¨ç‡é«˜ï¼Œä½†æ€§èƒ½å·®"
    },
    {
      id: "d",
      text: "ä¸ä¼šå½±å“æ€§èƒ½",
      correct: false,
      explanation: "è´Ÿè½½å› å­ç›´æ¥å½±å“å†²çªæ¦‚ç‡å’Œæ€§èƒ½"
    }
  ]}
  hint="è€ƒè™‘è´Ÿè½½å› å­å¯¹å†²çªæ¦‚ç‡çš„å½±å“"
/>

---

## ğŸš€ è¯¾åç»ƒä¹ 

1. **åŸºç¡€ç»ƒä¹ **ï¼šå®ç°å„ç§å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³æ–¹æ³•
2. **è¿›é˜¶ç»ƒä¹ **ï¼šå®ç°å¸ƒéš†è¿‡æ»¤å™¨å’Œä¸€è‡´æ€§å“ˆå¸Œ
3. **å®æˆ˜ç»ƒä¹ **ï¼šè®¾è®¡å¹¶å®ç°ä¸€ä¸ªé«˜æ€§èƒ½çš„ç¼“å­˜ç³»ç»Ÿ
4. **é¡¹ç›®ç»ƒä¹ **ï¼šæ„å»ºåˆ†å¸ƒå¼å“ˆå¸Œè¡¨å’Œç›‘æ§ç³»ç»Ÿ

**è®°ä½**ï¼šå“ˆå¸Œè¡¨æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€å®ç”¨çš„æ•°æ®ç»“æ„ä¹‹ä¸€ï¼ŒæŒæ¡å®ƒçš„åŸç†å’Œä¼˜åŒ–æŠ€å·§å¯¹è§£å†³å®é™…é—®é¢˜è‡³å…³é‡è¦ï¼ğŸ”‘